class RunChecks extends java.lang.Object with ScalaObject {
  def this(): code.snippet.RunChecks = {
    RunChecks.super.this();
    ()
  };
  def render: scala.xml.NodeSeq = intform.FormSubmit.rendered("Run Checks")(js.this.JsCmd.unitToJsCmd(control.Checker.runChecks()))
}
RunChecks: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
          render

final class $anon extends scala.AnyRef {
  def this(): anonymous class $anon = {
    $anon.super.this();
    ()
  };
  def $: String = number.map[String](((x$1: model.Dollars) => x$1.$)).getOrElse[String]("n/a")
}
$anon: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
               $

<static> class ResponseAsset extends _root_.java.lang.Object {
  def this() = _;
  var ticker: String = _;
  var shares: Double = _;
  var price: Double = _;
  var dollars: Double = _
}
ResponseAsset: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
  shares
  ticker
 dollars
   price

class SharesField extends intform.TextField[model.Shares] with ScalaObject {
  <paramaccessor> private[this] val initText: String = _;
  def this(initText: String): code.snippet.SharesField = {
    SharesField.super.this(initText);
    ()
  };
  def produce(): intform.SubmitResult[model.Shares] = try {
    new intform.OK[model.Shares](model.Shares.apply(SharesField.this.text))
  } catch {
    case (_: NumberFormatException) => new intform.Error("Should be a price in dollars")
  }
}
SharesField: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
         produce
 initTex        

sealed abstract class Security extends java.lang.Object with ScalaObject {
  def this(): model.Security = {
    Security.super.this();
    ()
  };
  def *(scale: model.Scale): model.Security;
  def spotValue: model.Dollars
}
Security: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
 spotVal
  $times

class TwitterFrontend extends java.lang.Object with net.liftweb.common.Loggable with ScalaObject {
  <paramaccessor> private[this] val app: AnyRef{val consumerKey: String; val consumerSecret: String; val accessToken: String; val accessTokenSecret: String; val accessUser: String} = _;
  <paramaccessor> private[this] val backend: texttrading.Backend = _;
  def this(app: AnyRef{val consumerKey: String; val consumerSecret: String; val accessToken: String; val accessTokenSecret: String; val accessUser: String}, backend: texttrading.Backend): texttrading.TwitterFrontend = {
    TwitterFrontend.super.this();
    ()
  };
  private[this] val h: dispatch.nio.Http = new dispatch.nio.Http();
  <stable> <accessor> def h: dispatch.nio.Http = TwitterFrontend.this.h;
  private[this] val consumer: dispatch.oauth.Consumer = new dispatch.oauth.Consumer(TwitterFrontend.this.app.consumerKey, TwitterFrontend.this.app.consumerSecret);
  <stable> <accessor> def consumer: dispatch.oauth.Consumer = TwitterFrontend.this.consumer;
  private[this] val token: dispatch.oauth.Token = new dispatch.oauth.Token(TwitterFrontend.this.app.accessToken, TwitterFrontend.this.app.accessTokenSecret);
  <stable> <accessor> def token: dispatch.oauth.Token = TwitterFrontend.this.token;
  def send_to_user(user: String, message: String): TwitterFrontend.this.h.HttpPackage[Unit] = {
    TwitterFrontend.this.logger.debug(scala.this.Predef.augmentString("Sending the following to the user %s: %s").format(user, message));
    TwitterFrontend.this.h.apply[Unit](dispatch.Request.toHandlerVerbs(dispatch.twitter.Status.update("@".+(user).+(" ").+(message), TwitterFrontend.this.consumer, TwitterFrontend.this.token)).>~[Unit](((src: scala.io.Source) => TwitterFrontend.this.logger.debug("Twitter status update returned: ".+(src.getLines().mkString)))))
  };
  def follow_user(user: String): Unit = ();
  private[this] var last_id: Int = 0;
  <accessor> def last_id: Int = TwitterFrontend.this.last_id;
  <accessor> def last_id_=(x$1: Int): Unit = TwitterFrontend.this.last_id = x$1;
  private[this] val run_again: java.lang.Object with net.liftweb.actor.LiftActor = {
    final class $anon extends java.lang.Object with net.liftweb.actor.LiftActor {
      def this(): anonymous class $anon = {
        $anon.super.this();
        ()
      };
      def messageHandler: PartialFunction[Any,Unit] = ((x0$1: Any) => x0$1 match {
        case _ => TwitterFrontend.this.run()
      })
    };
    new $anon()
  };
  <stable> <accessor> def run_again: java.lang.Object with net.liftweb.actor.LiftActor = TwitterFrontend.this.run_again;
  private[this] val user_stream: dispatch.Callback[Unit] = dispatch.twitter.UserStream.open(TwitterFrontend.this.consumer, TwitterFrontend.this.token, scala.None, dispatch.twitter.RepliesMutual, collection.this.Seq.apply[java.lang.String]("@".+(TwitterFrontend.this.app.accessUser)))(((message: net.liftweb.json.JsonAST.JValue) => {
  message.\("text").filter(((check$ifrefutable$1: net.liftweb.json.JsonAST.JValue) => (check$ifrefutable$1: net.liftweb.json.JsonAST.JValue @unchecked) match {
  case (s: String)net.liftweb.json.JsonAST.JString((line @ _)) => true
  case _ => false
})).flatMap[Unit, Any](((x$3: net.liftweb.json.JsonAST.JValue) => (x$3: net.liftweb.json.JsonAST.JValue @unchecked) match {
    case (s: String)net.liftweb.json.JsonAST.JString((line @ _)) => message.\("user").\("screen_name").filter(((check$ifrefutable$2: net.liftweb.json.JsonAST.JValue) => (check$ifrefutable$2: net.liftweb.json.JsonAST.JValue @unchecked) match {
  case (s: String)net.liftweb.json.JsonAST.JString((user @ _)) => true
  case _ => false
})).map[Unit, List[Unit]](((x$2: net.liftweb.json.JsonAST.JValue) => (x$2: net.liftweb.json.JsonAST.JValue @unchecked) match {
      case (s: String)net.liftweb.json.JsonAST.JString((user @ _)) => {
        TwitterFrontend.this.logger.info(scala.this.Predef.augmentString("Twitter user stream recived %s: %s").format(user, line));
        if (user.!=(TwitterFrontend.this.app.accessUser))
          {
            TwitterFrontend.this.follow_user(user);
            TextTrader.runCommand(user, line, TwitterFrontend.this.backend).foreach[TwitterFrontend.this.h.HttpPackage[Unit]](((x$1: String) => TwitterFrontend.this.send_to_user(user, x$1)))
          }
        else
          ()
      }
    }))(immutable.this.List.canBuildFrom[Unit])
  }))(immutable.this.List.canBuildFrom[Unit]);
  ()
})).^!(((x0$2: Throwable) => x0$2 match {
    case (e @ _) => {
      TwitterFrontend.this.logger.error("user stream error ".+(e));
      {
        net.liftweb.util.Schedule.schedule[Symbol](TwitterFrontend.this.run_again, scala.Symbol.apply("yo"), net.liftweb.util.Helpers.intToTimeSpanBuilder(5).seconds);
        ()
      }
    }
  }));
  <stable> <accessor> def user_stream: dispatch.Callback[Unit] = TwitterFrontend.this.user_stream;
  def run(): Unit = {
    TwitterFrontend.this.h.apply[Unit](TwitterFrontend.this.user_stream);
    TwitterFrontend.this.logger.info("started the user stream")
  }
}
TwitterFrontend: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.667
             run follow_ send_to
 backend                        
 last_id                        
     app                        

class ShortThrowableRenderer extends _root_.java.lang.Object with ThrowableRenderer {
  def this() = _;
  def doRender(thrown: Throwable = _): scala.Array[String] = _
}
ShortThrowableRenderer: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
         doRende

sealed abstract class Direction extends java.lang.Object with ScalaObject {
  def this(): code.snippet.Direction = {
    Direction.super.this();
    ()
  };
  def sign(x: model.Dollars): model.Dollars;
  def sign(x: model.Shares): model.Shares;
  def sign(x: Int): Int
}
Direction: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
    sign
    sign
    sign

case class AutoTradeSubmit extends java.lang.Object with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val title: String = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def title: String = AutoTradeSubmit.this.title;
  <caseaccessor> <paramaccessor> private[this] val code: String = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def code: String = AutoTradeSubmit.this.code;
  def this(title: String, code: String): AutoTrades.this.AutoTradeSubmit = {
    AutoTradeSubmit.super.this();
    ()
  };
  <synthetic> def copy(title: String = title, code: String = code): AutoTrades.this.AutoTradeSubmit = new AutoTrades.this.AutoTradeSubmit(title, code);
  <synthetic> def copy$default$2: String @scala.annotation.unchecked.uncheckedVariance = AutoTradeSubmit.this.code;
  <synthetic> def copy$default$1: String @scala.annotation.unchecked.uncheckedVariance = AutoTradeSubmit.this.title;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(AutoTradeSubmit.this);
  override def toString(): String = ScalaRunTime.this._toString(AutoTradeSubmit.this);
  override def equals(x$1: Any): Boolean = AutoTradeSubmit.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (title: String, code: String)AutoTrades.this.AutoTradeSubmit((title$1 @ _), (code$1 @ _)) if title$1.==(title).&&(code$1.==(code)) => x$1.asInstanceOf[AutoTrades.this.AutoTradeSubmit].canEqual(AutoTradeSubmit.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "AutoTradeSubmit";
  override def productArity: Int = 2;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => title
    case 1 => code
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[AutoTrades.this.AutoTradeSubmit]()
}
AutoTradeSubmit: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
    code
   title

final object LoginManager extends java.lang.Object with net.liftweb.common.Loggable with ScalaObject {
  def this(): object code.control.LoginManager = {
    LoginManager.super.this();
    ()
  };
  final case object NotLoggedIn extends scala.`package`.RuntimeException with ScalaObject with Product with Serializable {
    def this(): object code.control.LoginManager.NotLoggedIn = {
      NotLoggedIn.super.this();
      ()
    };
    final override def hashCode(): Int = -187442662;
    override def productPrefix: java.lang.String = "NotLoggedIn";
    override def productArity: Int = 0;
    override def productElement(x$1: Int): Any = x$1 match {
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[object code.control.LoginManager.NotLoggedIn]();
    protected def readResolve(): java.lang.Object = LoginManager.this.NotLoggedIn
  };
  def loggedIn_?: Boolean = LoginManager.this.currentLogin match {
    case (x: String)Some[String](_) => true
    case _ => false
  };
  def loginAsOpenID(id: String): Unit = throw new java.this.lang.IllegalStateException("Not supported");
  def loginAsTwitter(name: String): Unit = {
    sessions.`package`.toColon[Option[String]](LoginManager.this._currentLogin).:=(new Some[String](name));
    model.schema.User.userEnsure(name);
    PortfolioSwitcher.clearOnLogin()
  };
  def logout(): Unit = {
    sessions.`package`.toColon[Option[String]](LoginManager.this._currentLogin).:=(scala.None);
    ()
  };
  def currentLogin: Option[String] = LoginManager.this._currentLogin.is;
  def currentUser: model.schema.User = LoginManager.this.currentLogin match {
    case (x: String)Some[String]((name @ _)) => model.schema.User.userEnsure(name)
    case _ => throw LoginManager.this.NotLoggedIn
  };
  final object _currentLogin extends net.liftweb.http.SessionVar[Option[String]] with ScalaObject {
    def this(): object code.control.LoginManager._currentLogin = {
      _currentLogin.super.this(new Some[java.lang.String]("ellbur_k_a"));
      ()
    }
  }
}
LoginManager: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.333
         loginAs  logout current loggedI loginAs current

final object AggregateField extends java.lang.Object with ScalaObject {
  def this(): object intform.AggregateField = {
    AggregateField.super.this();
    ()
  };
  def apply[A >: Nothing <: Any, F >: Nothing <: up.HList](c: F => A, f: up.KList[intform.Field,F], r: => scala.xml.NodeSeq): intform.AggregateField[A,F] = new intform.AggregateField[A,F](c, f, (() => r));
  private[this] val mapProcess: java.lang.Object with up.~>[intform.Field,Option] = {
    final class $anon extends java.lang.Object with up.~>[intform.Field,Option] {
      def this(): anonymous class $anon = {
        $anon.super.this();
        ()
      };
      def apply[T >: Nothing <: Any](field: intform.Field[T]): Option[T] = field.process()
    };
    new $anon()
  };
  <stable> <accessor> def mapProcess: java.lang.Object with up.~>[intform.Field,Option] = AggregateField.this.mapProcess;
  private[this] val mapExtract: java.lang.Object with up.~>[Option,up.~>.Id] = {
    final class $anon extends java.lang.Object with up.~>[Option,up.~>.Id] {
      def this(): anonymous class $anon = {
        $anon.super.this();
        ()
      };
      def apply[T >: Nothing <: Any](o: Option[T]): T = o match {
        case (x: T)Some[T]((t @ _)) => t
        case _ => throw new java.this.lang.IllegalStateException("Owen doesn\'t know how to use types!")
      }
    };
    new $anon()
  };
  <stable> <accessor> def mapExtract: java.lang.Object with up.~>[Option,up.~>.Id] = AggregateField.this.mapExtract
}
AggregateField: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
           apply

abstract trait UserSchema extends java.lang.Object with ScalaObject { self: model.UserSchema with model.StockSchema with model.DerivativeSchema with model.AuctionSchema with model.CommentSchema with model.DBMagic with model.SchemaErrors with model.VotingSchema with model.AutoTradeSchema => 
  def /*UserSchema*/$init$(): Unit = {
    ()
  };
  private[this] val users: model.Table[UserSchema.this.User] = UserSchema.this.table[UserSchema.this.User];
  implicit <stable> <accessor> def users: model.Table[UserSchema.this.User] = UserSchema.this.users;
  private[this] val portfolios: model.Table[UserSchema.this.Portfolio] = UserSchema.this.table[UserSchema.this.Portfolio];
  implicit <stable> <accessor> def portfolios: model.Table[UserSchema.this.Portfolio] = UserSchema.this.portfolios;
  private[this] val ownerships: model.Table[UserSchema.this.Ownership] = UserSchema.this.table[UserSchema.this.Ownership];
  implicit <stable> <accessor> def ownerships: model.Table[UserSchema.this.Ownership] = UserSchema.this.ownerships;
  private[this] val portfolioInvites: model.Table[UserSchema.this.PortfolioInvite] = UserSchema.this.table[UserSchema.this.PortfolioInvite];
  implicit <stable> <accessor> def portfolioInvites: model.Table[UserSchema.this.PortfolioInvite] = UserSchema.this.portfolioInvites;
  private[this] val leagues: model.Table[UserSchema.this.League] = UserSchema.this.table[UserSchema.this.League];
  implicit <stable> <accessor> def leagues: model.Table[UserSchema.this.League] = UserSchema.this.leagues;
  case class User extends java.lang.Object with model.KL with UserSchema.this.UserOps with UserSchema.this.UserWithComments with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val id: model.package.Key = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def id: model.package.Key = User.this.id;
    <caseaccessor> <paramaccessor> private[this] val username: String = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def username: String = User.this.username;
    <caseaccessor> <paramaccessor> private[this] val lastPortfolio: model.Link[UserSchema.this.Portfolio] = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def lastPortfolio: model.Link[UserSchema.this.Portfolio] = User.this.lastPortfolio;
    def this(id: model.package.Key = model.this.`package`.nextID, username: String, lastPortfolio: model.Link[UserSchema.this.Portfolio]): UserSchema.this.User = {
      User.super.this();
      ()
    };
    <synthetic> def copy(id: model.package.Key = id, username: String = username, lastPortfolio: model.Link[UserSchema.this.Portfolio] = lastPortfolio): UserSchema.this.User = new UserSchema.this.User(id, username, lastPortfolio);
    <synthetic> def copy$default$3: model.Link[UserSchema.this.Portfolio] @scala.annotation.unchecked.uncheckedVariance = User.this.lastPortfolio;
    <synthetic> def copy$default$2: String @scala.annotation.unchecked.uncheckedVariance = User.this.username;
    <synthetic> def copy$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = User.this.id;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(User.this);
    override def toString(): String = ScalaRunTime.this._toString(User.this);
    override def equals(x$1: Any): Boolean = User.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (id: model.package.Key, username: String, lastPortfolio: model.Link[UserSchema.this.Portfolio])UserSchema.this.User((id$1 @ _), (username$1 @ _), (lastPortfolio$1 @ _)) if id$1.==(id).&&(username$1.==(username)).&&(lastPortfolio$1.==(lastPortfolio)) => x$1.asInstanceOf[UserSchema.this.User].canEqual(User.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "User";
    override def productArity: Int = 3;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => id
      case 1 => username
      case 2 => lastPortfolio
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[UserSchema.this.User]()
  };
  case class Portfolio extends java.lang.Object with model.KL with UserSchema.this.PortfolioOps with UserSchema.this.PortfolioWithStocks with UserSchema.this.PortfolioWithDerivatives with UserSchema.this.PortfolioWithAuctions with UserSchema.this.PortfolioWithVotes with UserSchema.this.PortfolioWithAutoTrades with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val id: model.package.Key = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def id: model.package.Key = Portfolio.this.id;
    <caseaccessor> <paramaccessor> private[this] val league: model.Link[UserSchema.this.League] = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def league: model.Link[UserSchema.this.League] = Portfolio.this.league;
    <caseaccessor> <paramaccessor> private[this] val name: String = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def name: String = Portfolio.this.name;
    <caseaccessor> <paramaccessor> private[this] val cash: model.Dollars = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def cash: model.Dollars = Portfolio.this.cash;
    <caseaccessor> <paramaccessor> private[this] val loan: model.Dollars = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def loan: model.Dollars = Portfolio.this.loan;
    <caseaccessor> <paramaccessor> private[this] val rank: Int = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def rank: Int = Portfolio.this.rank;
    def this(id: model.package.Key = model.this.`package`.nextID, league: model.Link[UserSchema.this.League], name: String, cash: model.Dollars, loan: model.Dollars, rank: Int): UserSchema.this.Portfolio = {
      Portfolio.super.this();
      ()
    };
    <synthetic> def copy$default$6: Int @scala.annotation.unchecked.uncheckedVariance = Portfolio.this.rank;
    <synthetic> def copy$default$5: model.Dollars @scala.annotation.unchecked.uncheckedVariance = Portfolio.this.loan;
    <synthetic> def copy$default$4: model.Dollars @scala.annotation.unchecked.uncheckedVariance = Portfolio.this.cash;
    <synthetic> def copy$default$3: String @scala.annotation.unchecked.uncheckedVariance = Portfolio.this.name;
    <synthetic> def copy$default$2: model.Link[UserSchema.this.League] @scala.annotation.unchecked.uncheckedVariance = Portfolio.this.league;
    <synthetic> def copy$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = Portfolio.this.id;
    <synthetic> def copy(id: model.package.Key = id, league: model.Link[UserSchema.this.League] = league, name: String = name, cash: model.Dollars = cash, loan: model.Dollars = loan, rank: Int = rank): UserSchema.this.Portfolio = new UserSchema.this.Portfolio(id, league, name, cash, loan, rank);
    override def hashCode(): Int = ScalaRunTime.this._hashCode(Portfolio.this);
    override def toString(): String = ScalaRunTime.this._toString(Portfolio.this);
    override def equals(x$1: Any): Boolean = Portfolio.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (id: model.package.Key, league: model.Link[UserSchema.this.League], name: String, cash: model.Dollars, loan: model.Dollars, rank: Int)UserSchema.this.Portfolio((id$2 @ _), (league$1 @ _), (name$1 @ _), (cash$1 @ _), (loan$1 @ _), (rank$1 @ _)) if id$2.==(id).&&(league$1.==(league)).&&(name$1.==(name)).&&(cash$1.==(cash)).&&(loan$1.==(loan)).&&(rank$1.==(rank)) => x$1.asInstanceOf[UserSchema.this.Portfolio].canEqual(Portfolio.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "Portfolio";
    override def productArity: Int = 6;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => id
      case 1 => league
      case 2 => name
      case 3 => cash
      case 4 => loan
      case 5 => rank
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[UserSchema.this.Portfolio]()
  };
  case class Ownership extends java.lang.Object with model.KL with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val id: model.package.Key = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def id: model.package.Key = Ownership.this.id;
    <caseaccessor> <paramaccessor> private[this] val user: UserSchema.this.User = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def user: UserSchema.this.User = Ownership.this.user;
    <caseaccessor> <paramaccessor> private[this] val portfolio: UserSchema.this.Portfolio = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def portfolio: UserSchema.this.Portfolio = Ownership.this.portfolio;
    def this(id: model.package.Key = model.this.`package`.nextID, user: UserSchema.this.User, portfolio: UserSchema.this.Portfolio): UserSchema.this.Ownership = {
      Ownership.super.this();
      ()
    };
    <synthetic> def copy(id: model.package.Key = id, user: UserSchema.this.User = user, portfolio: UserSchema.this.Portfolio = portfolio): UserSchema.this.Ownership = new UserSchema.this.Ownership(id, user, portfolio);
    <synthetic> def copy$default$3: UserSchema.this.Portfolio @scala.annotation.unchecked.uncheckedVariance = Ownership.this.portfolio;
    <synthetic> def copy$default$2: UserSchema.this.User @scala.annotation.unchecked.uncheckedVariance = Ownership.this.user;
    <synthetic> def copy$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = Ownership.this.id;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(Ownership.this);
    override def toString(): String = ScalaRunTime.this._toString(Ownership.this);
    override def equals(x$1: Any): Boolean = Ownership.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (id: model.package.Key, user: UserSchema.this.User, portfolio: UserSchema.this.Portfolio)UserSchema.this.Ownership((id$3 @ _), (user$1 @ _), (portfolio$1 @ _)) if id$3.==(id).&&(user$1.==(user)).&&(portfolio$1.==(portfolio)) => x$1.asInstanceOf[UserSchema.this.Ownership].canEqual(Ownership.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "Ownership";
    override def productArity: Int = 3;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => id
      case 1 => user
      case 2 => portfolio
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[UserSchema.this.Ownership]()
  };
  final <synthetic> object Ownership extends scala.runtime.AbstractFunction3[model.package.Key,UserSchema.this.User,UserSchema.this.Portfolio,UserSchema.this.Ownership] with ScalaObject with Serializable {
    def this(): object UserSchema.this.Ownership = {
      Ownership.super.this();
      ()
    };
    final override def toString(): java.lang.String = "Ownership";
    <synthetic> def apply$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
    <synthetic> def init$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
    case <synthetic> def unapply(x$0: UserSchema.this.Ownership): Option[(model.package.Key, UserSchema.this.User, UserSchema.this.Portfolio)] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(model.package.Key, UserSchema.this.User, UserSchema.this.Portfolio)](new (model.package.Key, UserSchema.this.User, UserSchema.this.Portfolio)(x$0.id, x$0.user, x$0.portfolio));
    case <synthetic> def apply(id: model.package.Key = model.this.`package`.nextID, user: UserSchema.this.User, portfolio: UserSchema.this.Portfolio): UserSchema.this.Ownership = new UserSchema.this.Ownership(id, user, portfolio)
  };
  @volatile <synthetic> private[this] var Ownership$module: object UserSchema.this.Ownership = _;
  final <synthetic> <stable> def Ownership: object UserSchema.this.Ownership = new object UserSchema.this.Ownership();
  case class PortfolioInvite extends java.lang.Object with model.KL with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val id: model.package.Key = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def id: model.package.Key = PortfolioInvite.this.id;
    <caseaccessor> <paramaccessor> private[this] val from: UserSchema.this.Portfolio = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def from: UserSchema.this.Portfolio = PortfolioInvite.this.from;
    <caseaccessor> <paramaccessor> private[this] val to: UserSchema.this.User = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def to: UserSchema.this.User = PortfolioInvite.this.to;
    def this(id: model.package.Key = model.this.`package`.nextID, from: UserSchema.this.Portfolio, to: UserSchema.this.User): UserSchema.this.PortfolioInvite = {
      PortfolioInvite.super.this();
      ()
    };
    <synthetic> def copy(id: model.package.Key = id, from: UserSchema.this.Portfolio = from, to: UserSchema.this.User = to): UserSchema.this.PortfolioInvite = new UserSchema.this.PortfolioInvite(id, from, to);
    <synthetic> def copy$default$3: UserSchema.this.User @scala.annotation.unchecked.uncheckedVariance = PortfolioInvite.this.to;
    <synthetic> def copy$default$2: UserSchema.this.Portfolio @scala.annotation.unchecked.uncheckedVariance = PortfolioInvite.this.from;
    <synthetic> def copy$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = PortfolioInvite.this.id;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(PortfolioInvite.this);
    override def toString(): String = ScalaRunTime.this._toString(PortfolioInvite.this);
    override def equals(x$1: Any): Boolean = PortfolioInvite.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (id: model.package.Key, from: UserSchema.this.Portfolio, to: UserSchema.this.User)UserSchema.this.PortfolioInvite((id$4 @ _), (from$1 @ _), (to$1 @ _)) if id$4.==(id).&&(from$1.==(from)).&&(to$1.==(to)) => x$1.asInstanceOf[UserSchema.this.PortfolioInvite].canEqual(PortfolioInvite.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "PortfolioInvite";
    override def productArity: Int = 3;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => id
      case 1 => from
      case 2 => to
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[UserSchema.this.PortfolioInvite]()
  };
  final <synthetic> object PortfolioInvite extends scala.runtime.AbstractFunction3[model.package.Key,UserSchema.this.Portfolio,UserSchema.this.User,UserSchema.this.PortfolioInvite] with ScalaObject with Serializable {
    def this(): object UserSchema.this.PortfolioInvite = {
      PortfolioInvite.super.this();
      ()
    };
    final override def toString(): java.lang.String = "PortfolioInvite";
    <synthetic> def apply$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
    <synthetic> def init$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
    case <synthetic> def unapply(x$0: UserSchema.this.PortfolioInvite): Option[(model.package.Key, UserSchema.this.Portfolio, UserSchema.this.User)] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(model.package.Key, UserSchema.this.Portfolio, UserSchema.this.User)](new (model.package.Key, UserSchema.this.Portfolio, UserSchema.this.User)(x$0.id, x$0.from, x$0.to));
    case <synthetic> def apply(id: model.package.Key = model.this.`package`.nextID, from: UserSchema.this.Portfolio, to: UserSchema.this.User): UserSchema.this.PortfolioInvite = new UserSchema.this.PortfolioInvite(id, from, to)
  };
  @volatile <synthetic> private[this] var PortfolioInvite$module: object UserSchema.this.PortfolioInvite = _;
  final <synthetic> <stable> def PortfolioInvite: object UserSchema.this.PortfolioInvite = new object UserSchema.this.PortfolioInvite();
  case class League extends java.lang.Object with model.KL with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val id: model.package.Key = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def id: model.package.Key = League.this.id;
    <caseaccessor> <paramaccessor> private[this] val name: String = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def name: String = League.this.name;
    <caseaccessor> <paramaccessor> private[this] val startingCash: model.Dollars = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def startingCash: model.Dollars = League.this.startingCash;
    def this(id: model.package.Key = model.this.`package`.nextID, name: String, startingCash: model.Dollars): UserSchema.this.League = {
      League.super.this();
      ()
    };
    <synthetic> def copy(id: model.package.Key = id, name: String = name, startingCash: model.Dollars = startingCash): UserSchema.this.League = new UserSchema.this.League(id, name, startingCash);
    <synthetic> def copy$default$3: model.Dollars @scala.annotation.unchecked.uncheckedVariance = League.this.startingCash;
    <synthetic> def copy$default$2: String @scala.annotation.unchecked.uncheckedVariance = League.this.name;
    <synthetic> def copy$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = League.this.id;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(League.this);
    override def toString(): String = ScalaRunTime.this._toString(League.this);
    override def equals(x$1: Any): Boolean = League.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (id: model.package.Key, name: String, startingCash: model.Dollars)UserSchema.this.League((id$5 @ _), (name$2 @ _), (startingCash$1 @ _)) if id$5.==(id).&&(name$2.==(name)).&&(startingCash$1.==(startingCash)) => x$1.asInstanceOf[UserSchema.this.League].canEqual(League.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "League";
    override def productArity: Int = 3;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => id
      case 1 => name
      case 2 => startingCash
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[UserSchema.this.League]()
  };
  abstract trait UserOps extends java.lang.Object with ScalaObject { self: UserSchema.this.User => 
    def /*UserOps*/$init$(): Unit = {
      ()
    };
    def myPortfolios: List[UserSchema.this.Portfolio] = UserSchema.this.readDB[List[UserSchema.this.Portfolio]](UserSchema.this.ownerships.filter(((x$1: UserSchema.this.Ownership) => x$1.user.~~(this))).map[UserSchema.this.Portfolio, scala.collection.mutable.ArrayBuffer[UserSchema.this.Portfolio]](((x$2: UserSchema.this.Ownership) => x$2.portfolio))(mutable.this.ArrayBuffer.canBuildFrom[UserSchema.this.Portfolio]).toList);
    def userCreatePortfolio(name: String): UserSchema.this.Portfolio = UserSchema.this.editDB[UserSchema.this.Portfolio](UserOps.this.createPortfolio(name));
    def portfolioByName(name: String): UserSchema.this.Portfolio = UserSchema.this.readDB[UserSchema.this.Portfolio](UserSchema.this.ownerships.filter(((x$3: UserSchema.this.Ownership) => x$3.user.~~(this))).map[UserSchema.this.Portfolio, scala.collection.mutable.ArrayBuffer[UserSchema.this.Portfolio]](((x$4: UserSchema.this.Ownership) => x$4.portfolio))(mutable.this.ArrayBuffer.canBuildFrom[UserSchema.this.Portfolio]).filter(((x$5: UserSchema.this.Portfolio) => x$5.name.==(name))).headOption.getOrElse[UserSchema.this.Portfolio](throw UserSchema.this.NoSuchPortfolio));
    def userSwitchPortfolio(port: UserSchema.this.Portfolio): Unit = UserSchema.this.editDB[Unit](UserOps.this.switchPortfolio(port));
    def myPortfolioInvites: List[UserSchema.this.PortfolioInvite] = UserSchema.this.readDB[List[UserSchema.this.PortfolioInvite]](UserSchema.this.portfolioInvites.filter(((x$6: UserSchema.this.PortfolioInvite) => x$6.to.~~(this))).toList);
    def userAcceptInvite(invite: UserSchema.this.PortfolioInvite): Unit = UserSchema.this.editDB[Unit](UserOps.this.acceptInvite(invite));
    def userDeclineInvite(invite: UserSchema.this.PortfolioInvite): UserSchema.this.PortfolioInvite = UserSchema.this.editDB[UserSchema.this.PortfolioInvite](UserOps.this.declineInvite(invite));
    private[model] def createPortfolio(name: String): UserSchema.this.Transaction[UserSchema.this.Portfolio] = {
      if (UserSchema.this.portfolios.exists(((x$7: UserSchema.this.Portfolio) => x$7.name.==(name))))
        throw UserSchema.this.NameInUse
      else
        ();
      val league: UserSchema.this.League = UserSchema.this.League.default();
      val cash: model.Dollars = league.startingCash;
      UserSchema.this.toOps[UserSchema.this.Portfolio]({
  val x$24: String = name;
  val x$25: model.Link[UserSchema.this.League] = model.this.KL.toLink[UserSchema.this.League](league);
  val x$26: model.Dollars = cash;
  val x$27: model.Dollars = cash;
  val x$28: Int(1000) = 1000;
  val x$29: model.package.Key = UserSchema.this.Portfolio.apply$default$1;
  new UserSchema.this.Portfolio(x$29, x$25, x$24, x$26, x$27, 1000)
}).insert(UserSchema.this.portfolios).flatMap[UserSchema.this.Portfolio](((port: UserSchema.this.Portfolio) => UserSchema.this.toOps[UserSchema.this.Ownership]({
  val x$30: UserSchema.this.User = this;
  val x$31: UserSchema.this.Portfolio = port;
  val x$32: model.package.Key = UserSchema.this.Ownership.apply$default$1;
  new UserSchema.this.Ownership(x$32, x$30, x$31)
}).insert(UserSchema.this.ownerships).map[UserSchema.this.Portfolio](((_: UserSchema.this.Ownership) => port))))
    };
    private[model] def switchPortfolio(port: UserSchema.this.Portfolio): UserSchema.this.Transaction[Unit] = UserSchema.this.toOps[UserSchema.this.User](this).update(((t: UserSchema.this.User) => {
      val x$33: model.Link[UserSchema.this.Portfolio] = model.this.KL.toLink[UserSchema.this.Portfolio](port);
      val x$34: model.package.Key = t.copy$default$1;
      val x$35: String = t.copy$default$2;
      t.copy(x$34, x$35, x$33)
    }))(UserSchema.this.users);
    private[model] def acceptInvite(invite: UserSchema.this.PortfolioInvite): UserSchema.this.Transaction[Unit] = UserSchema.this.toOps[UserSchema.this.Ownership]({
  val x$36: UserSchema.this.User = this;
  val x$37: UserSchema.this.Portfolio = invite.from;
  val x$38: model.package.Key = UserSchema.this.Ownership.apply$default$1;
  new UserSchema.this.Ownership(x$38, x$36, x$37)
}).insert(UserSchema.this.ownerships).flatMap[Unit](((_: UserSchema.this.Ownership) => UserSchema.this.toOps[UserSchema.this.PortfolioInvite](invite).delete(UserSchema.this.portfolioInvites).map[Unit](((_: UserSchema.this.PortfolioInvite) => ()))));
    private[model] def declineInvite(invite: UserSchema.this.PortfolioInvite): UserSchema.this.Transaction[UserSchema.this.PortfolioInvite] = UserSchema.this.toOps[UserSchema.this.PortfolioInvite](invite).delete(UserSchema.this.portfolioInvites)
  };
  final object User extends java.lang.Object with ScalaObject with Serializable {
    def this(): object UserSchema.this.User = {
      User.super.this();
      ()
    };
    def byName(name: String): UserSchema.this.User = {
      val u: Option[UserSchema.this.User] = UserSchema.this.users.filter(((x$8: UserSchema.this.User) => x$8.username.==(name))).headOption;
      u.getOrElse[UserSchema.this.User](throw UserSchema.this.NoSuchUser)
    };
    def userEnsure(name: String): UserSchema.this.User = UserSchema.this.editDB[UserSchema.this.User](User.this.ensure(name));
    def isNew(name: String): Product with Serializable = UserSchema.this.editDB[Product with Serializable](try {
      UserSchema.this.Transaction.apply[UserSchema.this.OldUser](new UserSchema.this.OldUser(User.this.byName(name)))
    } catch {
      case UserSchema.this.NoSuchUser => User.this.ensure(name).map[UserSchema.this.NewUser](((x$9: UserSchema.this.User) => new UserSchema.this.NewUser(x$9)))
    });
    private[model] def ensure(name: String): UserSchema.this.Transaction[UserSchema.this.User] = UserSchema.this.toOrCreate[UserSchema.this.User](User.this.byName(name)).orCreate(User.this.newUser(name));
    private[model] def ensureP(name: String): UserSchema.this.Transaction[UserSchema.this.Portfolio] = {
      def port: UserSchema.this.Portfolio = model.this.Link.extract[UserSchema.this.Portfolio](User.this.byName(name).lastPortfolio)(UserSchema.this.portfolios);
      UserSchema.this.toOrCreate[UserSchema.this.Portfolio](port).orCreate(User.this.newUserP(name))
    };
    private[model] def newUserAll(name: String): UserSchema.this.Transaction[(UserSchema.this.User, UserSchema.this.Portfolio)] = {
      val league: UserSchema.this.League = UserSchema.this.League.default();
      val cash: model.Dollars = league.startingCash;
      UserSchema.this.toOps[UserSchema.this.Portfolio]({
  val x$39: String = name;
  val x$40: model.Link[UserSchema.this.League] = model.this.KL.toLink[UserSchema.this.League](UserSchema.this.League.default());
  val x$41: model.Dollars = cash;
  val x$42: model.Dollars = cash;
  val x$43: Int(0) = 0;
  val x$44: model.package.Key = UserSchema.this.Portfolio.apply$default$1;
  new UserSchema.this.Portfolio(x$44, x$40, x$39, x$41, x$42, 0)
}).insert(UserSchema.this.portfolios).flatMap[(UserSchema.this.User, UserSchema.this.Portfolio)](((port: UserSchema.this.Portfolio) => UserSchema.this.toOps[UserSchema.this.User]({
  val x$45: String = name;
  val x$46: model.Link[UserSchema.this.Portfolio] = model.this.KL.toLink[UserSchema.this.Portfolio](port);
  val x$47: model.package.Key = UserSchema.this.User.apply$default$1;
  new UserSchema.this.User(x$47, x$45, x$46)
}).insert(UserSchema.this.users).flatMap[(UserSchema.this.User, UserSchema.this.Portfolio)](((user: UserSchema.this.User) => UserSchema.this.toOps[UserSchema.this.Ownership]({
  val x$48: UserSchema.this.User = user;
  val x$49: UserSchema.this.Portfolio = port;
  val x$50: model.package.Key = UserSchema.this.Ownership.apply$default$1;
  new UserSchema.this.Ownership(x$50, x$48, x$49)
}).insert(UserSchema.this.ownerships).map[(UserSchema.this.User, UserSchema.this.Portfolio)](((_: UserSchema.this.Ownership) => new (UserSchema.this.User, UserSchema.this.Portfolio)(user, port)))))))
    };
    private[model] def newUser(name: String): UserSchema.this.Transaction[UserSchema.this.User] = User.this.newUserAll(name).map[UserSchema.this.User](((x$10: (UserSchema.this.User, UserSchema.this.Portfolio)) => x$10._1));
    private[model] def newUserP(name: String): UserSchema.this.Transaction[UserSchema.this.Portfolio] = User.this.newUserAll(name).map[UserSchema.this.Portfolio](((x$11: (UserSchema.this.User, UserSchema.this.Portfolio)) => x$11._2));
    <synthetic> def apply$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
    <synthetic> def init$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
    case <synthetic> def unapply(x$0: UserSchema.this.User): Option[(model.package.Key, String, model.Link[UserSchema.this.Portfolio])] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(model.package.Key, String, model.Link[UserSchema.this.Portfolio])](new (model.package.Key, String, model.Link[UserSchema.this.Portfolio])(x$0.id, x$0.username, x$0.lastPortfolio));
    case <synthetic> def apply(id: model.package.Key = model.this.`package`.nextID, username: String, lastPortfolio: model.Link[UserSchema.this.Portfolio]): UserSchema.this.User = new UserSchema.this.User(id, username, lastPortfolio)
  };
  @volatile <synthetic> private[this] var User$module: object UserSchema.this.User = _;
  final <stable> def User: object UserSchema.this.User = new object UserSchema.this.User();
  final object Portfolio extends java.lang.Object with ScalaObject with Serializable {
    def this(): object UserSchema.this.Portfolio = {
      Portfolio.super.this();
      ()
    };
    def byID(id: model.package.Key): UserSchema.this.Portfolio = UserSchema.this.portfolios.lookup(id).getOrElse[UserSchema.this.Portfolio](throw UserSchema.this.NoSuchPortfolio);
    def byName(name: String): UserSchema.this.Portfolio = UserSchema.this.portfolios.filter(((x$12: UserSchema.this.Portfolio) => x$12.name.==(name))).headOption.getOrElse[UserSchema.this.Portfolio](throw UserSchema.this.NoSuchPortfolio);
    def byLeague(league: UserSchema.this.League): scala.collection.mutable.ArrayBuffer[UserSchema.this.Portfolio] = UserSchema.this.portfolios.filter(((x$13: UserSchema.this.Portfolio) => x$13.league.id.==(league.id)));
    <synthetic> def apply$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
    <synthetic> def init$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
    case <synthetic> def unapply(x$0: UserSchema.this.Portfolio): Option[(model.package.Key, model.Link[UserSchema.this.League], String, model.Dollars, model.Dollars, Int)] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(model.package.Key, model.Link[UserSchema.this.League], String, model.Dollars, model.Dollars, Int)](new (model.package.Key, model.Link[UserSchema.this.League], String, model.Dollars, model.Dollars, Int)(x$0.id, x$0.league, x$0.name, x$0.cash, x$0.loan, x$0.rank));
    case <synthetic> def apply(id: model.package.Key = model.this.`package`.nextID, league: model.Link[UserSchema.this.League], name: String, cash: model.Dollars, loan: model.Dollars, rank: Int): UserSchema.this.Portfolio = new UserSchema.this.Portfolio(id, league, name, cash, loan, rank)
  };
  @volatile <synthetic> private[this] var Portfolio$module: object UserSchema.this.Portfolio = _;
  final <stable> def Portfolio: object UserSchema.this.Portfolio = new object UserSchema.this.Portfolio();
  sealed abstract trait IsNewUser extends scala.AnyRef;
  case class NewUser extends java.lang.Object with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val user: UserSchema.this.User = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def user: UserSchema.this.User = NewUser.this.user;
    def this(user: UserSchema.this.User): UserSchema.this.NewUser = {
      NewUser.super.this();
      ()
    };
    <synthetic> def copy(user: UserSchema.this.User = user): UserSchema.this.NewUser = new UserSchema.this.NewUser(user);
    <synthetic> def copy$default$1: UserSchema.this.User @scala.annotation.unchecked.uncheckedVariance = NewUser.this.user;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(NewUser.this);
    override def toString(): String = ScalaRunTime.this._toString(NewUser.this);
    override def equals(x$1: Any): Boolean = NewUser.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (user: UserSchema.this.User)UserSchema.this.NewUser((user$2 @ _)) if user$2.==(user) => x$1.asInstanceOf[UserSchema.this.NewUser].canEqual(NewUser.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "NewUser";
    override def productArity: Int = 1;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => user
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[UserSchema.this.NewUser]()
  };
  final <synthetic> object NewUser extends scala.runtime.AbstractFunction1[UserSchema.this.User,UserSchema.this.NewUser] with ScalaObject with Serializable {
    def this(): object UserSchema.this.NewUser = {
      NewUser.super.this();
      ()
    };
    final override def toString(): java.lang.String = "NewUser";
    case <synthetic> def unapply(x$0: UserSchema.this.NewUser): Option[UserSchema.this.User] = if (x$0.==(null))
      scala.this.None
    else
      new Some[UserSchema.this.User](x$0.user);
    case <synthetic> def apply(user: UserSchema.this.User): UserSchema.this.NewUser = new UserSchema.this.NewUser(user)
  };
  @volatile <synthetic> private[this] var NewUser$module: object UserSchema.this.NewUser = _;
  final <synthetic> <stable> def NewUser: object UserSchema.this.NewUser = new object UserSchema.this.NewUser();
  case class OldUser extends java.lang.Object with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val user: UserSchema.this.User = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def user: UserSchema.this.User = OldUser.this.user;
    def this(user: UserSchema.this.User): UserSchema.this.OldUser = {
      OldUser.super.this();
      ()
    };
    <synthetic> def copy(user: UserSchema.this.User = user): UserSchema.this.OldUser = new UserSchema.this.OldUser(user);
    <synthetic> def copy$default$1: UserSchema.this.User @scala.annotation.unchecked.uncheckedVariance = OldUser.this.user;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(OldUser.this);
    override def toString(): String = ScalaRunTime.this._toString(OldUser.this);
    override def equals(x$1: Any): Boolean = OldUser.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (user: UserSchema.this.User)UserSchema.this.OldUser((user$3 @ _)) if user$3.==(user) => x$1.asInstanceOf[UserSchema.this.OldUser].canEqual(OldUser.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "OldUser";
    override def productArity: Int = 1;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => user
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[UserSchema.this.OldUser]()
  };
  final <synthetic> object OldUser extends scala.runtime.AbstractFunction1[UserSchema.this.User,UserSchema.this.OldUser] with ScalaObject with Serializable {
    def this(): object UserSchema.this.OldUser = {
      OldUser.super.this();
      ()
    };
    final override def toString(): java.lang.String = "OldUser";
    case <synthetic> def unapply(x$0: UserSchema.this.OldUser): Option[UserSchema.this.User] = if (x$0.==(null))
      scala.this.None
    else
      new Some[UserSchema.this.User](x$0.user);
    case <synthetic> def apply(user: UserSchema.this.User): UserSchema.this.OldUser = new UserSchema.this.OldUser(user)
  };
  @volatile <synthetic> private[this] var OldUser$module: object UserSchema.this.OldUser = _;
  final <synthetic> <stable> def OldUser: object UserSchema.this.OldUser = new object UserSchema.this.OldUser();
  abstract trait PortfolioOps extends java.lang.Object with ScalaObject { self: UserSchema.this.Portfolio with UserSchema.this.PortfolioWithStocks with UserSchema.this.PortfolioWithDerivatives => 
    def /*PortfolioOps*/$init$(): Unit = {
      ()
    };
    def spotValue: model.Dollars = PortfolioOps.this.cash.+(PortfolioOps.this.myStockAssets.map[model.Dollars, List[model.Dollars]](((x$14: UserSchema.this.StockAsset) => x$14.dollars))(immutable.this.List.canBuildFrom[model.Dollars]).foldLeft[model.Dollars](new model.Dollars(math.this.BigDecimal.int2bigDecimal(0)))(((x$15: model.Dollars, x$16: model.Dollars) => x$15.+(x$16)))).+(PortfolioOps.this.myDerivativeAssets.map[model.Dollars, List[model.Dollars]](((x$17: UserSchema.this.DerivativeAsset) => x$17.spotValue))(immutable.this.List.canBuildFrom[model.Dollars]).foldLeft[model.Dollars](new model.Dollars(math.this.BigDecimal.int2bigDecimal(0)))(((x$18: model.Dollars, x$19: model.Dollars) => x$18.+(x$19))));
    def userInviteUser(user: UserSchema.this.User): UserSchema.this.PortfolioInvite = UserSchema.this.editDB[UserSchema.this.PortfolioInvite](PortfolioOps.this.inviteUser(user));
    def owners: List[UserSchema.this.User] = UserSchema.this.readDB[List[UserSchema.this.User]](UserSchema.this.ownerships.filter(((x$20: UserSchema.this.Ownership) => x$20.portfolio.~~(this))).map[UserSchema.this.User, scala.collection.mutable.ArrayBuffer[UserSchema.this.User]](((x$21: UserSchema.this.Ownership) => x$21.user))(mutable.this.ArrayBuffer.canBuildFrom[UserSchema.this.User]).toList);
    def isOwnedBy(user: UserSchema.this.User): Boolean = PortfolioOps.this.owners.exists(((x$22: UserSchema.this.User) => x$22.~~(user)));
    private[model] def inviteUser(user: UserSchema.this.User): UserSchema.this.Transaction[UserSchema.this.PortfolioInvite] = UserSchema.this.toOps[UserSchema.this.PortfolioInvite]({
  val x$51: UserSchema.this.Portfolio with UserSchema.this.PortfolioWithStocks with UserSchema.this.PortfolioWithDerivatives = this;
  val x$52: UserSchema.this.User = user;
  val x$53: model.package.Key = UserSchema.this.PortfolioInvite.apply$default$1;
  new UserSchema.this.PortfolioInvite(x$53, x$51, x$52)
}).insert(UserSchema.this.portfolioInvites)
  };
  final object League extends java.lang.Object with ScalaObject with Serializable {
    def this(): object UserSchema.this.League = {
      League.super.this();
      ()
    };
    private[this] val defaultName: java.lang.String = "default";
    <stable> <accessor> def defaultName: java.lang.String = League.this.defaultName;
    private[this] val defaultStartingCash: model.Dollars = new model.Dollars(math.this.BigDecimal.int2bigDecimal(200000));
    <stable> <accessor> def defaultStartingCash: model.Dollars = League.this.defaultStartingCash;
    def leagueEnsure(name: String): UserSchema.this.League = UserSchema.this.editDB[UserSchema.this.League](UserSchema.this.toOrCreateOpt[UserSchema.this.League](League.this.byName(name)).orCreate(UserSchema.this.toOps[UserSchema.this.League]({
  val x$54: String = name;
  val x$55: model.Dollars = League.this.defaultStartingCash;
  val x$56: model.package.Key = UserSchema.this.League.apply$default$1;
  new UserSchema.this.League(x$56, x$54, x$55)
}).insert(UserSchema.this.leagues)));
    def default(): UserSchema.this.League = League.this.leagueEnsure(League.this.defaultName);
    def byName(name: String): Option[UserSchema.this.League] = UserSchema.this.leagues.filter(((x$23: UserSchema.this.League) => x$23.name.==(name))).headOption;
    def byID(id: model.package.Key): Option[UserSchema.this.League] = UserSchema.this.leagues.lookup(id);
    <synthetic> def apply$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
    <synthetic> def init$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
    case <synthetic> def unapply(x$0: UserSchema.this.League): Option[(model.package.Key, String, model.Dollars)] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(model.package.Key, String, model.Dollars)](new (model.package.Key, String, model.Dollars)(x$0.id, x$0.name, x$0.startingCash));
    case <synthetic> def apply(id: model.package.Key = model.this.`package`.nextID, name: String, startingCash: model.Dollars): UserSchema.this.League = new UserSchema.this.League(id, name, startingCash)
  };
  @volatile <synthetic> private[this] var League$module: object UserSchema.this.League = _;
  final <stable> def League: object UserSchema.this.League = new object UserSchema.this.League()
}
UserSchema: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=1.000
          League    User Portfol
 OldUser                        
 Portfol                        
 Ownersh                        
 League$                        
 User$mo                        
 NewUser                        
 Portfol                        

class OutgoingOffers extends java.lang.Object with code.comet.Refreshable with net.liftweb.common.Loggable with ScalaObject {
  def this(): code.comet.OutgoingOffers = {
    OutgoingOffers.super.this();
    ()
  };
  def registerWith: model.Table[model.schema.AuctionOffer] = model.schema.auctionOffers;
  def render: net.liftweb.http.RenderOut = model.schema.readDB[net.liftweb.http.RenderOut]({
    try {
      val port: model.schema.Portfolio = control.PortfolioSwitcher.currentPortfolio;
      val offers: Seq[model.schema.AuctionOffer] = port.auctionOffers;
      lazy var all$lzy: scala.xml.Elem = _;
      <stable> <accessor> lazy def all: scala.xml.Elem = {
        all$lzy = {
          {
            var $md: scala.xml.MetaData = scala.xml.Null;
            $md = new scala.xml.UnprefixedAttribute("id", new scala.xml.Text("outgoing-offers"), $md);
            $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("block"), $md);
            new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
              val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
              $buf.&+(new scala.xml.Text("\012                    "));
              $buf.&+({
                {
                  new scala.xml.Elem(null, "h2", scala.xml.Null, scala.this.Predef.$scope, ({
                    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                    $buf.&+(new scala.xml.Text("Offers at Auction"));
                    $buf
                  }: _*))
                }
              });
              $buf.&+(new scala.xml.Text("\012                    "));
              $buf.&+({
                {
                  new scala.xml.Elem(null, "p", scala.xml.Null, scala.this.Predef.$scope, ({
                    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                    $buf.&+(new scala.xml.Text("You have offered one or more derivatives to an open\012                    auction. Monitor their current prices below and use the\012                    \"close\" button to confirm the sale."));
                    $buf
                  }: _*))
                }
              });
              $buf.&+(new scala.xml.Text("\012                    \012                    "));
              $buf.&+({
                {
                  var $md: scala.xml.MetaData = scala.xml.Null;
                  $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("boxy"), $md);
                  new scala.xml.Elem(null, "table", $md, scala.this.Predef.$scope, ({
                    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                    $buf.&+(new scala.xml.Text("\012                        "));
                    $buf.&+({
                      {
                        new scala.xml.Elem(null, "thead", scala.xml.Null, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(new scala.xml.Text("\012                            "));
                          $buf.&+({
                            {
                              new scala.xml.Elem(null, "tr", scala.xml.Null, scala.this.Predef.$scope, ({
                                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                                $buf.&+(new scala.xml.Text("\012                                "));
                                $buf.&+({
                                  {
                                    new scala.xml.Elem(null, "th", scala.xml.Null, scala.this.Predef.$scope)
                                  }
                                });
                                $buf.&+(new scala.xml.Text("\012                                "));
                                $buf.&+({
                                  {
                                    new scala.xml.Elem(null, "th", scala.xml.Null, scala.this.Predef.$scope, ({
                                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                                      $buf.&+(new scala.xml.Text("Going Price"));
                                      $buf
                                    }: _*))
                                  }
                                });
                                $buf.&+(new scala.xml.Text("\012                                "));
                                $buf.&+({
                                  {
                                    new scala.xml.Elem(null, "th", scala.xml.Null, scala.this.Predef.$scope, ({
                                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                                      $buf.&+(new scala.xml.Text("Bid by"));
                                      $buf
                                    }: _*))
                                  }
                                });
                                $buf.&+(new scala.xml.Text("\012                                "));
                                $buf.&+({
                                  {
                                    new scala.xml.Elem(null, "th", scala.xml.Null, scala.this.Predef.$scope, ({
                                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                                      $buf.&+(new scala.xml.Text("Expires on"));
                                      $buf
                                    }: _*))
                                  }
                                });
                                $buf.&+(new scala.xml.Text("\012                                "));
                                $buf.&+({
                                  {
                                    new scala.xml.Elem(null, "th", scala.xml.Null, scala.this.Predef.$scope, ({
                                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                                      $buf.&+(new scala.xml.Text("Offering"));
                                      $buf
                                    }: _*))
                                  }
                                });
                                $buf.&+(new scala.xml.Text("\012                            "));
                                $buf
                              }: _*))
                            }
                          });
                          $buf.&+(new scala.xml.Text("\012                        "));
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012                        "));
                    $buf.&+({
                      {
                        new scala.xml.Elem(null, "tbody", scala.xml.Null, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(new scala.xml.Text("\012                            "));
                          $buf.&+(offerRows);
                          $buf.&+(new scala.xml.Text("\012                        "));
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012                    "));
                    $buf
                  }: _*))
                }
              });
              $buf.&+(new scala.xml.Text("\012                "));
              $buf
            }: _*))
          }
        };
        all$lzy
      };
      lazy var offerRows$lzy: Seq[scala.xml.Elem] = _;
      <stable> <accessor> lazy def offerRows: Seq[scala.xml.Elem] = {
        offerRows$lzy = offers.map[scala.xml.Elem, Seq[scala.xml.Elem]](((offer: model.schema.AuctionOffer) => {
          val high: Option[model.schema.AuctionBid] = offer.highBid;
          val highBidder: Option[model.Link[model.schema.Portfolio]] = high.map[model.Link[model.schema.Portfolio]](((x$1: model.schema.AuctionBid) => x$1.by));
          lazy var all$lzy: scala.xml.Elem = _;
          <stable> <accessor> lazy def all: scala.xml.Elem = {
            all$lzy = {
              {
                new scala.xml.Elem(null, "tr", scala.xml.Null, scala.this.Predef.$scope, ({
                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                  $buf.&+(new scala.xml.Text("\012                        "));
                  $buf.&+({
                    {
                      new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                        $buf.&+(closeButton.render);
                        $buf
                      }: _*))
                    }
                  });
                  $buf.&+(new scala.xml.Text("\012                        "));
                  $buf.&+({
                    {
                      new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                        $buf.&+(offer.goingPrice.$);
                        $buf
                      }: _*))
                    }
                  });
                  $buf.&+(new scala.xml.Text("\012                        "));
                  $buf.&+({
                    {
                      new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                        $buf.&+(highBidder.map[scala.xml.NodeSeq](((x$2: model.Link[model.schema.Portfolio]) => snippet.PortfolioLink.apply(model.this.Link.extract[model.schema.Portfolio](x$2)(model.schema.portfolios)))).getOrElse[scala.xml.NodeSeq]({
                          {
                            new scala.xml.Elem(null, "span", scala.xml.Null, scala.this.Predef.$scope, ({
                              val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                              $buf.&+(new scala.xml.Text("-"));
                              $buf
                            }: _*))
                          }
                        }));
                        $buf
                      }: _*))
                    }
                  });
                  $buf.&+(new scala.xml.Text("\012                        "));
                  $buf.&+({
                    {
                      new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                        $buf.&+(formats.`package`.dateTimeFormatted(offer.expires).toNearbyString);
                        $buf
                      }: _*))
                    }
                  });
                  $buf.&+(new scala.xml.Text("\012                        "));
                  $buf.&+({
                    {
                      new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                        $buf.&+(formats.`package`.derivativeFormatted(offer.derivative).toHumanString);
                        $buf
                      }: _*))
                    }
                  });
                  $buf.&+(new scala.xml.Text("\012                    "));
                  $buf
                }: _*))
              }
            };
            all$lzy
          };
          lazy var closeButton$lzy: intform.FormSubmit = _;
          <stable> <accessor> lazy def closeButton: intform.FormSubmit = {
            closeButton$lzy = intform.FormSubmit.apply("Close")(offer.userClose());
            closeButton$lzy
          };
          all
        }))(collection.this.Seq.canBuildFrom[scala.xml.Elem]);
        offerRows$lzy
      };
      if (offers.isEmpty)
        OutgoingOffers.this.arrayToRenderOut(immutable.this.Nil)
      else
        OutgoingOffers.this.arrayToRenderOut(all)
    } catch {
      case control.LoginManager.NotLoggedIn => OutgoingOffers.this.arrayToRenderOut(immutable.this.Nil)
    }
  })
}
OutgoingOffers: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=1.000
          render registe

case class Dollars extends java.lang.Object with Ordered[model.Dollars] with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val dollars: scala.math.BigDecimal = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def dollars: scala.math.BigDecimal = Dollars.this.dollars;
  def this(dollars: scala.math.BigDecimal): model.Dollars = {
    Dollars.super.this();
    ()
  };
  def this(str: String): model.Dollars = {
    Dollars.this.this(scala.math.BigDecimal.apply(str));
    ()
  };
  def +(other: model.Dollars): model.Dollars = new model.Dollars(Dollars.this.dollars.+(other.dollars));
  def -(other: model.Dollars): model.Dollars = new model.Dollars(Dollars.this.dollars.-(other.dollars));
  def *(scale: model.Scale): model.Dollars = new model.Dollars(scale.scale.*(Dollars.this.dollars));
  def unary_-: model.Dollars = Dollars.this.copy(Dollars.this.dollars.unary_-);
  def ~/~(price: model.Price): model.Shares = new model.Shares(Dollars.this.dollars./(price.price));
  def /-/(price: model.Price): model.Shares = new model.Shares(model.`package`.bigDecimalOps(Dollars.this.dollars./(price.price)).floor);
  def /(shares: model.Shares): model.Price = new model.Price(Dollars.this.dollars./(shares.shares));
  def compare(other: model.Dollars): Int = Dollars.this.dollars.compare(other.dollars);
  def $: String = if (Dollars.this.dollars.<(math.this.BigDecimal.int2bigDecimal(0)))
    scala.this.Predef.augmentString("-$%.2f").format(Dollars.this.dollars.doubleValue().unary_-)
  else
    scala.this.Predef.augmentString("$%.2f").format(Dollars.this.dollars.doubleValue());
  def $short: String = if (Dollars.this.dollars.>=(math.this.BigDecimal.int2bigDecimal(1000000)))
    scala.this.Predef.augmentString("$%.0fM").format(Dollars.this.dollars.doubleValue()./(1000000))
  else
    if (Dollars.this.dollars.>=(math.this.BigDecimal.int2bigDecimal(1000)))
      scala.this.Predef.augmentString("$%.0fk").format(Dollars.this.dollars.doubleValue()./(1000))
    else
      scala.this.Predef.augmentString("$%.0f").format(Dollars.this.dollars.doubleValue());
  def no$: String = scala.this.Predef.augmentString("%.2f").format(Dollars.this.dollars.doubleValue());
  def double: Double = Dollars.this.dollars.doubleValue();
  <synthetic> def copy$default$1: scala.math.BigDecimal @scala.annotation.unchecked.uncheckedVariance = Dollars.this.dollars;
  <synthetic> def copy(dollars: scala.math.BigDecimal = dollars): model.Dollars = new model.this.Dollars(dollars);
  override def hashCode(): Int = ScalaRunTime.this._hashCode(Dollars.this);
  override def toString(): String = ScalaRunTime.this._toString(Dollars.this);
  override def equals(x$1: Any): Boolean = Dollars.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (dollars: scala.math.BigDecimal)model.Dollars((dollars$1 @ _)) if dollars$1.==(dollars) => x$1.asInstanceOf[model.Dollars].canEqual(Dollars.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "Dollars";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => dollars
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[model.Dollars]()
}
Dollars: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=0.146
         $tilde$  double     no$ $div$mi   $plus    $div  $times       $ unary_$  $short  $minus compare
 dollars     X       X       X       X       X       X       X       X       X       X       X       X  

case class User extends java.lang.Object with model.KL with UserSchema.this.UserOps with UserSchema.this.UserWithComments with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val id: model.package.Key = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def id: model.package.Key = User.this.id;
  <caseaccessor> <paramaccessor> private[this] val username: String = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def username: String = User.this.username;
  <caseaccessor> <paramaccessor> private[this] val lastPortfolio: model.Link[UserSchema.this.Portfolio] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def lastPortfolio: model.Link[UserSchema.this.Portfolio] = User.this.lastPortfolio;
  def this(id: model.package.Key = model.this.`package`.nextID, username: String, lastPortfolio: model.Link[UserSchema.this.Portfolio]): UserSchema.this.User = {
    User.super.this();
    ()
  };
  <synthetic> def copy(id: model.package.Key = id, username: String = username, lastPortfolio: model.Link[UserSchema.this.Portfolio] = lastPortfolio): UserSchema.this.User = new UserSchema.this.User(id, username, lastPortfolio);
  <synthetic> def copy$default$3: model.Link[UserSchema.this.Portfolio] @scala.annotation.unchecked.uncheckedVariance = User.this.lastPortfolio;
  <synthetic> def copy$default$2: String @scala.annotation.unchecked.uncheckedVariance = User.this.username;
  <synthetic> def copy$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = User.this.id;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(User.this);
  override def toString(): String = ScalaRunTime.this._toString(User.this);
  override def equals(x$1: Any): Boolean = User.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (id: model.package.Key, username: String, lastPortfolio: model.Link[UserSchema.this.Portfolio])UserSchema.this.User((id$1 @ _), (username$1 @ _), (lastPortfolio$1 @ _)) if id$1.==(id).&&(username$1.==(username)).&&(lastPortfolio$1.==(lastPortfolio)) => x$1.asInstanceOf[UserSchema.this.User].canEqual(User.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "User";
  override def productArity: Int = 3;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => id
    case 1 => username
    case 2 => lastPortfolio
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[UserSchema.this.User]()
}
User: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
 usernam
 lastPor
      id

final object DollarsField extends java.lang.Object with ScalaObject {
  def this(): object code.snippet.DollarsField = {
    DollarsField.super.this();
    ()
  };
  def apply(i: String = ""): code.snippet.DollarsField = new DollarsField(i);
  <synthetic> def apply$default$1: String @scala.annotation.unchecked.uncheckedVariance = ""
}
DollarsField: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
           apply

final case object Refresh extends java.lang.Object with ScalaObject with Product with Serializable {
  def this(): object model.Refresh = {
    Refresh.super.this();
    ()
  };
  final override def hashCode(): Int = -1544869189;
  final override def toString(): java.lang.String = "Refresh";
  override def productPrefix: java.lang.String = "Refresh";
  override def productArity: Int = 0;
  override def productElement(x$1: Int): Any = x$1 match {
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[object model.Refresh]();
  protected def readResolve(): java.lang.Object = model.this.Refresh
}
Refresh: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
         readRes

class Form[A >: Nothing <: Any] extends java.lang.Object with intform.Processable[A] with intform.InnerFieldRender with intform.FormOuter with intform.Refreshable with ScalaObject {
  <paramaccessor> private[this] val field: intform.Field[A] with intform.Renderable = _;
  <stable> <accessor> <paramaccessor> def field: intform.Field[A] with intform.Renderable = Form.this.field;
  def this(field: intform.Field[A] with intform.Renderable): intform.Form[A] = {
    Form.super.this();
    ()
  };
  def process(): Option[A] = Form.this.field.process();
  def reset(): Unit = Form.this.field.reset()
}
Form: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
           reset process
   field     X       X  

abstract trait FieldErrorRender extends java.lang.Object with intform.FieldRender with ScalaObject {
  private <superaccessor> def super$main: scala.xml.NodeSeq;
  def /*FieldErrorRender*/$init$(): Unit = {
    ()
  };
  def error: Option[String];
  def errorText: String;
  absoverride def main: scala.xml.Elem = {
    {
      var $md: scala.xml.MetaData = scala.xml.Null;
      $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("input-error"), $md);
      new scala.xml.Elem(null, "span", $md, scala.this.Predef.$scope, ({
        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
        $buf.&+(new scala.xml.Text("\012            "));
        $buf.&+(FieldErrorRender.this.super$main);
        $buf.&+(new scala.xml.Text("\012            "));
        $buf.&+(FieldErrorRender.this.error.map[scala.xml.Elem](((message: String) => {
  {
    var $md: scala.xml.MetaData = scala.xml.Null;
    $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("error"), $md);
    new scala.xml.Elem(null, "span", $md, scala.this.Predef.$scope, ({
      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
      $buf.&+(message);
      $buf
    }: _*))
  }
})).getOrElse[scala.collection.immutable.Seq[scala.xml.Node] with Serializable](immutable.this.Nil));
        $buf.&+(new scala.xml.Text("\012        "));
        $buf
      }: _*))
    }
  }
}
FieldErrorRender: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
            main
   error     X  
 super$m     X  
 errorTe        

case class ResponseOption extends java.lang.Object with ScalaObject with Product with Serializable {
  def this(): FailoverStockDatabase.this.ResponseOption = {
    ResponseOption.super.this();
    ()
  };
  override def hashCode(): Int = ScalaRunTime.this._hashCode(ResponseOption.this);
  override def toString(): String = ScalaRunTime.this._toString(ResponseOption.this);
  override def equals(x$1: Any): Boolean = ResponseOption.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case ()FailoverStockDatabase.this.ResponseOption() => x$1.asInstanceOf[FailoverStockDatabase.this.ResponseOption].canEqual(ResponseOption.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "ResponseOption";
  override def productArity: Int = 0;
  override def productElement(x$1: Int): Any = x$1 match {
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[FailoverStockDatabase.this.ResponseOption]()
}
ResponseOption: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

final object Email_bg extends  {
  def this() = _;
  <static> def main(args: scala.Array[String] = _): Unit = _;
  private <static> def getCurrentTime(): String = _;
  <static> def send_email(to_input: String = _, subject_input: String = _, body_input: String = _): Unit = _
}
Email_bg: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.667
         send_em getCurr    main

final object insertTestData extends java.lang.Object with ScalaObject {
  def this(): object bootstrap.liftweb.insertTestData = {
    insertTestData.super.this();
    ()
  };
  def apply(): Unit = {
    val ellburU: model.schema.User = model.schema.User.userEnsure("ellbur_k_a");
    val pitfailU: model.schema.User = model.schema.User.userEnsure("pitfail");
    val ellbur: model.Link[model.schema.Portfolio] = ellburU.lastPortfolio;
    val pitfail: model.Link[model.schema.Portfolio] = pitfailU.lastPortfolio;
    val deriv: model.Derivative = new model.Derivative({
      <synthetic> val x$1: model.SecStock = new model.SecStock("MSFT", new model.Shares(math.this.BigDecimal.int2bigDecimal(30)));
      immutable.this.Nil.::[model.SecStock](x$1)
    }, org.joda.time.DateTime.now().plusDays(7), model.CondAlways, true);
    val offer: model.schema.DerivativeOffer = model.this.Link.extract[model.schema.Portfolio](pitfail)(model.schema.portfolios).userOfferDerivativeTo(model.this.Link.extract[model.schema.Portfolio](ellbur)(model.schema.portfolios), deriv, new model.Dollars(math.this.BigDecimal.int2bigDecimal(1000)));
    val event: model.schema.NewsEvent = model.this.Link.extract[model.schema.Portfolio](ellbur)(model.schema.portfolios).userAcceptOffer(offer.id);
    <synthetic> private[this] val x$2: (model.schema.DerivativeBuyerSetAside, model.schema.DerivativeSellerSetAside) = (event.asVotable: Option[(model.schema.DerivativeBuyerSetAside, model.schema.DerivativeSellerSetAside)] @unchecked) match {
      case (x: (model.schema.DerivativeBuyerSetAside, model.schema.DerivativeSellerSetAside))Some[(model.schema.DerivativeBuyerSetAside, model.schema.DerivativeSellerSetAside)]((_1: model.schema.DerivativeBuyerSetAside, _2: model.schema.DerivativeSellerSetAside)(model.schema.DerivativeBuyerSetAside, model.schema.DerivativeSellerSetAside)((b @ _), (s @ _))) => new (model.schema.DerivativeBuyerSetAside, model.schema.DerivativeSellerSetAside)(b, s)
    };
    val b: model.schema.DerivativeBuyerSetAside = x$2._1;
    val s: model.schema.DerivativeSellerSetAside = x$2._2;
    model.this.Link.extract[model.schema.Portfolio](ellbur)(model.schema.portfolios).userVoteUp(event, b);
    val joejoe: model.schema.Portfolio = pitfailU.userCreatePortfolio("joejoe");
    joejoe.userInviteUser(ellburU);
    def slurpResource(name: String): String = {
      val resource: java.io.InputStream = insertTestData.this.getClass().getClassLoader().getResourceAsStream(name);
      if (resource.==(null))
        scala.sys.`package`.error("Failed to find ".+(name))
      else
        scala.io.Source.fromInputStream(resource)(io.this.Codec.fallbackSystemCodec).mkString
    };
    implicit val _: net.liftweb.json.DefaultFormats.type = net.liftweb.json.DefaultFormats;
    val demoScripts: List[String] = scalaz.Scalaz.mkIdentity[String](scalaz.Scalaz.mkIdentity[java.lang.String]("jsapi/demo-scripts/list.json").|>[String]({
  ((name: String) => slurpResource(name))
})).|>[net.liftweb.json.package.JValue]({
  ((s: String) => net.liftweb.json.`package`.parse(s))
}).extract[List[String]](_, reflect.this.Manifest.classType[List[String]](classOf[scala.collection.immutable.List], reflect.this.Manifest.classType[String](classOf[java.lang.String])));
    demoScripts.foreach[Unit](((script: String) => {
      val code: String = slurpResource("jsapi/demo-scripts/".+(script));
      val trade: model.schema.AutoTrade = model.this.Link.extract[model.schema.Portfolio](ellbur)(model.schema.portfolios).userMakeNewAutoTrade();
      trade.userModify(script, code)
    }));
    model.this.Link.extract[model.schema.Portfolio](pitfail)(model.schema.portfolios).userBuyStock("MSFT", new model.Shares(math.this.BigDecimal.int2bigDecimal(10)));
    model.this.Link.extract[model.schema.Portfolio](pitfail)(model.schema.portfolios).userBuyStock("F", new model.Shares(math.this.BigDecimal.int2bigDecimal(10)));
    model.this.Link.extract[model.schema.Portfolio](pitfail)(model.schema.portfolios).userSellStock("F", new model.Shares(math.this.BigDecimal.int2bigDecimal(2)));
    val now: org.joda.time.DateTime = new org.joda.time.DateTime();
    model.Stocks.syntheticDividends_=(model.Stocks.syntheticDividends.++[stockdata.Dividend, List[stockdata.Dividend]](immutable.this.List.apply[stockdata.Dividend](new stockdata.Dividend("MSFT", now.plusMinutes(1), model.Price.apply("0.30"))))(immutable.this.List.canBuildFrom[stockdata.Dividend]));
    model.schema.systemRecalculateRankings();
    {
      model.schema.systemCheckForDividends();
      ()
    }
  }
}
insertTestData: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
           apply

class GetPortfolio extends HttpServlet {
  import GetPortfolio._;
  def this() = _;
  protected[servlets] def doPost(request: HttpServletRequest = _, response: HttpServletResponse = _): Unit = _
}
GetPortfolio: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
          doPost

abstract trait StockSchema extends java.lang.Object with ScalaObject { schema: model.StockSchema with model.UserSchema with model.DBMagic with model.SchemaErrors with model.NewsSchema => 
  def /*StockSchema*/$init$(): Unit = {
    ()
  };
  private[this] val stockAssets: model.Table[StockSchema.this.StockAsset] = StockSchema.this.table[StockSchema.this.StockAsset];
  implicit <stable> <accessor> def stockAssets: model.Table[StockSchema.this.StockAsset] = StockSchema.this.stockAssets;
  case class StockAsset extends java.lang.Object with model.KL with StockSchema.this.StockAssetOps with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val id: model.package.Key = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def id: model.package.Key = StockAsset.this.id;
    <caseaccessor> <paramaccessor> private[this] val ticker: String = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def ticker: String = StockAsset.this.ticker;
    <caseaccessor> <paramaccessor> private[this] val shares: model.Shares = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def shares: model.Shares = StockAsset.this.shares;
    <caseaccessor> <paramaccessor> private[this] val owner: model.Link[StockSchema.this.Portfolio] = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def owner: model.Link[StockSchema.this.Portfolio] = StockAsset.this.owner;
    <caseaccessor> <paramaccessor> private[this] val purchasePrice: model.Price = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def purchasePrice: model.Price = StockAsset.this.purchasePrice;
    <caseaccessor> <paramaccessor> private[this] val notifiedPrice: model.Price = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def notifiedPrice: model.Price = StockAsset.this.notifiedPrice;
    <caseaccessor> <paramaccessor> private[this] val purchaseDate: org.joda.time.DateTime = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def purchaseDate: org.joda.time.DateTime = StockAsset.this.purchaseDate;
    <caseaccessor> <paramaccessor> private[this] val lastDividendDate: org.joda.time.DateTime = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def lastDividendDate: org.joda.time.DateTime = StockAsset.this.lastDividendDate;
    <caseaccessor> <paramaccessor> private[this] val totalDividends: model.Dollars = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def totalDividends: model.Dollars = StockAsset.this.totalDividends;
    def this(id: model.package.Key = model.this.`package`.nextID, ticker: String, shares: model.Shares, owner: model.Link[StockSchema.this.Portfolio], purchasePrice: model.Price, notifiedPrice: model.Price, purchaseDate: org.joda.time.DateTime, lastDividendDate: org.joda.time.DateTime, totalDividends: model.Dollars): StockSchema.this.StockAsset = {
      StockAsset.super.this();
      ()
    };
    <synthetic> def copy$default$9: model.Dollars @scala.annotation.unchecked.uncheckedVariance = StockAsset.this.totalDividends;
    <synthetic> def copy$default$8: org.joda.time.DateTime @scala.annotation.unchecked.uncheckedVariance = StockAsset.this.lastDividendDate;
    <synthetic> def copy$default$7: org.joda.time.DateTime @scala.annotation.unchecked.uncheckedVariance = StockAsset.this.purchaseDate;
    <synthetic> def copy$default$6: model.Price @scala.annotation.unchecked.uncheckedVariance = StockAsset.this.notifiedPrice;
    <synthetic> def copy$default$5: model.Price @scala.annotation.unchecked.uncheckedVariance = StockAsset.this.purchasePrice;
    <synthetic> def copy$default$4: model.Link[StockSchema.this.Portfolio] @scala.annotation.unchecked.uncheckedVariance = StockAsset.this.owner;
    <synthetic> def copy$default$3: model.Shares @scala.annotation.unchecked.uncheckedVariance = StockAsset.this.shares;
    <synthetic> def copy$default$2: String @scala.annotation.unchecked.uncheckedVariance = StockAsset.this.ticker;
    <synthetic> def copy$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = StockAsset.this.id;
    <synthetic> def copy(id: model.package.Key = id, ticker: String = ticker, shares: model.Shares = shares, owner: model.Link[StockSchema.this.Portfolio] = owner, purchasePrice: model.Price = purchasePrice, notifiedPrice: model.Price = notifiedPrice, purchaseDate: org.joda.time.DateTime = purchaseDate, lastDividendDate: org.joda.time.DateTime = lastDividendDate, totalDividends: model.Dollars = totalDividends): StockSchema.this.StockAsset = new StockSchema.this.StockAsset(id, ticker, shares, owner, purchasePrice, notifiedPrice, purchaseDate, lastDividendDate, totalDividends);
    override def hashCode(): Int = ScalaRunTime.this._hashCode(StockAsset.this);
    override def toString(): String = ScalaRunTime.this._toString(StockAsset.this);
    override def equals(x$1: Any): Boolean = StockAsset.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (id: model.package.Key, ticker: String, shares: model.Shares, owner: model.Link[StockSchema.this.Portfolio], purchasePrice: model.Price, notifiedPrice: model.Price, purchaseDate: org.joda.time.DateTime, lastDividendDate: org.joda.time.DateTime, totalDividends: model.Dollars)StockSchema.this.StockAsset((id$1 @ _), (ticker$1 @ _), (shares$1 @ _), (owner$1 @ _), (purchasePrice$1 @ _), (notifiedPrice$1 @ _), (purchaseDate$1 @ _), (lastDividendDate$1 @ _), (totalDividends$1 @ _)) if id$1.==(id).&&(ticker$1.==(ticker)).&&(shares$1.==(shares)).&&(owner$1.==(owner)).&&(purchasePrice$1.==(purchasePrice)).&&(notifiedPrice$1.==(notifiedPrice)).&&(purchaseDate$1.==(purchaseDate)).&&(lastDividendDate$1.==(lastDividendDate)).&&(totalDividends$1.==(totalDividends)) => x$1.asInstanceOf[StockSchema.this.StockAsset].canEqual(StockAsset.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "StockAsset";
    override def productArity: Int = 9;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => id
      case 1 => ticker
      case 2 => shares
      case 3 => owner
      case 4 => purchasePrice
      case 5 => notifiedPrice
      case 6 => purchaseDate
      case 7 => lastDividendDate
      case 8 => totalDividends
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[StockSchema.this.StockAsset]()
  };
  final <synthetic> object StockAsset extends scala.runtime.AbstractFunction9[model.package.Key,String,model.Shares,model.Link[StockSchema.this.Portfolio],model.Price,model.Price,org.joda.time.DateTime,org.joda.time.DateTime,model.Dollars,StockSchema.this.StockAsset] with ScalaObject with Serializable {
    def this(): object StockSchema.this.StockAsset = {
      StockAsset.super.this();
      ()
    };
    final override def toString(): java.lang.String = "StockAsset";
    <synthetic> def apply$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
    <synthetic> def init$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
    case <synthetic> def unapply(x$0: StockSchema.this.StockAsset): Option[(model.package.Key, String, model.Shares, model.Link[StockSchema.this.Portfolio], model.Price, model.Price, org.joda.time.DateTime, org.joda.time.DateTime, model.Dollars)] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(model.package.Key, String, model.Shares, model.Link[StockSchema.this.Portfolio], model.Price, model.Price, org.joda.time.DateTime, org.joda.time.DateTime, model.Dollars)](new (model.package.Key, String, model.Shares, model.Link[StockSchema.this.Portfolio], model.Price, model.Price, org.joda.time.DateTime, org.joda.time.DateTime, model.Dollars)(x$0.id, x$0.ticker, x$0.shares, x$0.owner, x$0.purchasePrice, x$0.notifiedPrice, x$0.purchaseDate, x$0.lastDividendDate, x$0.totalDividends));
    case <synthetic> def apply(id: model.package.Key = model.this.`package`.nextID, ticker: String, shares: model.Shares, owner: model.Link[StockSchema.this.Portfolio], purchasePrice: model.Price, notifiedPrice: model.Price, purchaseDate: org.joda.time.DateTime, lastDividendDate: org.joda.time.DateTime, totalDividends: model.Dollars): StockSchema.this.StockAsset = new StockSchema.this.StockAsset(id, ticker, shares, owner, purchasePrice, notifiedPrice, purchaseDate, lastDividendDate, totalDividends)
  };
  @volatile <synthetic> private[this] var StockAsset$module: object StockSchema.this.StockAsset = _;
  final <synthetic> <stable> def StockAsset: object StockSchema.this.StockAsset = new object StockSchema.this.StockAsset();
  case class StockPurchase extends java.lang.Object with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val shares: model.Shares = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def shares: model.Shares = StockPurchase.this.shares;
    <caseaccessor> <paramaccessor> private[this] val dollars: model.Dollars = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def dollars: model.Dollars = StockPurchase.this.dollars;
    <caseaccessor> <paramaccessor> private[this] val asset: model.package.Key = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def asset: model.package.Key = StockPurchase.this.asset;
    def this(shares: model.Shares, dollars: model.Dollars, asset: model.package.Key): StockSchema.this.StockPurchase = {
      StockPurchase.super.this();
      ()
    };
    <synthetic> def copy(shares: model.Shares = shares, dollars: model.Dollars = dollars, asset: model.package.Key = asset): StockSchema.this.StockPurchase = new StockSchema.this.StockPurchase(shares, dollars, asset);
    <synthetic> def copy$default$3: model.package.Key @scala.annotation.unchecked.uncheckedVariance = StockPurchase.this.asset;
    <synthetic> def copy$default$2: model.Dollars @scala.annotation.unchecked.uncheckedVariance = StockPurchase.this.dollars;
    <synthetic> def copy$default$1: model.Shares @scala.annotation.unchecked.uncheckedVariance = StockPurchase.this.shares;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(StockPurchase.this);
    override def toString(): String = ScalaRunTime.this._toString(StockPurchase.this);
    override def equals(x$1: Any): Boolean = StockPurchase.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (shares: model.Shares, dollars: model.Dollars, asset: model.package.Key)StockSchema.this.StockPurchase((shares$2 @ _), (dollars$1 @ _), (asset$1 @ _)) if shares$2.==(shares).&&(dollars$1.==(dollars)).&&(asset$1.==(asset)) => x$1.asInstanceOf[StockSchema.this.StockPurchase].canEqual(StockPurchase.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "StockPurchase";
    override def productArity: Int = 3;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => shares
      case 1 => dollars
      case 2 => asset
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[StockSchema.this.StockPurchase]()
  };
  final <synthetic> object StockPurchase extends scala.runtime.AbstractFunction3[model.Shares,model.Dollars,model.package.Key,StockSchema.this.StockPurchase] with ScalaObject with Serializable {
    def this(): object StockSchema.this.StockPurchase = {
      StockPurchase.super.this();
      ()
    };
    final override def toString(): java.lang.String = "StockPurchase";
    case <synthetic> def unapply(x$0: StockSchema.this.StockPurchase): Option[(model.Shares, model.Dollars, model.package.Key)] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(model.Shares, model.Dollars, model.package.Key)](new (model.Shares, model.Dollars, model.package.Key)(x$0.shares, x$0.dollars, x$0.asset));
    case <synthetic> def apply(shares: model.Shares, dollars: model.Dollars, asset: model.package.Key): StockSchema.this.StockPurchase = new StockSchema.this.StockPurchase(shares, dollars, asset)
  };
  @volatile <synthetic> private[this] var StockPurchase$module: object StockSchema.this.StockPurchase = _;
  final <synthetic> <stable> def StockPurchase: object StockSchema.this.StockPurchase = new object StockSchema.this.StockPurchase();
  case class GroupedStockAsset extends java.lang.Object with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val ticker: String = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def ticker: String = GroupedStockAsset.this.ticker;
    <caseaccessor> <paramaccessor> private[this] val shares: model.Shares = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def shares: model.Shares = GroupedStockAsset.this.shares;
    <caseaccessor> <paramaccessor> private[this] val owner: model.Link[StockSchema.this.Portfolio] = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def owner: model.Link[StockSchema.this.Portfolio] = GroupedStockAsset.this.owner;
    <caseaccessor> <paramaccessor> private[this] val purchasePrice: model.Price = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def purchasePrice: model.Price = GroupedStockAsset.this.purchasePrice;
    def this(ticker: String, shares: model.Shares, owner: model.Link[StockSchema.this.Portfolio], purchasePrice: model.Price): StockSchema.this.GroupedStockAsset = {
      GroupedStockAsset.super.this();
      ()
    };
    <synthetic> def copy(ticker: String = ticker, shares: model.Shares = shares, owner: model.Link[StockSchema.this.Portfolio] = owner, purchasePrice: model.Price = purchasePrice): StockSchema.this.GroupedStockAsset = new StockSchema.this.GroupedStockAsset(ticker, shares, owner, purchasePrice);
    <synthetic> def copy$default$4: model.Price @scala.annotation.unchecked.uncheckedVariance = GroupedStockAsset.this.purchasePrice;
    <synthetic> def copy$default$3: model.Link[StockSchema.this.Portfolio] @scala.annotation.unchecked.uncheckedVariance = GroupedStockAsset.this.owner;
    <synthetic> def copy$default$2: model.Shares @scala.annotation.unchecked.uncheckedVariance = GroupedStockAsset.this.shares;
    <synthetic> def copy$default$1: String @scala.annotation.unchecked.uncheckedVariance = GroupedStockAsset.this.ticker;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(GroupedStockAsset.this);
    override def toString(): String = ScalaRunTime.this._toString(GroupedStockAsset.this);
    override def equals(x$1: Any): Boolean = GroupedStockAsset.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (ticker: String, shares: model.Shares, owner: model.Link[StockSchema.this.Portfolio], purchasePrice: model.Price)StockSchema.this.GroupedStockAsset((ticker$2 @ _), (shares$3 @ _), (owner$2 @ _), (purchasePrice$2 @ _)) if ticker$2.==(ticker).&&(shares$3.==(shares)).&&(owner$2.==(owner)).&&(purchasePrice$2.==(purchasePrice)) => x$1.asInstanceOf[StockSchema.this.GroupedStockAsset].canEqual(GroupedStockAsset.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "GroupedStockAsset";
    override def productArity: Int = 4;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => ticker
      case 1 => shares
      case 2 => owner
      case 3 => purchasePrice
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[StockSchema.this.GroupedStockAsset]()
  };
  final <synthetic> object GroupedStockAsset extends scala.runtime.AbstractFunction4[String,model.Shares,model.Link[StockSchema.this.Portfolio],model.Price,StockSchema.this.GroupedStockAsset] with ScalaObject with Serializable {
    def this(): object StockSchema.this.GroupedStockAsset = {
      GroupedStockAsset.super.this();
      ()
    };
    final override def toString(): java.lang.String = "GroupedStockAsset";
    case <synthetic> def unapply(x$0: StockSchema.this.GroupedStockAsset): Option[(String, model.Shares, model.Link[StockSchema.this.Portfolio], model.Price)] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(String, model.Shares, model.Link[StockSchema.this.Portfolio], model.Price)](new (String, model.Shares, model.Link[StockSchema.this.Portfolio], model.Price)(x$0.ticker, x$0.shares, x$0.owner, x$0.purchasePrice));
    case <synthetic> def apply(ticker: String, shares: model.Shares, owner: model.Link[StockSchema.this.Portfolio], purchasePrice: model.Price): StockSchema.this.GroupedStockAsset = new StockSchema.this.GroupedStockAsset(ticker, shares, owner, purchasePrice)
  };
  @volatile <synthetic> private[this] var GroupedStockAsset$module: object StockSchema.this.GroupedStockAsset = _;
  final <synthetic> <stable> def GroupedStockAsset: object StockSchema.this.GroupedStockAsset = new object StockSchema.this.GroupedStockAsset();
  abstract trait StockAssetOps extends java.lang.Object with ScalaObject { self: StockSchema.this.StockAsset => 
    def /*StockAssetOps*/$init$(): Unit = {
      ()
    };
    def price: model.Price = Stocks.stockPrice(StockAssetOps.this.ticker);
    def dollars: model.Dollars = StockAssetOps.this.shares.*(StockAssetOps.this.price)
  };
  abstract trait PortfolioWithStocks extends java.lang.Object with ScalaObject { self: StockSchema.this.Portfolio => 
    def /*PortfolioWithStocks*/$init$(): Unit = {
      ()
    };
    def myStockAssets: List[StockSchema.this.StockAsset] = StockSchema.this.stockAssets.filter(((x$1: StockSchema.this.StockAsset) => x$1.owner.~~(PortfolioWithStocks.this))).toList;
    def myStockAssetsGrouped: Seq[StockSchema.this.GroupedStockAsset] = PortfolioWithStocks.this.myStockAssets.groupBy[String](((x$2: StockSchema.this.StockAsset) => x$2.ticker)).map[StockSchema.this.GroupedStockAsset, scala.collection.immutable.Iterable[StockSchema.this.GroupedStockAsset]](((x0$1: (String, List[StockSchema.this.StockAsset])) => x0$1 match {
  case (_1: String, _2: List[StockSchema.this.StockAsset])(String, List[StockSchema.this.StockAsset])((ticker @ _), (assets @ _)) => new StockSchema.this.GroupedStockAsset(ticker, new model.Shares(assets.map[scala.math.BigDecimal, List[scala.math.BigDecimal]](((x$3: StockSchema.this.StockAsset) => x$3.shares.shares))(immutable.this.List.canBuildFrom[scala.math.BigDecimal]).sum[scala.math.BigDecimal](math.this.Numeric.BigDecimalIsFractional)), model.this.KL.toLink[StockSchema.this.Portfolio](this), {
    val dollars: List[model.Dollars] = assets.map[model.Dollars, List[model.Dollars]](((a: StockSchema.this.StockAsset) => a.shares.*(a.purchasePrice)))(immutable.this.List.canBuildFrom[model.Dollars]);
    val shares: List[model.Shares] = assets.map[model.Shares, List[model.Shares]](((x$4: StockSchema.this.StockAsset) => x$4.shares))(immutable.this.List.canBuildFrom[model.Shares]);
    dollars.reduceLeft[model.Dollars](((x$5: model.Dollars, x$6: model.Dollars) => x$5.+(x$6)))./(shares.reduceLeft[model.Shares](((x$7: model.Shares, x$8: model.Shares) => x$7.+(x$8))))
  })
}))(immutable.this.Iterable.canBuildFrom[StockSchema.this.GroupedStockAsset]).toList;
    def getMyStockAssets: java.util.List[StockSchema.this.StockAsset] = StockSchema.this.readDB[java.util.List[StockSchema.this.StockAsset]](scala.collection.JavaConversions.seqAsJavaList[StockSchema.this.StockAsset](PortfolioWithStocks.this.myStockAssets));
    def howManyShares(ticker: String): model.Shares = StockSchema.this.readDB[model.Shares]({
      val s: scala.math.BigDecimal = PortfolioWithStocks.this.myStockAssets.filter(((x$9: StockSchema.this.StockAsset) => x$9.ticker.==(ticker))).map[scala.math.BigDecimal, List[scala.math.BigDecimal]](((x$10: StockSchema.this.StockAsset) => x$10.shares.shares))(immutable.this.List.canBuildFrom[scala.math.BigDecimal]).sum[scala.math.BigDecimal](math.this.Numeric.BigDecimalIsFractional);
      new model.Shares(s)
    });
    def howManyDollars(ticker: String): model.Dollars = PortfolioWithStocks.this.howManyShares(ticker).*(Stocks.stockPrice(ticker));
    def userBuyStock(ticker: String, shares: model.Shares): StockSchema.this.StockPurchase = StockSchema.this.editDB[StockSchema.this.StockPurchase](PortfolioWithStocks.this.buyStock(ticker, shares));
    def userBuyStock(ticker: String, dollars: model.Dollars): StockSchema.this.StockPurchase = StockSchema.this.editDB[StockSchema.this.StockPurchase](PortfolioWithStocks.this.buyStock(ticker, dollars));
    def userSellStock(ticker: String, shares: model.Shares): Unit = StockSchema.this.editDB[Unit](PortfolioWithStocks.this.sellStock(ticker, shares));
    def userSellStock(ticker: String, dollars: model.Dollars): Unit = StockSchema.this.editDB[Unit](PortfolioWithStocks.this.sellStock(ticker, dollars));
    def userSellAll(ticker: String): Unit = StockSchema.this.editDB[Unit](PortfolioWithStocks.this.sellAll(ticker));
    private[model] def buyStock(ticker: String, shares: model.Shares): StockSchema.this.Transaction[StockSchema.this.StockPurchase] = {
      val price: model.Price = Stocks.stockPrice(ticker);
      PortfolioWithStocks.this.buyStock(ticker, price.*(shares), shares, price)
    };
    private[model] def buyStock(ticker: String, dollars: model.Dollars): StockSchema.this.Transaction[StockSchema.this.StockPurchase] = {
      val price: model.Price = Stocks.stockPrice(ticker);
      PortfolioWithStocks.this.buyStock(ticker, dollars, dollars./-/(price), price)
    };
    private[model] def buyStock(ticker: String, dollars: model.Dollars, shares: model.Shares, price: model.Price): StockSchema.this.Transaction[StockSchema.this.StockPurchase] = {
      if (PortfolioWithStocks.this.cash.<=(dollars))
        throw new StockSchema.this.NotEnoughCash(PortfolioWithStocks.this.cash, dollars)
      else
        ();
      StockSchema.this.toOps[StockSchema.this.StockAsset]({
  val x$19: String = ticker;
  val x$20: model.Shares = shares;
  val x$21: model.Link[StockSchema.this.Portfolio] = model.this.KL.toLink[StockSchema.this.Portfolio](this);
  val x$22: model.Price = price;
  val x$23: model.Price = price;
  val x$24: org.joda.time.DateTime = new org.joda.time.DateTime();
  val x$25: org.joda.time.DateTime = new org.joda.time.DateTime();
  val x$26: model.Dollars = new model.Dollars(math.this.BigDecimal.int2bigDecimal(0));
  val x$27: model.package.Key = StockSchema.this.StockAsset.apply$default$1;
  new StockSchema.this.StockAsset(x$27, x$19, x$20, x$21, x$22, x$23, x$24, x$25, x$26)
}).insert(StockSchema.this.stockAssets).flatMap[StockSchema.this.StockPurchase](((asset: StockSchema.this.StockAsset) => StockSchema.this.toOps[StockSchema.this.Portfolio](this).update(((t: StockSchema.this.Portfolio) => {
  val x$28: model.Dollars = t.cash.-(dollars);
  val x$29: model.package.Key = t.copy$default$1;
  val x$30: model.Link[StockSchema.this.League] = t.copy$default$2;
  val x$31: String = t.copy$default$3;
  val x$32: model.Dollars = t.copy$default$5;
  val x$33: Int = t.copy$default$6;
  t.copy(x$29, x$30, x$31, x$28, x$32, x$33)
}))(StockSchema.this.portfolios).flatMap[StockSchema.this.StockPurchase](((_: Unit) => new StockSchema.this.Bought(this, ticker, shares, dollars, price).report().map[StockSchema.this.StockPurchase](((_: StockSchema.this.NewsEvent) => new StockSchema.this.StockPurchase(shares, dollars, asset.id)))))))
    };
    private[model] def sellStock(ticker: String, shares: model.Shares): StockSchema.this.Transaction[Unit] = {
      val price: model.Price = Stocks.stockPrice(ticker);
      PortfolioWithStocks.this.sellStock(ticker, shares.*(price), shares, price)
    };
    private[model] def sellStock(ticker: String, dollars: model.Dollars): StockSchema.this.Transaction[Unit] = {
      val price: model.Price = Stocks.stockPrice(ticker);
      PortfolioWithStocks.this.sellStock(ticker, dollars, dollars./-/(price), price)
    };
    private[model] def sellStock(ticker: String, dollars: model.Dollars, shares: model.Shares, price: model.Price): StockSchema.this.Transaction[Unit] = {
      val allAssets: List[StockSchema.this.StockAsset] = PortfolioWithStocks.this.myStockAssets.filter(((x$11: StockSchema.this.StockAsset) => x$11.ticker.==(ticker))).sortBy[scala.math.BigDecimal](((x$12: StockSchema.this.StockAsset) => x$12.shares.shares))(math.this.Ordering.BigDecimal);
      def processAssets(soFar: model.Shares, assets: List[StockSchema.this.StockAsset]): StockSchema.this.Transaction[Unit] = assets match {
        case immutable.this.Nil => if (allAssets.isEmpty)
          throw new StockSchema.this.DontOwnStock(ticker)
        else
          throw new StockSchema.this.NotEnoughShares(soFar, shares)
        case (hd: StockSchema.this.StockAsset, tl: List[StockSchema.this.StockAsset])collection.immutable.::[StockSchema.this.StockAsset]((asset @ _), (restAssets @ _)) => if (asset.shares.+(soFar).==(shares))
          StockSchema.this.toOps[StockSchema.this.StockAsset](asset).delete(StockSchema.this.stockAssets).map[Unit](((x$13: StockSchema.this.StockAsset) => ()))
        else
          if (asset.shares.+(soFar).>=(shares))
            {
              val remaining: model.Shares = shares.-(soFar);
              StockSchema.this.toOps[StockSchema.this.StockAsset](asset).update(((a: StockSchema.this.StockAsset) => {
                val x$34: model.Shares = a.shares.-(remaining);
                val x$35: model.package.Key = a.copy$default$1;
                val x$36: String = a.copy$default$2;
                val x$37: model.Link[StockSchema.this.Portfolio] = a.copy$default$4;
                val x$38: model.Price = a.copy$default$5;
                val x$39: model.Price = a.copy$default$6;
                val x$40: org.joda.time.DateTime = a.copy$default$7;
                val x$41: org.joda.time.DateTime = a.copy$default$8;
                val x$42: model.Dollars = a.copy$default$9;
                a.copy(x$35, x$36, x$34, x$37, x$38, x$39, x$40, x$41, x$42)
              }))(StockSchema.this.stockAssets)
            }
          else
            StockSchema.this.toOps[StockSchema.this.StockAsset](asset).delete(StockSchema.this.stockAssets).flatMap[Unit](((x$14: StockSchema.this.StockAsset) => processAssets(soFar.-(asset.shares), restAssets)))
      };
      processAssets(new model.Shares(math.this.BigDecimal.int2bigDecimal(0)), allAssets.toList).flatMap[Unit](((_: Unit) => StockSchema.this.toOps[StockSchema.this.Portfolio](this).update(((t: StockSchema.this.Portfolio) => {
  val x$43: model.Dollars = t.cash.+(dollars);
  val x$44: model.package.Key = t.copy$default$1;
  val x$45: model.Link[StockSchema.this.League] = t.copy$default$2;
  val x$46: String = t.copy$default$3;
  val x$47: model.Dollars = t.copy$default$5;
  val x$48: Int = t.copy$default$6;
  t.copy(x$44, x$45, x$46, x$43, x$47, x$48)
}))(StockSchema.this.portfolios).flatMap[Unit](((_: Unit) => new StockSchema.this.Sold(this, ticker, shares, dollars, price).report().map[Unit](((_: StockSchema.this.NewsEvent) => ()))))))
    };
    private[model] def sellAll(ticker: String): StockSchema.this.Transaction[Unit] = {
      val assets: List[StockSchema.this.StockAsset] = PortfolioWithStocks.this.myStockAssets.filter(((x$15: StockSchema.this.StockAsset) => x$15.ticker.==(ticker)));
      val delete: StockSchema.this.Transaction[List[StockSchema.this.StockAsset]] = scalaz.Scalaz.SeqMA[List, StockSchema.this.Transaction[StockSchema.this.StockAsset]](assets.map[StockSchema.this.Transaction[StockSchema.this.StockAsset], List[StockSchema.this.Transaction[StockSchema.this.StockAsset]]](((x$16: StockSchema.this.StockAsset) => StockSchema.this.toOps[StockSchema.this.StockAsset](x$16).delete(StockSchema.this.stockAssets)))(immutable.this.List.canBuildFrom[StockSchema.this.Transaction[StockSchema.this.StockAsset]])).sequence[StockSchema.this.Transaction, StockSchema.this.StockAsset](scala.this.Predef.conforms[StockSchema.this.Transaction[StockSchema.this.StockAsset]], scalaz.this.Traverse.TraversableTraverse[List](scalaz.this.CanBuildAnySelf.GenericCanBuildSelf[List](immutable.this.List.canBuildFrom[Nothing])), scalaz.this.Applicative.applicative[StockSchema.this.Transaction](StockSchema.this.TransactionPure, scalaz.this.Apply.FunctorBindApply[StockSchema.this.Transaction](StockSchema.this.TransactionFunctor, StockSchema.this.TransactionBind)));
      val totalShares: model.Shares = new model.Shares(assets.map[scala.math.BigDecimal, List[scala.math.BigDecimal]](((x$17: StockSchema.this.StockAsset) => x$17.shares.shares))(immutable.this.List.canBuildFrom[scala.math.BigDecimal]).sum[scala.math.BigDecimal](math.this.Numeric.BigDecimalIsFractional));
      val price: model.Price = Stocks.stockPrice(ticker);
      val dollars: model.Dollars = totalShares.*(price);
      delete.flatMap[Unit](((_: List[StockSchema.this.StockAsset]) => StockSchema.this.toOps[StockSchema.this.Portfolio](this).update(((t: StockSchema.this.Portfolio) => {
  val x$49: model.Dollars = t.cash.+(dollars);
  val x$50: model.package.Key = t.copy$default$1;
  val x$51: model.Link[StockSchema.this.League] = t.copy$default$2;
  val x$52: String = t.copy$default$3;
  val x$53: model.Dollars = t.copy$default$5;
  val x$54: Int = t.copy$default$6;
  t.copy(x$50, x$51, x$52, x$49, x$53, x$54)
}))(StockSchema.this.portfolios).flatMap[Unit](((_: Unit) => new StockSchema.this.Sold(this, ticker, totalShares, dollars, price).report().map[Unit](((_: StockSchema.this.NewsEvent) => ()))))))
    }
  }
}
StockSchema: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
 Grouped
 StockPu
 StockAs

case class Ownership extends java.lang.Object with model.KL with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val id: model.package.Key = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def id: model.package.Key = Ownership.this.id;
  <caseaccessor> <paramaccessor> private[this] val user: UserSchema.this.User = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def user: UserSchema.this.User = Ownership.this.user;
  <caseaccessor> <paramaccessor> private[this] val portfolio: UserSchema.this.Portfolio = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def portfolio: UserSchema.this.Portfolio = Ownership.this.portfolio;
  def this(id: model.package.Key = model.this.`package`.nextID, user: UserSchema.this.User, portfolio: UserSchema.this.Portfolio): UserSchema.this.Ownership = {
    Ownership.super.this();
    ()
  };
  <synthetic> def copy(id: model.package.Key = id, user: UserSchema.this.User = user, portfolio: UserSchema.this.Portfolio = portfolio): UserSchema.this.Ownership = new UserSchema.this.Ownership(id, user, portfolio);
  <synthetic> def copy$default$3: UserSchema.this.Portfolio @scala.annotation.unchecked.uncheckedVariance = Ownership.this.portfolio;
  <synthetic> def copy$default$2: UserSchema.this.User @scala.annotation.unchecked.uncheckedVariance = Ownership.this.user;
  <synthetic> def copy$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = Ownership.this.id;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(Ownership.this);
  override def toString(): String = ScalaRunTime.this._toString(Ownership.this);
  override def equals(x$1: Any): Boolean = Ownership.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (id: model.package.Key, user: UserSchema.this.User, portfolio: UserSchema.this.Portfolio)UserSchema.this.Ownership((id$3 @ _), (user$1 @ _), (portfolio$1 @ _)) if id$3.==(id).&&(user$1.==(user)).&&(portfolio$1.==(portfolio)) => x$1.asInstanceOf[UserSchema.this.Ownership].canEqual(Ownership.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "Ownership";
  override def productArity: Int = 3;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => id
    case 1 => user
    case 2 => portfolio
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[UserSchema.this.Ownership]()
}
Ownership: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
    user
 portfol
      id

final class $anon extends java.lang.Object with net.liftweb.actor.LiftActor {
  def this(): anonymous class $anon = {
    $anon.super.this();
    ()
  };
  def messageHandler: PartialFunction[Any,Unit] = ((x0$1: Any) => x0$1 match {
    case _ => {
      net.liftweb.util.Schedule.schedule[Symbol](this, scala.Symbol.apply("yo"), delay);
      command
    }
  })
}
$anon: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
         message

class MyPage extends java.lang.Object with ScalaObject {
  def this(): code.snippet.MyPage = {
    MyPage.super.this();
    ()
  };
  def render: scala.xml.NodeBuffer = myPage.apply()
}
MyPage: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
          render

case class Price extends java.lang.Object with Ordered[model.Price] with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val price: scala.math.BigDecimal = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def price: scala.math.BigDecimal = Price.this.price;
  def this(price: scala.math.BigDecimal): model.Price = {
    Price.super.this();
    ()
  };
  def this(str: String): model.Price = {
    Price.this.this(scala.math.BigDecimal.apply(str));
    ()
  };
  def +(other: model.Price): model.Price = new model.Price(Price.this.price.+(other.price));
  def -(other: model.Price): model.Price = new model.Price(Price.this.price.-(other.price));
  def *(shares: model.Shares): model.Dollars = new model.Dollars(shares.shares.*(Price.this.price));
  def *(scale: model.Scale): model.Price = new model.Price(scale.scale.*(Price.this.price));
  def compare(other: model.Price): Int = Price.this.price.compare(other.price);
  def $: String = if (Price.this.price.<(math.this.BigDecimal.int2bigDecimal(0)))
    scala.this.Predef.augmentString("-$%.2f").format(Price.this.price.doubleValue().unary_-)
  else
    scala.this.Predef.augmentString("$%.2f").format(Price.this.price.doubleValue());
  def double: Double = Price.this.price.doubleValue();
  <synthetic> def copy(price: scala.math.BigDecimal = price): model.Price = new model.this.Price(price);
  <synthetic> def copy$default$1: scala.math.BigDecimal @scala.annotation.unchecked.uncheckedVariance = Price.this.price;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(Price.this);
  override def toString(): String = ScalaRunTime.this._toString(Price.this);
  override def equals(x$1: Any): Boolean = Price.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (price: scala.math.BigDecimal)model.Price((price$1 @ _)) if price$1.==(price) => x$1.asInstanceOf[model.Price].canEqual(Price.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "Price";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => price
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[model.Price]()
}
Price: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=0.238
          double   $plus  $times compare  $times       $  $minus
   price     X       X       X       X       X       X       X  

abstract class Recipient extends java.lang.Object with ScalaObject {
  def this(): code.snippet.Recipient = {
    Recipient.super.this();
    ()
  }
}
Recipient: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

class CachedStockDatabase extends java.lang.Object with stockdata.StockDatabase with ScalaObject {
  <paramaccessor> private[this] val database: stockdata.StockDatabase = _;
  <paramaccessor> private[this] val timeout: org.joda.time.Duration = _;
  def this(database: stockdata.StockDatabase, timeout: org.joda.time.Duration): stockdata.CachedStockDatabase = {
    CachedStockDatabase.super.this();
    ()
  };
  private[this] val cache: scala.collection.mutable.Map[stockdata.Stock,stockdata.Quote] = scala.collection.mutable.MMap.apply[stockdata.Stock, stockdata.Quote]();
  <stable> <accessor> def cache: scala.collection.mutable.Map[stockdata.Stock,stockdata.Quote] = CachedStockDatabase.this.cache;
  if (CachedStockDatabase.this.database.==(null))
    throw new scala.`package`.NullPointerException("Database must be non-null.")
  else
    ();
  if (CachedStockDatabase.this.timeout.==(null))
    throw new scala.`package`.NullPointerException("Timeout must be non-null.")
  else
    ();
  def getQuotes(stocks: Iterable[stockdata.Stock]): Iterable[stockdata.Quote] = {
    val now: org.joda.time.DateTime = new org.joda.time.DateTime();
    <synthetic> private[this] val x$2: (Iterable[stockdata.Stock], Iterable[stockdata.Stock]) = (stocks.partition(((x$1: stockdata.Stock) => CachedStockDatabase.this.hasQuote(x$1, now))): (Iterable[stockdata.Stock], Iterable[stockdata.Stock]) @unchecked) match {
      case (_1: Iterable[stockdata.Stock], _2: Iterable[stockdata.Stock])(Iterable[stockdata.Stock], Iterable[stockdata.Stock])((cached @ _), (missing @ _)) => new (Iterable[stockdata.Stock], Iterable[stockdata.Stock])(cached, missing)
    };
    val cached: Iterable[stockdata.Stock] = x$2._1;
    val missing: Iterable[stockdata.Stock] = x$2._2;
    val new_quotes: Iterable[stockdata.Quote] = if (missing.isEmpty.unary_!)
      CachedStockDatabase.this.updateQuotes(missing)
    else
      scala.`package`.Iterable.apply[stockdata.Quote]();
    val cached_quotes: Iterable[stockdata.Quote] = cached.map[stockdata.Quote, Iterable[stockdata.Quote]](((x$3: stockdata.Stock) => CachedStockDatabase.this.getCachedQuote(x$3, now).get))(collection.this.Iterable.canBuildFrom[stockdata.Quote]);
    cached_quotes.++[stockdata.Quote, Iterable[stockdata.Quote]](new_quotes)(collection.this.Iterable.canBuildFrom[stockdata.Quote])
  };
  private def hasQuote(stock: stockdata.Stock, now: org.joda.time.DateTime): Boolean = CachedStockDatabase.this.getCachedQuote(stock, now) match {
    case (x: stockdata.Quote)Some[stockdata.Quote]((quote @ (_: stockdata.Quote))) => true
    case scala.None => false
  };
  private def getCachedQuote(stock: stockdata.Stock, now: org.joda.time.DateTime): Option[stockdata.Quote] = CachedStockDatabase.this.cache.get(stock) match {
    case (x: stockdata.Quote)Some[stockdata.Quote]((quote @ (_: stockdata.Quote))) => if (CachedStockDatabase.this.isExpired(quote, now))
      scala.None
    else
      new Some[stockdata.Quote](quote)
    case scala.None => scala.None
  };
  private def updateQuotes(stocks: Iterable[stockdata.Stock]): Iterable[stockdata.Quote] = {
    val quotes: Iterable[stockdata.Quote] = CachedStockDatabase.this.database.getQuotes(stocks);
    quotes.map[stockdata.Quote, Iterable[stockdata.Quote]](((quote: stockdata.Quote) => {
      CachedStockDatabase.this.cache.update(quote.stock, quote);
      quote
    }))(collection.this.Iterable.canBuildFrom[stockdata.Quote])
  };
  private def isExpired(quote: stockdata.Quote, now: org.joda.time.DateTime): Boolean = CachedStockDatabase.this.timeout.compareTo(new org.joda.time.Duration(quote.updateTime, now)).<(0)
}
CachedStockDatabase: SCOM=0.550 CC=0.500 LSCC=0.350 CAMC=0.400
         getCach hasQuot getQuot updateQ isExpir
 timeout     X       X       X               X  
 databas                     X       X          

case class DerivativeBuyerSetAside extends java.lang.Object with model.KL with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val id: model.package.Key = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def id: model.package.Key = DerivativeBuyerSetAside.this.id;
  <caseaccessor> <paramaccessor> private[this] val buyer: model.Link[VotingSchema.this.Portfolio] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def buyer: model.Link[VotingSchema.this.Portfolio] = DerivativeBuyerSetAside.this.buyer;
  <caseaccessor> <paramaccessor> private[this] val seller: model.Link[VotingSchema.this.Portfolio] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def seller: model.Link[VotingSchema.this.Portfolio] = DerivativeBuyerSetAside.this.seller;
  <caseaccessor> <paramaccessor> private[this] val derivative: model.Derivative = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def derivative: model.Derivative = DerivativeBuyerSetAside.this.derivative;
  <caseaccessor> <paramaccessor> private[this] val price: model.Dollars = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def price: model.Dollars = DerivativeBuyerSetAside.this.price;
  <caseaccessor> <paramaccessor> private[this] val remaining: model.Scale = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def remaining: model.Scale = DerivativeBuyerSetAside.this.remaining;
  def this(id: model.package.Key = model.this.`package`.nextID, buyer: model.Link[VotingSchema.this.Portfolio], seller: model.Link[VotingSchema.this.Portfolio], derivative: model.Derivative, price: model.Dollars, remaining: model.Scale): VotingSchema.this.DerivativeBuyerSetAside = {
    DerivativeBuyerSetAside.super.this();
    ()
  };
  <synthetic> def copy(id: model.package.Key = id, buyer: model.Link[VotingSchema.this.Portfolio] = buyer, seller: model.Link[VotingSchema.this.Portfolio] = seller, derivative: model.Derivative = derivative, price: model.Dollars = price, remaining: model.Scale = remaining): VotingSchema.this.DerivativeBuyerSetAside = new VotingSchema.this.DerivativeBuyerSetAside(id, buyer, seller, derivative, price, remaining);
  <synthetic> def copy$default$6: model.Scale @scala.annotation.unchecked.uncheckedVariance = DerivativeBuyerSetAside.this.remaining;
  <synthetic> def copy$default$5: model.Dollars @scala.annotation.unchecked.uncheckedVariance = DerivativeBuyerSetAside.this.price;
  <synthetic> def copy$default$4: model.Derivative @scala.annotation.unchecked.uncheckedVariance = DerivativeBuyerSetAside.this.derivative;
  <synthetic> def copy$default$3: model.Link[VotingSchema.this.Portfolio] @scala.annotation.unchecked.uncheckedVariance = DerivativeBuyerSetAside.this.seller;
  <synthetic> def copy$default$2: model.Link[VotingSchema.this.Portfolio] @scala.annotation.unchecked.uncheckedVariance = DerivativeBuyerSetAside.this.buyer;
  <synthetic> def copy$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = DerivativeBuyerSetAside.this.id;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(DerivativeBuyerSetAside.this);
  override def toString(): String = ScalaRunTime.this._toString(DerivativeBuyerSetAside.this);
  override def equals(x$1: Any): Boolean = DerivativeBuyerSetAside.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (id: model.package.Key, buyer: model.Link[VotingSchema.this.Portfolio], seller: model.Link[VotingSchema.this.Portfolio], derivative: model.Derivative, price: model.Dollars, remaining: model.Scale)VotingSchema.this.DerivativeBuyerSetAside((id$1 @ _), (buyer$1 @ _), (seller$1 @ _), (derivative$1 @ _), (price$1 @ _), (remaining$1 @ _)) if id$1.==(id).&&(buyer$1.==(buyer)).&&(seller$1.==(seller)).&&(derivative$1.==(derivative)).&&(price$1.==(price)).&&(remaining$1.==(remaining)) => x$1.asInstanceOf[VotingSchema.this.DerivativeBuyerSetAside].canEqual(DerivativeBuyerSetAside.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "DerivativeBuyerSetAside";
  override def productArity: Int = 6;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => id
    case 1 => buyer
    case 2 => seller
    case 3 => derivative
    case 4 => price
    case 5 => remaining
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[VotingSchema.this.DerivativeBuyerSetAside]()
}
DerivativeBuyerSetAside: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
  seller
   buyer
 remaini
   price
 derivat
      id

case class TransactionResponse extends Status with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val ticker: String = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def ticker: String = TransactionResponse.this.ticker;
  <caseaccessor> <paramaccessor> private[this] val dollars: model.Dollars = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def dollars: model.Dollars = TransactionResponse.this.dollars;
  <caseaccessor> <paramaccessor> private[this] val shares: model.Shares = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def shares: model.Shares = TransactionResponse.this.shares;
  def this(ticker: String, dollars: model.Dollars, shares: model.Shares): texttrading.TransactionResponse = {
    TransactionResponse.super.this();
    ()
  };
  <synthetic> def copy(ticker: String = ticker, dollars: model.Dollars = dollars, shares: model.Shares = shares): texttrading.TransactionResponse = new texttrading.this.TransactionResponse(ticker, dollars, shares);
  <synthetic> def copy$default$3: model.Shares @scala.annotation.unchecked.uncheckedVariance = TransactionResponse.this.shares;
  <synthetic> def copy$default$2: model.Dollars @scala.annotation.unchecked.uncheckedVariance = TransactionResponse.this.dollars;
  <synthetic> def copy$default$1: String @scala.annotation.unchecked.uncheckedVariance = TransactionResponse.this.ticker;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(TransactionResponse.this);
  override def toString(): String = ScalaRunTime.this._toString(TransactionResponse.this);
  override def equals(x$1: Any): Boolean = TransactionResponse.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (ticker: String, dollars: model.Dollars, shares: model.Shares)texttrading.TransactionResponse((ticker$5 @ _), (dollars$2 @ _), (shares$2 @ _)) if ticker$5.==(ticker).&&(dollars$2.==(dollars)).&&(shares$2.==(shares)) => x$1.asInstanceOf[texttrading.TransactionResponse].canEqual(TransactionResponse.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "TransactionResponse";
  override def productArity: Int = 3;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => ticker
    case 1 => dollars
    case 2 => shares
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[texttrading.TransactionResponse]()
}
TransactionResponse: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
  shares
  ticker
 dollars

final class $anon extends DollarsField with intform.FieldErrorRender {
  def this(): anonymous class $anon = {
    $anon.super.this("");
    ()
  }
}
$anon: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

class BatchingStockDatabase extends java.lang.Object with ScalaObject {
  <paramaccessor> private[this] val database: stockdata.StockDatabase = _;
  <stable> <accessor> <paramaccessor> def database: stockdata.StockDatabase = BatchingStockDatabase.this.database;
  def this(database: stockdata.StockDatabase): stockdata.BatchingStockDatabase = {
    BatchingStockDatabase.super.this();
    ()
  };
  private[this] val pendingStocks: scala.collection.mutable.Map[stockdata.Stock,Long] = scala.collection.mutable.MMap.apply[stockdata.Stock, Long]();
  private <stable> <accessor> def pendingStocks: scala.collection.mutable.Map[stockdata.Stock,Long] = BatchingStockDatabase.this.pendingStocks;
  private[this] val storedQuotes: scala.collection.mutable.Map[Long,stockdata.Quote] = scala.collection.mutable.MMap.apply[Long, stockdata.Quote]();
  private <stable> <accessor> def storedQuotes: scala.collection.mutable.Map[Long,stockdata.Quote] = BatchingStockDatabase.this.storedQuotes;
  private[this] var previousId: Long = 0L;
  private <accessor> def previousId: Long = BatchingStockDatabase.this.previousId;
  private <accessor> def previousId_=(x$1: Long): Unit = BatchingStockDatabase.this.previousId = x$1;
  if (BatchingStockDatabase.this.database.==(null))
    throw new scala.`package`.NullPointerException("Database must be non-null.")
  else
    ();
  def getQuote(stock: stockdata.Stock): BatchingStockDatabase.this.LazyQuote = BatchingStockDatabase.this.pendingStocks.get(stock) match {
    case (x: Long)Some[Long]((id @ _)) => new BatchingStockDatabase.this.LazyQuote(id)
    case scala.None => {
      BatchingStockDatabase.this.previousId_=(BatchingStockDatabase.this.previousId.+(1));
      BatchingStockDatabase.this.pendingStocks.+=(new (stockdata.Stock, Long)(stock, BatchingStockDatabase.this.previousId));
      new BatchingStockDatabase.this.LazyQuote(BatchingStockDatabase.this.previousId)
    }
  };
  def getQuotes(stocks: Iterable[stockdata.Stock]): Iterable[BatchingStockDatabase.this.LazyQuote] = stocks.map[BatchingStockDatabase.this.LazyQuote, Iterable[BatchingStockDatabase.this.LazyQuote]](((stock: stockdata.Stock) => BatchingStockDatabase.this.getQuote(stock)))(collection.this.Iterable.canBuildFrom[BatchingStockDatabase.this.LazyQuote]);
  private def fetchPendingStock(id: Long): stockdata.Quote = {
    val quotes: Iterable[stockdata.Quote] = BatchingStockDatabase.this.database.getQuotes(BatchingStockDatabase.this.pendingStocks.keys);
    BatchingStockDatabase.this.pendingStocks.values.zip[Long, stockdata.Quote, Iterable[(Long, stockdata.Quote)]](quotes)(collection.this.Iterable.canBuildFrom[(Long, stockdata.Quote)]).foreach[Unit](((x$1: (Long, stockdata.Quote)) => x$1 match {
      case (_1: Long, _2: stockdata.Quote)(Long, stockdata.Quote)((id @ _), (quote @ _)) => BatchingStockDatabase.this.storedQuotes.update(id, quote)
    }));
    BatchingStockDatabase.this.pendingStocks.clear();
    BatchingStockDatabase.this.storedQuotes.get(id) match {
      case (x: stockdata.Quote)Some[stockdata.Quote]((stock @ _)) => stock
      case scala.None => null
    }
  };
  case class LazyQuote extends java.lang.Object with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val id: Long = _;
    private <stable> <accessor> <paramaccessor> def id: Long = LazyQuote.this.id;
    def this(id: Long): BatchingStockDatabase.this.LazyQuote = {
      LazyQuote.super.this();
      ()
    };
    <synthetic> def copy(id: Long = id): BatchingStockDatabase.this.LazyQuote = new BatchingStockDatabase.this.LazyQuote(id);
    <synthetic> def copy$default$1: Long @scala.annotation.unchecked.uncheckedVariance = LazyQuote.this.id;
    <synthetic> <stable> <caseaccessor> def id$1: Long = LazyQuote.this.id;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(LazyQuote.this);
    override def toString(): String = ScalaRunTime.this._toString(LazyQuote.this);
    override def equals(x$1: Any): Boolean = LazyQuote.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (id: Long)BatchingStockDatabase.this.LazyQuote((id$1$1 @ _)) if id$1$1.==(id$1) => x$1.asInstanceOf[BatchingStockDatabase.this.LazyQuote].canEqual(LazyQuote.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "LazyQuote";
    override def productArity: Int = 1;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => id$1
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[BatchingStockDatabase.this.LazyQuote]()
  };
  final object LazyQuote extends java.lang.Object with ScalaObject with Serializable {
    def this(): object BatchingStockDatabase.this.LazyQuote = {
      LazyQuote.super.this();
      ()
    };
    implicit def forceLazyQuote(lazyQuote: BatchingStockDatabase.this.LazyQuote): stockdata.Quote = BatchingStockDatabase.this.storedQuotes.get(lazyQuote.id) match {
      case (x: stockdata.Quote)Some[stockdata.Quote]((quote @ _)) => quote
      case scala.None => BatchingStockDatabase.this.fetchPendingStock(lazyQuote.id)
    };
    case <synthetic> def unapply(x$0: BatchingStockDatabase.this.LazyQuote): Option[Long] = if (x$0.==(null))
      scala.this.None
    else
      new Some[Long](x$0.id);
    case <synthetic> def apply(id: Long): BatchingStockDatabase.this.LazyQuote = new BatchingStockDatabase.this.LazyQuote(id)
  };
  @volatile <synthetic> private[this] var LazyQuote$module: object BatchingStockDatabase.this.LazyQuote = _;
  final <stable> def LazyQuote: object BatchingStockDatabase.this.LazyQuote = {
    BatchingStockDatabase.this.LazyQuote$module = new object BatchingStockDatabase.this.LazyQuote();
    BatchingStockDatabase.this.LazyQuote$module
  }
}
BatchingStockDatabase: SCOM=0.056 CC=0.167 LSCC=0.056 CAMC=0.250
         fetchPe getQuot getQuot LazyQuo
 previou             X       X          
 LazyQuo                             X  
 databas     X                          

<static> class Response extends _root_.java.lang.Object {
  def this() = _;
  var cash: Double = _;
  var assets: List[ResponseAsset] = _
}
Response: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
    cash
  assets

final object _currentLogin extends net.liftweb.http.SessionVar[Option[String]] with ScalaObject {
  def this(): object code.control.LoginManager._currentLogin = {
    _currentLogin.super.this(new Some[java.lang.String]("ellbur_k_a"));
    ()
  }
}
_currentLogin: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

class TextTrader extends java.lang.Object with ScalaObject {
  <paramaccessor> private[this] val backend: texttrading.Backend = _;
  <paramaccessor> private[this] val frontend: texttrading.Frontend = _;
  def this(backend: texttrading.Backend, frontend: texttrading.Frontend): texttrading.TextTrader = {
    TextTrader.super.this();
    ()
  };
  def run(): Unit = TextTrader.this.frontend.messages.foreach[Unit](((x0$1: texttrading.Message) => x0$1 match {
    case (username: String, command: String, reply: texttrading.Reply)texttrading.Message((user @ _), (command @ _), (reply @ _)) => {
      val replies: Seq[String] = TextTrader.runCommand(user, command, TextTrader.this.backend);
      replies.foreach[Unit]({
        ((text: String) => reply.reply(text))
      })
    }
  }))
}
TextTrader: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
             run
 fronten     X  
 backend     X  

abstract trait AggregateRender extends java.lang.Object with intform.FieldRender with ScalaObject {
  def /*AggregateRender*/$init$(): Unit = {
    ()
  };
  def renderer: () => scala.xml.NodeSeq;
  def main: scala.xml.NodeSeq = AggregateRender.this.renderer.apply()
}
AggregateRender: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
            main
 rendere     X  

abstract trait FormOuter extends java.lang.Object with intform.Renderable with ScalaObject {
  private <superaccessor> def super$render: scala.xml.NodeSeq;
  def /*FormOuter*/$init$(): Unit = {
    ()
  };
  absoverride def render: scala.xml.NodeSeq = net.liftweb.http.SHtml.ajaxForm(FormOuter.this.super$render)
}
FormOuter: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
          render
 super$r     X  

case class SpecificUser extends Recipient with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val portfolio: model.schema.Portfolio = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def portfolio: model.schema.Portfolio = SpecificUser.this.portfolio;
  def this(portfolio: model.schema.Portfolio): code.snippet.SpecificUser = {
    SpecificUser.super.this();
    ()
  };
  <synthetic> def copy(portfolio: model.schema.Portfolio = portfolio): code.snippet.SpecificUser = new snippet.this.SpecificUser(portfolio);
  <synthetic> def copy$default$1: model.schema.Portfolio @scala.annotation.unchecked.uncheckedVariance = SpecificUser.this.portfolio;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(SpecificUser.this);
  override def toString(): String = ScalaRunTime.this._toString(SpecificUser.this);
  override def equals(x$1: Any): Boolean = SpecificUser.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (portfolio: model.schema.Portfolio)code.snippet.SpecificUser((portfolio$1 @ _)) if portfolio$1.==(portfolio) => x$1.asInstanceOf[code.snippet.SpecificUser].canEqual(SpecificUser.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "SpecificUser";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => portfolio
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[code.snippet.SpecificUser]()
}
SpecificUser: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
 portfol

case class FormattedDerivative extends java.lang.Object with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val deriv: model.Derivative = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def deriv: model.Derivative = FormattedDerivative.this.deriv;
  def this(deriv: model.Derivative): formats.package.FormattedDerivative = {
    FormattedDerivative.super.this();
    ()
  };
  def toHumanString: String = scala.this.Predef.augmentString("%s on %s if %s").format(package.this.securitiesFormatted(FormattedDerivative.this.deriv.securities).toHumanString, package.this.dateTimeFormatted(FormattedDerivative.this.deriv.exec).toNearbyString, package.this.conditionFormatted(FormattedDerivative.this.deriv.condition).toHumanString);
  <synthetic> def copy(deriv: model.Derivative = deriv): formats.package.FormattedDerivative = new package.this.FormattedDerivative(deriv);
  <synthetic> def copy$default$1: model.Derivative @scala.annotation.unchecked.uncheckedVariance = FormattedDerivative.this.deriv;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(FormattedDerivative.this);
  override def toString(): String = ScalaRunTime.this._toString(FormattedDerivative.this);
  override def equals(x$1: Any): Boolean = FormattedDerivative.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (deriv: model.Derivative)formats.package.FormattedDerivative((deriv$1 @ _)) if deriv$1.==(deriv) => x$1.asInstanceOf[formats.package.FormattedDerivative].canEqual(FormattedDerivative.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "FormattedDerivative";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => deriv
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[formats.package.FormattedDerivative]()
}
FormattedDerivative: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
         toHuman
   deriv     X  

final class $anon extends Refreshable.this.NeedRenderable with intform.Refreshable {
  def this(): anonymous class $anon = {
    $anon.super.this((() => r));
    ()
  }
}
$anon: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

case class NoOrder extends StockOrder with ScalaObject with Product with Serializable {
  def this(): code.snippet.NoOrder = {
    NoOrder.super.this();
    ()
  };
  override def hashCode(): Int = ScalaRunTime.this._hashCode(NoOrder.this);
  override def toString(): String = ScalaRunTime.this._toString(NoOrder.this);
  override def equals(x$1: Any): Boolean = NoOrder.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case ()code.snippet.NoOrder() => x$1.asInstanceOf[code.snippet.NoOrder].canEqual(NoOrder.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "NoOrder";
  override def productArity: Int = 0;
  override def productElement(x$1: Int): Any = x$1 match {
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[code.snippet.NoOrder]()
}
NoOrder: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

abstract trait StockDatabase extends scala.AnyRef {
  def getQuotes(stocks: Iterable[stockdata.Stock]): Iterable[stockdata.Quote]
}
StockDatabase: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
 getQuot

case class Buy extends Action with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val asset: texttrading.StockAsset = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def asset: texttrading.StockAsset = Buy.this.asset;
  def this(asset: texttrading.StockAsset): texttrading.Buy = {
    Buy.super.this();
    ()
  };
  <synthetic> def copy(asset: texttrading.StockAsset = asset): texttrading.Buy = new texttrading.this.Buy(asset);
  <synthetic> def copy$default$1: texttrading.StockAsset @scala.annotation.unchecked.uncheckedVariance = Buy.this.asset;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(Buy.this);
  override def toString(): String = ScalaRunTime.this._toString(Buy.this);
  override def equals(x$1: Any): Boolean = Buy.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (asset: texttrading.StockAsset)texttrading.Buy((asset$1 @ _)) if asset$1.==(asset) => x$1.asInstanceOf[texttrading.Buy].canEqual(Buy.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "Buy";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => asset
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[texttrading.Buy]()
}
Buy: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
   asset

final class $anon extends intform.BooleanField {
  def this(): anonymous class $anon = {
    $anon.super.this(true);
    ()
  };
  override def main: scala.xml.NodeSeq = {
  {
    new scala.xml.Elem(null, "dt", scala.xml.Null, scala.this.Predef.$scope, ({
      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
      $buf.&+({
        {
          var $md: scala.xml.MetaData = scala.xml.Null;
          $md = new scala.xml.UnprefixedAttribute("for", new scala.xml.Text("derivative-early"), $md);
          new scala.xml.Elem(null, "label", $md, scala.this.Predef.$scope, ({
            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
            $buf.&+(new scala.xml.Text("Exercise Early?"));
            $buf
          }: _*))
        }
      });
      $buf
    }: _*))
  }
}.++[scala.xml.Node, scala.xml.NodeSeq]({
    {
      new scala.xml.Elem(null, "dd", scala.xml.Null, scala.this.Predef.$scope, ({
        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
        $buf.&+(intform.`package`.mergeAttr($anon.super.main).&({
          {
            var $md: scala.xml.MetaData = scala.xml.Null;
            $md = new scala.xml.UnprefixedAttribute("id", new scala.xml.Text("derivative-early"), $md);
            new scala.xml.Elem(null, "input", $md, scala.this.Predef.$scope)
          }
        }));
        $buf
      }: _*))
    }
  })(xml.this.NodeSeq.canBuildFrom)
}
$anon: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
            main

final object ClearDatabase extends java.lang.Object with ScalaObject {
  def this(): object code.snippet.ClearDatabase = {
    ClearDatabase.super.this();
    ()
  };
  def render: net.liftweb.util.CssSel = util.this.Helpers.strToCssBindPromoter("type=submit").#>(net.liftweb.http.SHtml.onSubmitUnit((() => {
    model.schema.clearDatabase();
    net.liftweb.http.S.redirectTo("/")
  })))
}
ClearDatabase: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
          render

class BuyServlet extends HttpServlet {
  import BuyServlet._;
  def this() = _;
  protected[servlets] def doPost(request: HttpServletRequest = _, response: HttpServletResponse = _): Unit = _
}
BuyServlet: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
          doPost

abstract trait UserWithComments extends java.lang.Object with ScalaObject { self: CommentSchema.this.User => 
  def /*UserWithComments*/$init$(): Unit = {
    ()
  };
  def userPostComment(event: CommentSchema.this.NewsEvent, text: String): CommentSchema.this.EventComment = CommentSchema.this.editDB[CommentSchema.this.EventComment](UserWithComments.this.postComment(event, text));
  private[model] def postComment(event: CommentSchema.this.NewsEvent, text: String): CommentSchema.this.Transaction[CommentSchema.this.EventComment] = CommentSchema.this.toOps[CommentSchema.this.EventComment]({
  val x$2: CommentSchema.this.NewsEvent = event;
  val x$3: CommentSchema.this.User = this;
  val x$4: String = text;
  val x$5: org.joda.time.DateTime = new org.joda.time.DateTime();
  val x$6: model.package.Key = CommentSchema.this.EventComment.apply$default$1;
  new CommentSchema.this.EventComment(x$6, x$2, x$3, x$4, x$5)
}).insert(CommentSchema.this.eventComments)
}
UserWithComments: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=1.000
         userPos postCom

case class AutoTrade extends java.lang.Object with model.KL with AutoTradeSchema.this.AutoTradeOps with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val id: model.package.Key = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def id: model.package.Key = AutoTrade.this.id;
  <caseaccessor> <paramaccessor> private[this] val owner: AutoTradeSchema.this.Portfolio = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def owner: AutoTradeSchema.this.Portfolio = AutoTrade.this.owner;
  <caseaccessor> <paramaccessor> private[this] val title: String = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def title: String = AutoTrade.this.title;
  <caseaccessor> <paramaccessor> private[this] val code: String = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def code: String = AutoTrade.this.code;
  def this(id: model.package.Key = model.this.`package`.nextID, owner: AutoTradeSchema.this.Portfolio, title: String, code: String): AutoTradeSchema.this.AutoTrade = {
    AutoTrade.super.this();
    ()
  };
  <synthetic> def copy(id: model.package.Key = id, owner: AutoTradeSchema.this.Portfolio = owner, title: String = title, code: String = code): AutoTradeSchema.this.AutoTrade = new AutoTradeSchema.this.AutoTrade(id, owner, title, code);
  <synthetic> def copy$default$4: String @scala.annotation.unchecked.uncheckedVariance = AutoTrade.this.code;
  <synthetic> def copy$default$3: String @scala.annotation.unchecked.uncheckedVariance = AutoTrade.this.title;
  <synthetic> def copy$default$2: AutoTradeSchema.this.Portfolio @scala.annotation.unchecked.uncheckedVariance = AutoTrade.this.owner;
  <synthetic> def copy$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = AutoTrade.this.id;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(AutoTrade.this);
  override def toString(): String = ScalaRunTime.this._toString(AutoTrade.this);
  override def equals(x$1: Any): Boolean = AutoTrade.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (id: model.package.Key, owner: AutoTradeSchema.this.Portfolio, title: String, code: String)AutoTradeSchema.this.AutoTrade((id$1 @ _), (owner$1 @ _), (title$1 @ _), (code$1 @ _)) if id$1.==(id).&&(owner$1.==(owner)).&&(title$1.==(title)).&&(code$1.==(code)) => x$1.asInstanceOf[AutoTradeSchema.this.AutoTrade].canEqual(AutoTrade.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "AutoTrade";
  override def productArity: Int = 4;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => id
    case 1 => owner
    case 2 => title
    case 3 => code
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[AutoTradeSchema.this.AutoTrade]()
}
AutoTrade: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
   owner
    code
   title
      id

final object StringField extends java.lang.Object with ScalaObject {
  def this(): object intform.StringField = {
    StringField.super.this();
    ()
  };
  def apply(i: String = ""): intform.StringField = new StringField(i);
  <synthetic> def apply$default$1: String @scala.annotation.unchecked.uncheckedVariance = ""
}
StringField: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
           apply

class CaseField[A >: Nothing <: Any] extends intform.Field[A] with net.liftweb.common.Loggable with intform.CaseRender with ScalaObject {
  <paramaccessor> private[this] val cases: Seq[intform.Field[A]] = _;
  <paramaccessor> private[this] val renderer: intform.CaseChoices => scala.xml.NodeSeq = _;
  <stable> <accessor> <paramaccessor> def renderer: intform.CaseChoices => scala.xml.NodeSeq = CaseField.this.renderer;
  def this(cases: Seq[intform.Field[A]], renderer: intform.CaseChoices => scala.xml.NodeSeq): intform.CaseField[A] = {
    CaseField.super.this();
    ()
  };
  def produce(): intform.SubmitResult[A] = CaseField.this.selected match {
    case (x: String)Some[String]((name @ _)) => CaseField.this.table.apply(name).process() match {
      case (x: A)Some[A]((res @ _)) => new intform.OK[A](res)
      case scala.None => ChildError
    }
    case _ => new intform.Error("None selected")
  };
  def reset(): Unit = {
    CaseField.this.selected_=(scala.None);
    {
      CaseField.this.cases.map[Unit, Any](((x$3: intform.Field[A]) => x$3.reset()))(collection.this.Seq.canBuildFrom[Unit]);
      ()
    }
  };
  private[this] var selected: Option[String] = scala.None;
  <accessor> def selected: Option[String] = CaseField.this.selected;
  <accessor> def selected_=(x$1: Option[String]): Unit = CaseField.this.selected = x$1;
  private[this] val table: scala.collection.immutable.Map[java.lang.String,intform.Field[A]] = CaseField.this.cases.map[(java.lang.String, intform.Field[A]), Seq[(java.lang.String, intform.Field[A])]](((f: intform.Field[A]) => new (java.lang.String, intform.Field[A])(java.util.UUID.randomUUID().toString(), f)))(collection.this.Seq.canBuildFrom[(java.lang.String, intform.Field[A])]).toMap[java.lang.String, intform.Field[A]](scala.this.Predef.conforms[(java.lang.String, intform.Field[A])]);
  <stable> <accessor> def table: scala.collection.immutable.Map[java.lang.String,intform.Field[A]] = CaseField.this.table
}
CaseField: SCOM=0.667 CC=0.500 LSCC=0.333 CAMC=1.000
         produce   reset
 rendere                
 selecte     X       X  
   cases             X  

class Link[R >: Nothing <: model.KL] extends java.lang.Object with ScalaObject {
  <paramaccessor> private[this] val id: model.package.Key = _;
  <stable> <accessor> <paramaccessor> def id: model.package.Key = Link.this.id;
  def this(id: model.package.Key): model.Link[R] = {
    Link.super.this();
    ()
  };
  private[this] var target: Option[R] = scala.None;
  <accessor> def target: Option[R] = Link.this.target;
  <accessor> def target_=(x$1: Option[R]): Unit = Link.this.target = x$1;
  def extract(implicit table: model.Table[R]): R = Link.this.target.getOrElse[R](table.lookup(Link.this.id).getOrElse[R](throw NotFound));
  override def toString: java.lang.String = "[".+(Link.this.id).+("]");
  def ~~(o: model.KL): Boolean = o.id.==(this.id);
  def ~~(o: model.Link[R]): Boolean = o.id.==(this.id)
}
Link: SCOM=0.833 CC=0.667 LSCC=0.500 CAMC=0.333
         extract $tilde$ $tilde$
  target     X                  
      id     X       X       X  

class ConstField[A >: Nothing <: Any] extends intform.Field[A] with ScalaObject {
  <paramaccessor> private[this] val result: A = _;
  def this(result: A): intform.ConstField[A] = {
    ConstField.super.this();
    ()
  };
  def produce(): intform.OK[A] = new intform.OK[A](ConstField.this.result);
  def reset(): Unit = ()
}
ConstField: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=1.000
           reset produce
  result             X  

case class HaveCommand extends java.lang.Object with SearchBar.this.Status with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val command: String = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def command: String = HaveCommand.this.command;
  <caseaccessor> <paramaccessor> private[this] val response: Seq[String] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def response: Seq[String] = HaveCommand.this.response;
  def this(command: String, response: Seq[String]): SearchBar.this.HaveCommand = {
    HaveCommand.super.this();
    ()
  };
  <synthetic> def copy(command: String = command, response: Seq[String] = response): SearchBar.this.HaveCommand = new SearchBar.this.HaveCommand(command, response);
  <synthetic> def copy$default$2: Seq[String] @scala.annotation.unchecked.uncheckedVariance = HaveCommand.this.response;
  <synthetic> def copy$default$1: String @scala.annotation.unchecked.uncheckedVariance = HaveCommand.this.command;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(HaveCommand.this);
  override def toString(): String = ScalaRunTime.this._toString(HaveCommand.this);
  override def equals(x$1: Any): Boolean = HaveCommand.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (command: String, response: Seq[String])SearchBar.this.HaveCommand((command$1 @ _), (response$1 @ _)) if command$1.==(command).&&(response$1.==(response)) => x$1.asInstanceOf[SearchBar.this.HaveCommand].canEqual(HaveCommand.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "HaveCommand";
  override def productArity: Int = 2;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => command
    case 1 => response
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[SearchBar.this.HaveCommand]()
}
HaveCommand: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
 respons
 command

class YahooCSVStockDatabase extends java.lang.Object with stockdata.StockDatabase with ScalaObject {
  <paramaccessor> private[this] val queryService: stockdata.QueryService = _;
  def this(queryService: stockdata.QueryService): stockdata.YahooCSVStockDatabase = {
    YahooCSVStockDatabase.super.this();
    ()
  };
  private[this] val flags: List[java.lang.String] = immutable.this.List.apply[java.lang.String]("s", "x", "l1", "d1", "t1", "n", "o", "h", "g", "p2", "d");
  private <stable> <accessor> def flags: List[java.lang.String] = YahooCSVStockDatabase.this.flags;
  def getQuotes(stocks: Iterable[stockdata.Stock]): Iterable[stockdata.Quote] = {
    if (stocks.isEmpty)
      return scala.`package`.Iterable.apply[Nothing]()
    else
      ();
    val queryString: String = HttpQueryService.buildQuery(scala.this.Predef.Map.apply[java.lang.String, String](scala.this.Predef.any2ArrowAssoc[java.lang.String]("s").->[String](stocks.map[String, Iterable[String]](((x$1: stockdata.Stock) => x$1.symbol))(collection.this.Iterable.canBuildFrom[String]).mkString(" ")), scala.this.Predef.any2ArrowAssoc[java.lang.String]("f").->[String](YahooCSVStockDatabase.this.flags.mkString(""))), "UTF-8");
    val response: String = try {
      YahooCSVStockDatabase.this.queryService.query(new java.net.URL("http://finance.yahoo.com/d/quotes.csv?".+(queryString)))
    } catch {
      case (ex @ (_: java.io.IOException)) => throw new DatabaseException("Yahoo Finance CSV query failed.", ex)
    };
    try {
      scala.this.Predef.refArrayOps[java.lang.String](scala.this.Predef.refArrayOps[java.lang.String](response.split("$")).init).map[stockdata.Quote, Iterable[stockdata.Quote]](((line: java.lang.String) => {
        val stuff: Array[java.lang.String] = line.split("\\,");
        new stockdata.Quote(new stockdata.Stock(YahooCSVStockDatabase.this.parseQuotedString(stuff.apply(0))), YahooCSVStockDatabase.this.parseQuotedString(stuff.apply(1)), YahooCSVStockDatabase.this.parseQuotedString(stuff.apply(5)), new model.Price(scala.`package`.BigDecimal.apply(stuff.apply(2))), new org.joda.time.DateTime(), new stockdata.QuoteInfo(YahooCSVStockDatabase.this.tryParsePercent(stuff.apply(9)), YahooCSVStockDatabase.this.tryParseNumber(stuff.apply(6)), YahooCSVStockDatabase.this.tryParseNumber(stuff.apply(8)), YahooCSVStockDatabase.this.tryParseNumber(stuff.apply(7)), YahooCSVStockDatabase.this.tryParseNumber(stuff.apply(10))))
      }))(scala.this.Array.fallbackCanBuildFrom[stockdata.Quote](Predef.this.DummyImplicit.dummyImplicit))
    } catch {
      case (ex @ (_: Throwable)) => throw new DatabaseException("Yahoo Finance CSV query failed.", ex)
    }
  };
  private def parseQuotedString(str: String): String = scala.this.Predef.augmentString(scala.this.Predef.augmentString(str).stripPrefix("\"")).stripSuffix("\"");
  private def tryParsePercent(str: String): Option[BigDecimal] = YahooCSVStockDatabase.this.tryParseNumber(scala.this.Predef.augmentString(YahooCSVStockDatabase.this.parseQuotedString(str)).stripSuffix("%"));
  private def tryParseNumber(str: String): Option[BigDecimal] = try {
    new Some[scala.math.BigDecimal](scala.`package`.BigDecimal.apply(str))
  } catch {
    case _ => scala.None
  }
}
YahooCSVStockDatabase: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.500
         getQuot tryPars parseQu tryPars
 querySe     X                          

final object dividendChart extends java.lang.Object with net.liftweb.common.Loggable with ScalaObject {
  def this(): object code.snippet.dividendChart = {
    dividendChart.super.this();
    ()
  };
  def apply(port: model.schema.Portfolio, modifiable: Boolean): scala.xml.NodeSeq = {
    lazy var main$lzy: scala.xml.Elem = _;
    <stable> <accessor> lazy def main: scala.xml.Elem = {
      main$lzy = {
        {
          new scala.xml.Elem(null, "p", scala.xml.Null, scala.this.Predef.$scope)
        }
      };
      main$lzy
    };
    main
  }
}
dividendChart: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
           apply

final object DBSetup extends java.lang.Object with ScalaObject {
  def this(): object bootstrap.liftweb.DBSetup = {
    DBSetup.super.this();
    ()
  };
  def apply(): Unit = ()
}
DBSetup: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
           apply

class IntField extends intform.TextField[Int] with ScalaObject {
  <paramaccessor> private[this] val initText: String = _;
  def this(initText: String): intform.IntField = {
    IntField.super.this(initText);
    ()
  };
  def produce(): intform.SubmitResult[Int] = try {
    new intform.OK[Int](java.this.lang.Integer.parseInt(IntField.this.text))
  } catch {
    case (_: NumberFormatException) => new intform.Error("Should be an integer")
  }
}
IntField: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
         produce
 initTex        

abstract trait NewsEventWithComments extends java.lang.Object with ScalaObject { self: CommentSchema.this.NewsEvent => 
  def /*NewsEventWithComments*/$init$(): Unit = {
    ()
  };
  def comments: scala.collection.mutable.ArrayBuffer[CommentSchema.this.EventComment] = CommentSchema.this.eventComments.filter(((x$1: CommentSchema.this.EventComment) => x$1.event.~~(this)));
  def numComments: Int = NewsEventWithComments.this.comments.length;
  def userPostAnonymously(text: String): Unit = CommentSchema.this.editDB[Unit](CommentSchema.this.User.ensure("Anonymous").flatMap[Unit](((user: CommentSchema.this.User) => user.postComment(this, text).map[Unit](((_: CommentSchema.this.EventComment) => ())))))
}
NewsEventWithComments: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.333
         comment userPos numComm

sealed abstract class StockAsset extends java.lang.Object with ScalaObject {
  def this(): texttrading.StockAsset = {
    StockAsset.super.this();
    ()
  }
}
StockAsset: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

case class BigDecimalFormatted extends java.lang.Object with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val b: scala.math.BigDecimal = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def b: scala.math.BigDecimal = BigDecimalFormatted.this.b;
  def this(b: scala.math.BigDecimal): formats.package.BigDecimalFormatted = {
    BigDecimalFormatted.super.this();
    ()
  };
  def $: String = scala.this.Predef.augmentString("$%.2f").format(BigDecimalFormatted.this.b.doubleValue());
  def %(): String = scala.this.Predef.augmentString("%.0f%%").format(BigDecimalFormatted.this.b.doubleValue().*(100));
  def ###(): String = scala.this.Predef.augmentString("%.0f").format(BigDecimalFormatted.this.b.doubleValue());
  <synthetic> def copy(b: scala.math.BigDecimal = b): formats.package.BigDecimalFormatted = new package.this.BigDecimalFormatted(b);
  <synthetic> def copy$default$1: scala.math.BigDecimal @scala.annotation.unchecked.uncheckedVariance = BigDecimalFormatted.this.b;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(BigDecimalFormatted.this);
  override def toString(): String = ScalaRunTime.this._toString(BigDecimalFormatted.this);
  override def equals(x$1: Any): Boolean = BigDecimalFormatted.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (b: scala.math.BigDecimal)formats.package.BigDecimalFormatted((b$1 @ _)) if b$1.==(b) => x$1.asInstanceOf[formats.package.BigDecimalFormatted].canEqual(BigDecimalFormatted.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "BigDecimalFormatted";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => b
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[formats.package.BigDecimalFormatted]()
}
BigDecimalFormatted: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
         $percen $hash$h       $
       b     X       X       X  

case class BadInput extends scala.`package`.Exception with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val msg: String = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def msg: String = BadInput.this.msg;
  def this(msg: String): intform.BadInput = {
    BadInput.super.this();
    ()
  };
  <synthetic> def copy(msg: String = msg): intform.BadInput = new intform.this.BadInput(msg);
  <synthetic> def copy$default$1: String @scala.annotation.unchecked.uncheckedVariance = BadInput.this.msg;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(BadInput.this);
  override def equals(x$1: Any): Boolean = BadInput.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (msg: String)intform.BadInput((msg$1 @ _)) if msg$1.==(msg) => x$1.asInstanceOf[intform.BadInput].canEqual(BadInput.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "BadInput";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => msg
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[intform.BadInput]()
}
BadInput: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
     msg

case class Declined extends java.lang.Object with NewsSchema.this.Action with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val from: NewsSchema.this.P = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def from: NewsSchema.this.P = Declined.this.from;
  <caseaccessor> <paramaccessor> private[this] val to: NewsSchema.this.P = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def to: NewsSchema.this.P = Declined.this.to;
  <caseaccessor> <paramaccessor> private[this] val derivative: model.Derivative = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def derivative: model.Derivative = Declined.this.derivative;
  <caseaccessor> <paramaccessor> private[this] val price: model.Dollars = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def price: model.Dollars = Declined.this.price;
  def this(from: NewsSchema.this.P, to: NewsSchema.this.P, derivative: model.Derivative, price: model.Dollars): NewsSchema.this.Declined = {
    Declined.super.this();
    ()
  };
  <synthetic> def copy(from: NewsSchema.this.P = from, to: NewsSchema.this.P = to, derivative: model.Derivative = derivative, price: model.Dollars = price): NewsSchema.this.Declined = new NewsSchema.this.Declined(from, to, derivative, price);
  <synthetic> def copy$default$4: model.Dollars @scala.annotation.unchecked.uncheckedVariance = Declined.this.price;
  <synthetic> def copy$default$3: model.Derivative @scala.annotation.unchecked.uncheckedVariance = Declined.this.derivative;
  <synthetic> def copy$default$2: NewsSchema.this.P @scala.annotation.unchecked.uncheckedVariance = Declined.this.to;
  <synthetic> def copy$default$1: NewsSchema.this.P @scala.annotation.unchecked.uncheckedVariance = Declined.this.from;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(Declined.this);
  override def toString(): String = ScalaRunTime.this._toString(Declined.this);
  override def equals(x$1: Any): Boolean = Declined.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (from: NewsSchema.this.P, to: NewsSchema.this.P, derivative: model.Derivative, price: model.Dollars)NewsSchema.this.Declined((from$3 @ _), (to$3 @ _), (derivative$3 @ _), (price$5 @ _)) if from$3.==(from).&&(to$3.==(to)).&&(derivative$3.==(derivative)).&&(price$5.==(price)) => x$1.asInstanceOf[NewsSchema.this.Declined].canEqual(Declined.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "Declined";
  override def productArity: Int = 4;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => from
    case 1 => to
    case 2 => derivative
    case 3 => price
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[NewsSchema.this.Declined]()
}
Declined: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
   price
 derivat
      to
    from

final object StockUpdates extends  {
  def this() = _;
  private <static> val serialVersionUID: Long = _
}
StockUpdates: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

case class Bid extends java.lang.Object with NewsSchema.this.Action with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val from: NewsSchema.this.P = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def from: NewsSchema.this.P = Bid.this.from;
  <caseaccessor> <paramaccessor> private[this] val on: NewsSchema.this.AuctionOffer = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def on: NewsSchema.this.AuctionOffer = Bid.this.on;
  <caseaccessor> <paramaccessor> private[this] val price: model.Dollars = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def price: model.Dollars = Bid.this.price;
  def this(from: NewsSchema.this.P, on: NewsSchema.this.AuctionOffer, price: model.Dollars): NewsSchema.this.Bid = {
    Bid.super.this();
    ()
  };
  <synthetic> def copy(from: NewsSchema.this.P = from, on: NewsSchema.this.AuctionOffer = on, price: model.Dollars = price): NewsSchema.this.Bid = new NewsSchema.this.Bid(from, on, price);
  <synthetic> def copy$default$3: model.Dollars @scala.annotation.unchecked.uncheckedVariance = Bid.this.price;
  <synthetic> def copy$default$2: NewsSchema.this.AuctionOffer @scala.annotation.unchecked.uncheckedVariance = Bid.this.on;
  <synthetic> def copy$default$1: NewsSchema.this.P @scala.annotation.unchecked.uncheckedVariance = Bid.this.from;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(Bid.this);
  override def toString(): String = ScalaRunTime.this._toString(Bid.this);
  override def equals(x$1: Any): Boolean = Bid.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (from: NewsSchema.this.P, on: NewsSchema.this.AuctionOffer, price: model.Dollars)NewsSchema.this.Bid((from$5 @ _), (on$1 @ _), (price$7 @ _)) if from$5.==(from).&&(on$1.==(on)).&&(price$7.==(price)) => x$1.asInstanceOf[NewsSchema.this.Bid].canEqual(Bid.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "Bid";
  override def productArity: Int = 3;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => from
    case 1 => on
    case 2 => price
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[NewsSchema.this.Bid]()
}
Bid: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
      on
    from
   price

sealed abstract class ComparableSecurity extends java.lang.Object with ScalaObject {
  def this(): model.ComparableSecurity = {
    ComparableSecurity.super.this();
    ()
  };
  def toPrice: model.Price
}
ComparableSecurity: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
 toPrice

class AuctionPage extends java.lang.Object with intform.Page with net.liftweb.common.Loggable with ScalaObject {
  def this(): code.snippet.AuctionPage = {
    AuctionPage.super.this();
    ()
  };
  def render: scala.xml.NodeSeq = AuctionPage.this.refreshable.render;
  private[this] val param: net.liftweb.common.Box[String] = net.liftweb.http.S.param("id");
  <stable> <accessor> def param: net.liftweb.common.Box[String] = AuctionPage.this.param;
  private[this] val refreshable: intform.Refreshable.NeedRenderable with intform.Refreshable = intform.Refreshable.apply(AuctionPage.this.normal.openOr[scala.xml.NodeSeq](AuctionPage.this.error));
  <stable> <accessor> def refreshable: intform.Refreshable.NeedRenderable with intform.Refreshable = AuctionPage.this.refreshable;
  def normal: net.liftweb.common.Box[scala.xml.NodeSeq] = model.schema.readDB[net.liftweb.common.Box[scala.xml.NodeSeq]](AuctionPage.this.param.flatMap[scala.xml.NodeSeq](((id: String) => try {
  new net.liftweb.common.Full[model.schema.AuctionOffer](model.schema.AuctionOffer.byID(id))
} catch {
  case model.schema.NoSuchAuction => net.liftweb.common.Empty
}.map[(model.schema.AuctionOffer, model.Dollars, Option[model.Link[model.schema.Portfolio]], model.Link[model.schema.Portfolio], model.Derivative)](((auction: model.schema.AuctionOffer) => {
  val goingPrice: model.Dollars = auction.goingPrice;
  val highBidder: Option[model.Link[model.schema.Portfolio]] = auction.highBid.map[model.Link[model.schema.Portfolio]](((x$1: model.schema.AuctionBid) => x$1.by));
  val seller: model.Link[model.schema.Portfolio] = auction.offerer;
  val deriv: model.Derivative = auction.derivative;
  new (model.schema.AuctionOffer, model.Dollars, Option[model.Link[model.schema.Portfolio]], model.Link[model.schema.Portfolio], model.Derivative)(auction, goingPrice, highBidder, seller, deriv)
})).map[scala.xml.NodeSeq](((x$3: (model.schema.AuctionOffer, model.Dollars, Option[model.Link[model.schema.Portfolio]], model.Link[model.schema.Portfolio], model.Derivative)) => (x$3: (model.schema.AuctionOffer, model.Dollars, Option[model.Link[model.schema.Portfolio]], model.Link[model.schema.Portfolio], model.Derivative) @unchecked) match {
    case (_1: model.schema.AuctionOffer, _2: model.Dollars, _3: Option[model.Link[model.schema.Portfolio]], _4: model.Link[model.schema.Portfolio], _5: model.Derivative)(model.schema.AuctionOffer, model.Dollars, Option[model.Link[model.schema.Portfolio]], model.Link[model.schema.Portfolio], model.Derivative)((auction @ _), (goingPrice @ _), (highBidder @ _), (seller @ _), (deriv @ _)) => {
      lazy var all$lzy: scala.xml.Elem = _;
      <stable> <accessor> lazy def all: scala.xml.Elem = {
        all$lzy = {
          {
            var $md: scala.xml.MetaData = scala.xml.Null;
            $md = new scala.xml.UnprefixedAttribute("id", new scala.xml.Text("auction"), $md);
            $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("block"), $md);
            new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
              val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
              $buf.&+(new scala.xml.Text("\012                    "));
              $buf.&+({
                {
                  new scala.xml.Elem(null, "h2", scala.xml.Null, scala.this.Predef.$scope, ({
                    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                    $buf.&+(new scala.xml.Text("Auction #"));
                    $buf.&+(id);
                    $buf
                  }: _*))
                }
              });
              $buf.&+(new scala.xml.Text("\012                    \012                    "));
              $buf.&+({
                {
                  var $md: scala.xml.MetaData = scala.xml.Null;
                  $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("boxy auction"), $md);
                  new scala.xml.Elem(null, "table", $md, scala.this.Predef.$scope, ({
                    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                    $buf.&+(new scala.xml.Text("\012                        "));
                    $buf.&+({
                      {
                        new scala.xml.Elem(null, "tr", scala.xml.Null, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(new scala.xml.Text("\012                            "));
                          $buf.&+({
                            {
                              new scala.xml.Elem(null, "th", scala.xml.Null, scala.this.Predef.$scope, ({
                                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                                $buf.&+(new scala.xml.Text("Seller:"));
                                $buf
                              }: _*))
                            }
                          });
                          $buf.&+(new scala.xml.Text("\012                            "));
                          $buf.&+({
                            {
                              new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                                $buf.&+(PortfolioLink.apply(model.this.Link.extract[model.schema.Portfolio](seller)(model.schema.portfolios)));
                                $buf
                              }: _*))
                            }
                          });
                          $buf.&+(new scala.xml.Text("\012                        "));
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012                        "));
                    $buf.&+({
                      {
                        new scala.xml.Elem(null, "tr", scala.xml.Null, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(new scala.xml.Text("\012                            "));
                          $buf.&+({
                            {
                              new scala.xml.Elem(null, "th", scala.xml.Null, scala.this.Predef.$scope, ({
                                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                                $buf.&+(new scala.xml.Text("Going Price:"));
                                $buf
                              }: _*))
                            }
                          });
                          $buf.&+(new scala.xml.Text("\012                            "));
                          $buf.&+({
                            {
                              new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                                $buf.&+(goingPrice.$);
                                $buf
                              }: _*))
                            }
                          });
                          $buf.&+(new scala.xml.Text("\012                        "));
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012                        "));
                    $buf.&+({
                      {
                        new scala.xml.Elem(null, "tr", scala.xml.Null, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(new scala.xml.Text("\012                            "));
                          $buf.&+({
                            {
                              new scala.xml.Elem(null, "th", scala.xml.Null, scala.this.Predef.$scope, ({
                                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                                $buf.&+(new scala.xml.Text("High Bidder:"));
                                $buf
                              }: _*))
                            }
                          });
                          $buf.&+(new scala.xml.Text("\012                            "));
                          $buf.&+({
                            {
                              new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                                $buf.&+(highBidder.map[scala.xml.NodeSeq](((x$2: model.Link[model.schema.Portfolio]) => PortfolioLink.apply(model.this.Link.extract[model.schema.Portfolio](x$2)(model.schema.portfolios)))).getOrElse[java.lang.Object]("-"));
                                $buf
                              }: _*))
                            }
                          });
                          $buf.&+(new scala.xml.Text("\012                        "));
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012                        "));
                    $buf.&+({
                      {
                        new scala.xml.Elem(null, "tr", scala.xml.Null, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(new scala.xml.Text("\012                            "));
                          $buf.&+({
                            {
                              new scala.xml.Elem(null, "th", scala.xml.Null, scala.this.Predef.$scope, ({
                                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                                $buf.&+(new scala.xml.Text("Derivative:"));
                                $buf
                              }: _*))
                            }
                          });
                          $buf.&+(new scala.xml.Text("\012                            "));
                          $buf.&+({
                            {
                              new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                                $buf.&+(derivative);
                                $buf
                              }: _*))
                            }
                          });
                          $buf.&+(new scala.xml.Text("\012                        "));
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012                    "));
                    $buf
                  }: _*))
                }
              });
              $buf.&+(new scala.xml.Text("\012                    \012                    "));
              $buf.&+({
                {
                  new scala.xml.Elem(null, "h2", scala.xml.Null, scala.this.Predef.$scope, ({
                    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                    $buf.&+(new scala.xml.Text("Cast a Bid"));
                    $buf
                  }: _*))
                }
              });
              $buf.&+(new scala.xml.Text("\012                    "));
              $buf.&+(bidForm.render);
              $buf.&+(new scala.xml.Text("\012                "));
              $buf
            }: _*))
          }
        };
        all$lzy
      };
      lazy var derivative$lzy: scala.xml.Elem = _;
      <stable> <accessor> lazy def derivative: scala.xml.Elem = {
        derivative$lzy = {
          {
            new scala.xml.Elem(null, "table", scala.xml.Null, scala.this.Predef.$scope, ({
              val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
              $buf.&+(new scala.xml.Text("\012                    "));
              $buf.&+({
                {
                  new scala.xml.Elem(null, "tr", scala.xml.Null, scala.this.Predef.$scope, ({
                    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                    $buf.&+(new scala.xml.Text("\012                        "));
                    $buf.&+({
                      {
                        new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(new scala.xml.Text("Securities:"));
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+(new scala.xml.Text(" "));
                    $buf.&+({
                      {
                        new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(formats.`package`.securitiesFormatted(deriv.securities).toHumanString);
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012                    "));
                    $buf
                  }: _*))
                }
              });
              $buf.&+(new scala.xml.Text("\012                    "));
              $buf.&+({
                {
                  new scala.xml.Elem(null, "tr", scala.xml.Null, scala.this.Predef.$scope, ({
                    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                    $buf.&+(new scala.xml.Text("\012                        "));
                    $buf.&+({
                      {
                        new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(new scala.xml.Text("Exercise Date:"));
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+(new scala.xml.Text(" "));
                    $buf.&+({
                      {
                        new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(formats.`package`.dateTimeFormatted(deriv.exec).toNearbyString);
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012                    "));
                    $buf
                  }: _*))
                }
              });
              $buf.&+(new scala.xml.Text("\012                    "));
              $buf.&+({
                {
                  new scala.xml.Elem(null, "tr", scala.xml.Null, scala.this.Predef.$scope, ({
                    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                    $buf.&+(new scala.xml.Text("\012                        "));
                    $buf.&+({
                      {
                        new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(new scala.xml.Text("Condition:"));
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+(new scala.xml.Text(" "));
                    $buf.&+({
                      {
                        new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(formats.`package`.conditionFormatted(deriv.condition).toHumanString);
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012                    "));
                    $buf
                  }: _*))
                }
              });
              $buf.&+(new scala.xml.Text("\012                "));
              $buf
            }: _*))
          }
        };
        derivative$lzy
      };
      lazy var bidForm$lzy: intform.Form[AuctionPage.this.Bid] = _;
      <stable> <accessor> lazy def bidForm: intform.Form[AuctionPage.this.Bid] = {
        bidForm$lzy = intform.Form.apply[AuctionPage.this.Bid, up.HList.:+:[model.Dollars,up.HNil]](intform.`package`.hlistify1[model.Dollars, AuctionPage.this.Bid](AuctionPage.this.Bid), intform.`package`.klist1[intform.TextField, model.Dollars](bidField), {
          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
          $buf.&+({
            {
              new scala.xml.Elem(null, "p", scala.xml.Null, scala.this.Predef.$scope, ({
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+(new scala.xml.Text("Your bid: "));
                $buf.&+(bidField.main);
                $buf.&+(new scala.xml.Text(" "));
                $buf.&+(bidField.errors);
                $buf.&+(new scala.xml.Text("\012                    (> "));
                $buf.&+(goingPrice.$);
                $buf.&+(new scala.xml.Text(") "));
                $buf.&+(castSubmit.main);
                $buf.&+(new scala.xml.Text("\012                "));
                $buf
              }: _*))
            }
          });
          $buf.&+({
            {
              new scala.xml.Elem(null, "p", scala.xml.Null, scala.this.Predef.$scope, ({
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+(castSubmit.errors);
                $buf
              }: _*))
            }
          });
          xml.this.NodeSeq.seqToNodeSeq($buf)
        });
        bidForm$lzy
      };
      lazy var bidField$lzy: code.snippet.DollarsField = _;
      <stable> <accessor> lazy def bidField: code.snippet.DollarsField = {
        bidField$lzy = DollarsField.apply(goingPrice.no$);
        bidField$lzy
      };
      lazy var castSubmit$lzy: intform.Submit[AuctionPage.this.Bid] = _;
      <stable> <accessor> lazy def castSubmit: intform.Submit[AuctionPage.this.Bid] = {
        castSubmit$lzy = intform.Submit.apply[AuctionPage.this.Bid](bidForm, "Cast", intform.Submit.apply$default$3[Nothing])(((x0$1: AuctionPage.this.Bid) => x0$1 match {
          case (amount: model.Dollars)AuctionPage.this.Bid((amt @ _)) => {
            try {
              val port: model.schema.Portfolio = control.PortfolioSwitcher.currentPortfolio;
              port.userCastBid(auction, amt);
              bidForm.reset();
              AuctionPage.this.refreshable.refresh()
            } catch {
              case control.LoginManager.NotLoggedIn => throw new intform.BadInput("You must be logged in to bid")
              case (going: model.Dollars)model.schema.BidTooSmall((going @ _)) => throw new intform.BadInput(scala.this.Predef.augmentString("The bid must be more than %s").format(going.$))
            }
          }
        }));
        castSubmit$lzy
      };
      all
    }
  })))));
  case class Bid extends java.lang.Object with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val amount: model.Dollars = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def amount: model.Dollars = Bid.this.amount;
    def this(amount: model.Dollars): AuctionPage.this.Bid = {
      Bid.super.this();
      ()
    };
    <synthetic> def copy(amount: model.Dollars = amount): AuctionPage.this.Bid = new AuctionPage.this.Bid(amount);
    <synthetic> def copy$default$1: model.Dollars @scala.annotation.unchecked.uncheckedVariance = Bid.this.amount;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(Bid.this);
    override def toString(): String = ScalaRunTime.this._toString(Bid.this);
    override def equals(x$1: Any): Boolean = Bid.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (amount: model.Dollars)AuctionPage.this.Bid((amount$1 @ _)) if amount$1.==(amount) => x$1.asInstanceOf[AuctionPage.this.Bid].canEqual(Bid.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "Bid";
    override def productArity: Int = 1;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => amount
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[AuctionPage.this.Bid]()
  };
  final <synthetic> object Bid extends scala.runtime.AbstractFunction1[model.Dollars,AuctionPage.this.Bid] with ScalaObject with Serializable {
    def this(): object AuctionPage.this.Bid = {
      Bid.super.this();
      ()
    };
    final override def toString(): java.lang.String = "Bid";
    case <synthetic> def unapply(x$0: AuctionPage.this.Bid): Option[model.Dollars] = if (x$0.==(null))
      scala.this.None
    else
      new Some[model.Dollars](x$0.amount);
    case <synthetic> def apply(amount: model.Dollars): AuctionPage.this.Bid = new AuctionPage.this.Bid(amount)
  };
  @volatile <synthetic> private[this] var Bid$module: object AuctionPage.this.Bid = _;
  final <synthetic> <stable> def Bid: object AuctionPage.this.Bid = {
    AuctionPage.this.Bid$module = new object AuctionPage.this.Bid();
    AuctionPage.this.Bid$module
  };
  def error: scala.xml.Elem = {
    {
      new scala.xml.Elem(null, "p", scala.xml.Null, scala.this.Predef.$scope, ({
        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
        $buf.&+(new scala.xml.Text("This auction does not seem to exist anymore."));
        $buf
      }: _*))
    }
  }
}
AuctionPage: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=1.000
           error  render  normal
 Bid$mod                     X  

case class StockDollars extends StockAsset with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val ticker: String = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def ticker: String = StockDollars.this.ticker;
  <caseaccessor> <paramaccessor> private[this] val dollars: model.Dollars = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def dollars: model.Dollars = StockDollars.this.dollars;
  def this(ticker: String, dollars: model.Dollars): texttrading.StockDollars = {
    StockDollars.super.this();
    ()
  };
  override def toString: java.lang.String = StockDollars.this.dollars.$.+(" of ").+(StockDollars.this.ticker);
  <synthetic> def copy(ticker: String = ticker, dollars: model.Dollars = dollars): texttrading.StockDollars = new texttrading.this.StockDollars(ticker, dollars);
  <synthetic> def copy$default$2: model.Dollars @scala.annotation.unchecked.uncheckedVariance = StockDollars.this.dollars;
  <synthetic> def copy$default$1: String @scala.annotation.unchecked.uncheckedVariance = StockDollars.this.ticker;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(StockDollars.this);
  override def equals(x$1: Any): Boolean = StockDollars.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (ticker: String, dollars: model.Dollars)texttrading.StockDollars((ticker$3 @ _), (dollars$1 @ _)) if ticker$3.==(ticker).&&(dollars$1.==(dollars)) => x$1.asInstanceOf[texttrading.StockDollars].canEqual(StockDollars.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "StockDollars";
  override def productArity: Int = 2;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => ticker
    case 1 => dollars
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[texttrading.StockDollars]()
}
StockDollars: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
  ticker
 dollars

class Table[R >: Nothing <: model.KL] extends scala.collection.mutable.ArrayBuffer[R] with model.RefreshHub with net.liftweb.common.Loggable with ScalaObject {
  def this(): model.Table[R] = {
    Table.super.this();
    ()
  };
  def lookup(k: model.package.Key): Option[R] = this.filter(((x$1: R) => x$1.id.==(k))).headOption;
  def insert(r: R): Unit = {
    Table.this.logger.info("(Inserting) ".+(r));
    {
      this.+=(r);
      ()
    }
  };
  def update(r: R): Unit = {
    this.delete(r);
    this.insert(r)
  };
  def delete(r: R): Unit = {
    Table.this.logger.info("(Deleting) ".+(r));
    this.remove(this.indexWhere(((x$2: R) => x$2.id.==(r.id))));
    Table.this.logger.info("Leaving ".+(this))
  }
}
Table: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.500
          update  lookup  insert  delete

final object Form extends java.lang.Object with ScalaObject {
  def this(): object intform.Form = {
    Form.super.this();
    ()
  };
  def apply[A >: Nothing <: Any, F >: Nothing <: up.HList](c: F => A, f: up.KList[intform.Field,F], r: => scala.xml.NodeSeq): intform.Form[A] = new intform.Form[A](new intform.AggregateField[A,F](c, f, (() => r)))
}
Form: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
           apply

case class Auctioned extends java.lang.Object with NewsSchema.this.Action with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val from: NewsSchema.this.P = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def from: NewsSchema.this.P = Auctioned.this.from;
  <caseaccessor> <paramaccessor> private[this] val derivative: model.Derivative = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def derivative: model.Derivative = Auctioned.this.derivative;
  <caseaccessor> <paramaccessor> private[this] val price: model.Dollars = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def price: model.Dollars = Auctioned.this.price;
  def this(from: NewsSchema.this.P, derivative: model.Derivative, price: model.Dollars): NewsSchema.this.Auctioned = {
    Auctioned.super.this();
    ()
  };
  <synthetic> def copy(from: NewsSchema.this.P = from, derivative: model.Derivative = derivative, price: model.Dollars = price): NewsSchema.this.Auctioned = new NewsSchema.this.Auctioned(from, derivative, price);
  <synthetic> def copy$default$3: model.Dollars @scala.annotation.unchecked.uncheckedVariance = Auctioned.this.price;
  <synthetic> def copy$default$2: model.Derivative @scala.annotation.unchecked.uncheckedVariance = Auctioned.this.derivative;
  <synthetic> def copy$default$1: NewsSchema.this.P @scala.annotation.unchecked.uncheckedVariance = Auctioned.this.from;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(Auctioned.this);
  override def toString(): String = ScalaRunTime.this._toString(Auctioned.this);
  override def equals(x$1: Any): Boolean = Auctioned.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (from: NewsSchema.this.P, derivative: model.Derivative, price: model.Dollars)NewsSchema.this.Auctioned((from$4 @ _), (derivative$4 @ _), (price$6 @ _)) if from$4.==(from).&&(derivative$4.==(derivative)).&&(price$6.==(price)) => x$1.asInstanceOf[NewsSchema.this.Auctioned].canEqual(Auctioned.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "Auctioned";
  override def productArity: Int = 3;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => from
    case 1 => derivative
    case 2 => price
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[NewsSchema.this.Auctioned]()
}
Auctioned: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
   price
 derivat
    from

final protected object accessToken extends net.liftweb.http.SessionVar[Option[org.scribe.model.Token]] with ScalaObject {
  def this(): object code.control.TwitterLogin.accessToken = {
    accessToken.super.this(scala.None);
    ()
  }
}
accessToken: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

case class OldUser extends java.lang.Object with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val user: UserSchema.this.User = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def user: UserSchema.this.User = OldUser.this.user;
  def this(user: UserSchema.this.User): UserSchema.this.OldUser = {
    OldUser.super.this();
    ()
  };
  <synthetic> def copy(user: UserSchema.this.User = user): UserSchema.this.OldUser = new UserSchema.this.OldUser(user);
  <synthetic> def copy$default$1: UserSchema.this.User @scala.annotation.unchecked.uncheckedVariance = OldUser.this.user;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(OldUser.this);
  override def toString(): String = ScalaRunTime.this._toString(OldUser.this);
  override def equals(x$1: Any): Boolean = OldUser.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (user: UserSchema.this.User)UserSchema.this.OldUser((user$3 @ _)) if user$3.==(user) => x$1.asInstanceOf[UserSchema.this.OldUser].canEqual(OldUser.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "OldUser";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => user
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[UserSchema.this.OldUser]()
}
OldUser: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
    user

abstract trait SubmitRender extends java.lang.Object with intform.FieldRender with ScalaObject {
  def /*SubmitRender*/$init$(): Unit = {
    ()
  };
  <stable> <accessor> def value: String;
  def submitAjax(): net.liftweb.http.js.JsCmd;
  def main: scala.xml.Elem = net.liftweb.http.SHtml.ajaxSubmit(SubmitRender.this.value, {
    (() => SubmitRender.this.submitAjax())
  })
}
SubmitRender: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
            main
 submitA     X  
   value     X  

final object Refreshable extends java.lang.Object with ScalaObject {
  def this(): object intform.Refreshable = {
    Refreshable.super.this();
    ()
  };
  class NeedRenderable extends java.lang.Object with intform.Renderable with ScalaObject {
    <paramaccessor> private[this] val r: () => scala.xml.NodeSeq = _;
    def this(r: () => scala.xml.NodeSeq): intform.Refreshable.NeedRenderable = {
      NeedRenderable.super.this();
      ()
    };
    def render: scala.xml.NodeSeq = NeedRenderable.this.r.apply()
  };
  def apply(r: => scala.xml.NodeSeq): intform.Refreshable.NeedRenderable with intform.Refreshable = {
    final class $anon extends Refreshable.this.NeedRenderable with intform.Refreshable {
      def this(): anonymous class $anon = {
        $anon.super.this((() => r));
        ()
      }
    };
    new $anon()
  }
}
Refreshable: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
           apply

final object Dollars extends java.lang.Object with ScalaObject with Serializable {
  def this(): object model.Dollars = {
    Dollars.super.this();
    ()
  };
  def apply(str: String): model.Dollars = new model.Dollars(scala.math.BigDecimal.apply(str));
  case <synthetic> def unapply(x$0: model.Dollars): Option[scala.math.BigDecimal] = if (x$0.==(null))
    scala.this.None
  else
    new Some[scala.math.BigDecimal](x$0.dollars);
  case <synthetic> def apply(dollars: scala.math.BigDecimal): model.Dollars = new model.this.Dollars(dollars);
  protected def readResolve(): java.lang.Object = model.this.Dollars
}
Dollars: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.500
           apply readRes

final object FormSubmit extends java.lang.Object with ScalaObject {
  def this(): object intform.FormSubmit = {
    FormSubmit.super.this();
    ()
  };
  def apply(r: intform.Refreshable, text: String)(callback: => net.liftweb.http.js.JsCmd): intform.FormSubmit = new FormSubmit(r, text, (() => callback));
  def apply(text: String)(callback: => Unit): intform.FormSubmit = new FormSubmit(Refreshable.apply(xml.this.NodeSeq.seqToNodeSeq(immutable.this.Nil)), text, (() => {
    callback;
    net.liftweb.http.js.JsCmds.Noop
  }));
  def rendered(text: String)(callback: => net.liftweb.http.js.JsCmd): scala.xml.NodeSeq = {
    lazy var sub$lzy: intform.FormSubmit = _;
    <stable> <accessor> lazy def sub: intform.FormSubmit = {
      sub$lzy = new FormSubmit(ref, text, (() => callback));
      sub$lzy
    };
    lazy var ref$lzy: intform.Refreshable = _;
    <stable> <accessor> lazy def ref: intform.Refreshable = {
      ref$lzy = Refreshable.apply(sub.render.++[scala.xml.Node, scala.xml.NodeSeq](sub.errors)(xml.this.NodeSeq.canBuildFrom));
      ref$lzy
    };
    ref.render
  }
}
FormSubmit: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.583
           apply   apply rendere

final object commentPage extends java.lang.Object with ScalaObject {
  def this(): object code.snippet.commentPage = {
    commentPage.super.this();
    ()
  };
  def apply(ev: model.schema.NewsEvent): scala.xml.NodeSeq = {
    lazy var main$lzy: intform.Refreshable.NeedRenderable with intform.Refreshable = _;
    <stable> <accessor> lazy def main: intform.Refreshable.NeedRenderable with intform.Refreshable = {
      main$lzy = intform.Refreshable.apply({
        {
          new scala.xml.Elem(null, "div", scala.xml.Null, scala.this.Predef.$scope, ({
            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
            $buf.&+(new scala.xml.Text("\012                "));
            $buf.&+({
              {
                var $md: scala.xml.MetaData = scala.xml.Null;
                $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("comments"), $md);
                new scala.xml.Elem(null, "h3", $md, scala.this.Predef.$scope, ({
                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                  $buf.&+(new scala.xml.Text("Comments:"));
                  $buf
                }: _*))
              }
            });
            $buf.&+(new scala.xml.Text("\012                "));
            $buf.&+(if (ev.comments.isEmpty)
              {
                {
                  new scala.xml.Elem(null, "p", scala.xml.Null, scala.this.Predef.$scope, ({
                    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                    $buf.&+(new scala.xml.Text("None"));
                    $buf
                  }: _*))
                }
              }
            else
              showComments);
            $buf.&+(new scala.xml.Text("\012                "));
            $buf.&+(postForm.render);
            $buf.&+(new scala.xml.Text("\012            "));
            $buf
          }: _*))
        }
      });
      main$lzy
    };
    def showComments: scala.collection.mutable.ArrayBuffer[scala.xml.Elem] = ev.comments.map[scala.xml.Elem, scala.collection.mutable.ArrayBuffer[scala.xml.Elem]]({
      ((c: model.schema.EventComment) => showComment(c))
    })(mutable.this.ArrayBuffer.canBuildFrom[scala.xml.Elem]);
    def showComment(c: model.schema.EventComment): scala.xml.Elem = {
      {
        var $md: scala.xml.MetaData = scala.xml.Null;
        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("comment"), $md);
        new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
          $buf.&+(new scala.xml.Text("\012                "));
          $buf.&+({
            {
              var $md: scala.xml.MetaData = scala.xml.Null;
              $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("commentDate"), $md);
              new scala.xml.Elem(null, "span", $md, scala.this.Predef.$scope, ({
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+(formats.`package`.dateTimeFormatted(c.when).toNearbyString);
                $buf
              }: _*))
            }
          });
          $buf.&+(new scala.xml.Text("\012                "));
          $buf.&+({
            {
              var $md: scala.xml.MetaData = scala.xml.Null;
              $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("commentAuthor"), $md);
              new scala.xml.Elem(null, "span", $md, scala.this.Predef.$scope, ({
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+(UserLink.apply(c.by));
                $buf.&+(new scala.xml.Text(":"));
                $buf
              }: _*))
            }
          });
          $buf.&+(new scala.xml.Text("\012                "));
          $buf.&+({
            {
              var $md: scala.xml.MetaData = scala.xml.Null;
              $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("commentText"), $md);
              new scala.xml.Elem(null, "span", $md, scala.this.Predef.$scope, ({
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+(c.text);
                $buf
              }: _*))
            }
          });
          $buf.&+(new scala.xml.Text("\012            "));
          $buf
        }: _*))
      }
    };
    lazy var postForm$lzy: intform.Form[String] = _;
    <stable> <accessor> lazy def postForm: intform.Form[String] = {
      postForm$lzy = intform.Form.apply[String, up.HList.:+:[String,up.HNil]](intform.`package`.hlistify1[String, String]({
        ((x: String) => scala.this.Predef.identity[String](x))
      }), intform.`package`.klist1[intform.Field, String](commentField), {
        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
        $buf.&+({
          {
            new scala.xml.Elem(null, "h3", scala.xml.Null, scala.this.Predef.$scope, ({
              val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
              $buf.&+(new scala.xml.Text("Add comment:"));
              $buf
            }: _*))
          }
        });
        $buf.&+({
          {
            new scala.xml.Elem(null, "p", scala.xml.Null, scala.this.Predef.$scope, ({
              val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
              $buf.&+(commentField.main);
              $buf
            }: _*))
          }
        });
        $buf.&+({
          {
            new scala.xml.Elem(null, "p", scala.xml.Null, scala.this.Predef.$scope, ({
              val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
              $buf.&+(postSubmit.main);
              $buf.&+(new scala.xml.Text(" "));
              $buf.&+(postSubmit.errors);
              $buf
            }: _*))
          }
        });
        xml.this.NodeSeq.seqToNodeSeq($buf)
      });
      postForm$lzy
    };
    lazy var commentField$lzy: intform.TextAreaField = _;
    <stable> <accessor> lazy def commentField: intform.TextAreaField = {
      commentField$lzy = intform.TextAreaField.apply(intform.TextAreaField.apply$default$1);
      commentField$lzy
    };
    lazy var postSubmit$lzy: intform.Submit[String] = _;
    <stable> <accessor> lazy def postSubmit: intform.Submit[String] = {
      postSubmit$lzy = intform.Submit.apply[String](postForm, "Post", intform.Submit.apply$default$3[Nothing])(((x0$1: String) => x0$1 match {
        case (text @ _) => {
          try {
            control.LoginManager.currentUser.userPostComment(ev, text)
          } catch {
            case control.LoginManager.NotLoggedIn => ev.userPostAnonymously(text)
          };
          main.refresh()
        }
      }));
      postSubmit$lzy
    };
    main.render
  }
}
commentPage: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
           apply

case class AuctionBid extends java.lang.Object with model.KL with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val id: model.package.Key = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def id: model.package.Key = AuctionBid.this.id;
  <caseaccessor> <paramaccessor> private[this] val offer: model.Link[AuctionSchema.this.AuctionOffer] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def offer: model.Link[AuctionSchema.this.AuctionOffer] = AuctionBid.this.offer;
  <caseaccessor> <paramaccessor> private[this] val by: model.Link[AuctionSchema.this.Portfolio] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def by: model.Link[AuctionSchema.this.Portfolio] = AuctionBid.this.by;
  <caseaccessor> <paramaccessor> private[this] val price: model.Dollars = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def price: model.Dollars = AuctionBid.this.price;
  def this(id: model.package.Key = model.this.`package`.nextID, offer: model.Link[AuctionSchema.this.AuctionOffer], by: model.Link[AuctionSchema.this.Portfolio], price: model.Dollars): AuctionSchema.this.AuctionBid = {
    AuctionBid.super.this();
    ()
  };
  <synthetic> def copy(id: model.package.Key = id, offer: model.Link[AuctionSchema.this.AuctionOffer] = offer, by: model.Link[AuctionSchema.this.Portfolio] = by, price: model.Dollars = price): AuctionSchema.this.AuctionBid = new AuctionSchema.this.AuctionBid(id, offer, by, price);
  <synthetic> def copy$default$4: model.Dollars @scala.annotation.unchecked.uncheckedVariance = AuctionBid.this.price;
  <synthetic> def copy$default$3: model.Link[AuctionSchema.this.Portfolio] @scala.annotation.unchecked.uncheckedVariance = AuctionBid.this.by;
  <synthetic> def copy$default$2: model.Link[AuctionSchema.this.AuctionOffer] @scala.annotation.unchecked.uncheckedVariance = AuctionBid.this.offer;
  <synthetic> def copy$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = AuctionBid.this.id;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(AuctionBid.this);
  override def toString(): String = ScalaRunTime.this._toString(AuctionBid.this);
  override def equals(x$1: Any): Boolean = AuctionBid.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (id: model.package.Key, offer: model.Link[AuctionSchema.this.AuctionOffer], by: model.Link[AuctionSchema.this.Portfolio], price: model.Dollars)AuctionSchema.this.AuctionBid((id$2 @ _), (offer$1 @ _), (by$1 @ _), (price$2 @ _)) if id$2.==(id).&&(offer$1.==(offer)).&&(by$1.==(by)).&&(price$2.==(price)) => x$1.asInstanceOf[AuctionSchema.this.AuctionBid].canEqual(AuctionBid.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "AuctionBid";
  override def productArity: Int = 4;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => id
    case 1 => offer
    case 2 => by
    case 3 => price
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[AuctionSchema.this.AuctionBid]()
}
AuctionBid: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
      id
   offer
      by
   price

class StringField extends intform.TextField[String] with ScalaObject {
  <paramaccessor> private[this] val initText: String = _;
  def this(initText: String): intform.StringField = {
    StringField.super.this(initText);
    ()
  };
  def produce(): intform.OK[String] = new intform.OK[String](StringField.this.text)
}
StringField: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
         produce
 initTex        

final object News extends java.lang.Object with net.liftweb.common.Loggable with ScalaObject {
  def this(): object code.comet.News = {
    News.super.this();
    ()
  };
  def eventDescription(ev: model.schema.NewsEvent, link: Boolean): scala.collection.immutable.Seq[scala.xml.Node] with Serializable = {
    def alink(text: String): java.io.Serializable = if (link)
      News.link(ev, text)
    else
      text;
    ev.action match {
      case (buyer: model.schema.P, stock: String, shares: model.Shares, dollars: model.Dollars, price: model.Price)model.schema.Bought((buyer @ _), (stock @ _), (shares @ _), (dollars @ _), (price @ _)) => {
        {
          new scala.xml.Elem(null, "span", scala.xml.Null, scala.this.Predef.$scope, ({
            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
            $buf.&+(snippet.PortfolioLink.apply(buyer));
            $buf.&+(new scala.xml.Text(" "));
            $buf.&+(alink("bought"));
            $buf.&+(new scala.xml.Text(" "));
            $buf.&+(dollars.$);
            $buf.&+(new scala.xml.Text(" of "));
            $buf.&+(stock);
            $buf
          }: _*))
        }
      }
      case (seller: model.schema.P, stock: String, shares: model.Shares, dollars: model.Dollars, price: model.Price)model.schema.Sold((seller @ _), (stock @ _), (shares @ _), (dollars @ _), (price @ _)) => {
        {
          new scala.xml.Elem(null, "span", scala.xml.Null, scala.this.Predef.$scope, ({
            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
            $buf.&+(snippet.PortfolioLink.apply(seller));
            $buf.&+(new scala.xml.Text(" "));
            $buf.&+(alink("sold"));
            $buf.&+(new scala.xml.Text(" "));
            $buf.&+(dollars.$);
            $buf.&+(new scala.xml.Text(" of "));
            $buf.&+(stock);
            $buf
          }: _*))
        }
      }
      case (from: model.schema.P, to: model.schema.P, derivative: model.Derivative, price: model.Dollars)model.schema.Offered((from @ _), (to @ _), (derivative @ _), (price @ _)) => {
        {
          new scala.xml.Elem(null, "span", scala.xml.Null, scala.this.Predef.$scope, ({
            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
            $buf.&+(snippet.PortfolioLink.apply(from));
            $buf.&+(new scala.xml.Text(" "));
            $buf.&+(alink("made an offer"));
            $buf.&+(new scala.xml.Text(" to "));
            $buf.&+(snippet.PortfolioLink.apply(to));
            $buf
          }: _*))
        }
      }
      case (from: model.schema.P, to: model.schema.P, derivative: model.Derivative, price: model.Dollars, buyerAside: model.Link[model.schema.DerivativeBuyerSetAside], sellerAside: model.Link[model.schema.DerivativeSellerSetAside])model.schema.Accepted((from @ _), (to @ _), (derivative @ _), (price @ _), _, _) => {
        {
          new scala.xml.Elem(null, "span", scala.xml.Null, scala.this.Predef.$scope, ({
            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
            $buf.&+(snippet.PortfolioLink.apply(to));
            $buf.&+(new scala.xml.Text(" "));
            $buf.&+(alink("accepted"));
            $buf.&+(new scala.xml.Text(" "));
            $buf.&+(snippet.PortfolioLink.apply(from));
            $buf.&+(new scala.xml.Text("\'s offer"));
            $buf
          }: _*))
        }
      }
      case (from: model.schema.P, to: model.schema.P, derivative: model.Derivative, price: model.Dollars)model.schema.Declined((from @ _), (to @ _), (derivative @ _), (price @ _)) => {
        {
          new scala.xml.Elem(null, "span", scala.xml.Null, scala.this.Predef.$scope, ({
            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
            $buf.&+(snippet.PortfolioLink.apply(to));
            $buf.&+(new scala.xml.Text(" "));
            $buf.&+(alink("declined"));
            $buf.&+(new scala.xml.Text(" "));
            $buf.&+(snippet.PortfolioLink.apply(from));
            $buf.&+(new scala.xml.Text("\'s offer"));
            $buf
          }: _*))
        }
      }
      case (from: model.schema.P, derivative: model.Derivative, price: model.Dollars)model.schema.Auctioned((from @ _), (derivative @ _), (price @ _)) => {
        {
          new scala.xml.Elem(null, "span", scala.xml.Null, scala.this.Predef.$scope, ({
            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
            $buf.&+(snippet.PortfolioLink.apply(from));
            $buf.&+(new scala.xml.Text(" "));
            $buf.&+(alink("opened"));
            $buf.&+(new scala.xml.Text(" an auction"));
            $buf
          }: _*))
        }
      }
      case (from: model.schema.P, on: model.schema.AuctionOffer, price: model.Dollars)model.schema.Bid((from @ _), (on @ _), (price @ _)) => {
        {
          new scala.xml.Elem(null, "span", scala.xml.Null, scala.this.Predef.$scope, ({
            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
            $buf.&+(snippet.PortfolioLink.apply(from));
            $buf.&+(new scala.xml.Text(" "));
            $buf.&+(alink("bid"));
            $buf.&+(new scala.xml.Text(" on an auction"));
            $buf
          }: _*))
        }
      }
      case (offerer: model.schema.P, offer: model.schema.AuctionOffer)model.schema.Closed((port @ _), (offer @ _)) => {
        {
          new scala.xml.Elem(null, "span", scala.xml.Null, scala.this.Predef.$scope, ({
            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
            $buf.&+(snippet.PortfolioLink.apply(port));
            $buf.&+(new scala.xml.Text(" "));
            $buf.&+(alink("closed"));
            $buf.&+(new scala.xml.Text(" an auction"));
            $buf
          }: _*))
        }
      }
      case (user: model.schema.P, derivative: model.Derivative)model.schema.Exercised((port @ _), (derivative @ _)) => {
        {
          new scala.xml.Elem(null, "span", scala.xml.Null, scala.this.Predef.$scope, ({
            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
            $buf.&+(snippet.PortfolioLink.apply(port));
            $buf.&+(new scala.xml.Text(" "));
            $buf.&+(alink("exercised"));
            $buf.&+(new scala.xml.Text(" a derivative"));
            $buf
          }: _*))
        }
      }
      case (other @ _) => {
        News.this.logger.warn("Don\'t know the event ".+(other));
        immutable.this.Nil
      }
    }
  };
  def link(ev: model.schema.NewsEvent, text: String): scala.xml.Elem = {
    {
      var $md: scala.xml.MetaData = scala.xml.Null;
      $md = new scala.xml.UnprefixedAttribute("href", "/event?id=".+(ev.id), $md);
      new scala.xml.Elem(null, "a", $md, scala.this.Predef.$scope, ({
        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
        $buf.&+(text);
        $buf
      }: _*))
    }
  };
  def eventBriefTally(ev: model.schema.NewsEvent): scala.collection.immutable.Seq[scala.xml.Node] with Serializable = if (ev.isVotable)
    {
      {
        var $md: scala.xml.MetaData = scala.xml.Null;
        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("brief-tally"), $md);
        new scala.xml.Elem(null, "span", $md, scala.this.Predef.$scope, ({
          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
          $buf.&+(new scala.xml.Text("+"));
          $buf.&+(ev.buyerTally);
          $buf.&+(new scala.xml.Text("/-"));
          $buf.&+(ev.sellerTally);
          $buf
        }: _*))
      }
    }
  else
    immutable.this.Nil
}
News: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.556
         eventDe    link eventBr

abstract trait KL extends java.lang.Object with ScalaObject {
  def /*KL*/$init$(): Unit = {
    ()
  };
  <stable> <accessor> def id: model.package.Key;
  def ~~(o: model.KL): Boolean = o.id.==(this.id);
  def ~~(o: model.package.Key): Boolean = o.==(this.id)
}
KL: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=0.500
         $tilde$ $tilde$
      id     X       X  

case class League extends java.lang.Object with model.KL with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val id: model.package.Key = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def id: model.package.Key = League.this.id;
  <caseaccessor> <paramaccessor> private[this] val name: String = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def name: String = League.this.name;
  <caseaccessor> <paramaccessor> private[this] val startingCash: model.Dollars = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def startingCash: model.Dollars = League.this.startingCash;
  def this(id: model.package.Key = model.this.`package`.nextID, name: String, startingCash: model.Dollars): UserSchema.this.League = {
    League.super.this();
    ()
  };
  <synthetic> def copy(id: model.package.Key = id, name: String = name, startingCash: model.Dollars = startingCash): UserSchema.this.League = new UserSchema.this.League(id, name, startingCash);
  <synthetic> def copy$default$3: model.Dollars @scala.annotation.unchecked.uncheckedVariance = League.this.startingCash;
  <synthetic> def copy$default$2: String @scala.annotation.unchecked.uncheckedVariance = League.this.name;
  <synthetic> def copy$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = League.this.id;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(League.this);
  override def toString(): String = ScalaRunTime.this._toString(League.this);
  override def equals(x$1: Any): Boolean = League.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (id: model.package.Key, name: String, startingCash: model.Dollars)UserSchema.this.League((id$5 @ _), (name$2 @ _), (startingCash$1 @ _)) if id$5.==(id).&&(name$2.==(name)).&&(startingCash$1.==(startingCash)) => x$1.asInstanceOf[UserSchema.this.League].canEqual(League.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "League";
  override def productArity: Int = 3;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => id
    case 1 => name
    case 2 => startingCash
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[UserSchema.this.League]()
}
League: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
    name
      id
 startin

final object SellServlet extends  {
  def this() = _;
  private <static> val serialVersionUID: Long = _
}
SellServlet: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

abstract trait NewsEventWithVotes extends java.lang.Object with ScalaObject { self: VotingSchema.this.NewsEvent => 
  def /*NewsEventWithVotes*/$init$(): Unit = {
    ()
  };
  def isVotable: Boolean = NewsEventWithVotes.this.action match {
    case (from: VotingSchema.this.P, to: VotingSchema.this.P, derivative: model.Derivative, price: model.Dollars, buyerAside: model.Link[VotingSchema.this.DerivativeBuyerSetAside], sellerAside: model.Link[VotingSchema.this.DerivativeSellerSetAside])VotingSchema.this.Accepted(_, _, _, _, (b @ _), (s @ _)) => true
    case (buyer: VotingSchema.this.P, seller: VotingSchema.this.P, derivative: model.Derivative, buyerAside: model.Link[VotingSchema.this.BSA], sellerAside: model.Link[VotingSchema.this.SSA])VotingSchema.this.Won(_, _, _, (b @ _), (s @ _)) => true
    case _ => false
  };
  def asVotable: Option[(VotingSchema.this.DerivativeBuyerSetAside, VotingSchema.this.DerivativeSellerSetAside)] = NewsEventWithVotes.this.action match {
    case (from: VotingSchema.this.P, to: VotingSchema.this.P, derivative: model.Derivative, price: model.Dollars, buyerAside: model.Link[VotingSchema.this.DerivativeBuyerSetAside], sellerAside: model.Link[VotingSchema.this.DerivativeSellerSetAside])VotingSchema.this.Accepted(_, _, _, _, (b @ _), (s @ _)) => new Some[(VotingSchema.this.DerivativeBuyerSetAside, VotingSchema.this.DerivativeSellerSetAside)](new (VotingSchema.this.DerivativeBuyerSetAside, VotingSchema.this.DerivativeSellerSetAside)(model.this.Link.extract[VotingSchema.this.DerivativeBuyerSetAside](b)(VotingSchema.this.derivativeBuyerSetAsides), model.this.Link.extract[VotingSchema.this.DerivativeSellerSetAside](s)(VotingSchema.this.derivativeSellerSetAsides)))
    case (buyer: VotingSchema.this.P, seller: VotingSchema.this.P, derivative: model.Derivative, buyerAside: model.Link[VotingSchema.this.BSA], sellerAside: model.Link[VotingSchema.this.SSA])VotingSchema.this.Won(_, _, _, (b @ _), (s @ _)) => new Some[(VotingSchema.this.BSA, VotingSchema.this.SSA)](new (VotingSchema.this.BSA, VotingSchema.this.SSA)(model.this.Link.extract[VotingSchema.this.BSA](b)(VotingSchema.this.derivativeBuyerSetAsides), model.this.Link.extract[VotingSchema.this.SSA](s)(VotingSchema.this.derivativeSellerSetAsides)))
    case _ => scala.None
  };
  def buyerVotes: scala.collection.mutable.ArrayBuffer[VotingSchema.this.DerivativeBuyerVote] = VotingSchema.this.derivativeBuyerVotes.filter(((x$1: VotingSchema.this.DerivativeBuyerVote) => x$1.event.~~(this)));
  def sellerVotes: scala.collection.mutable.ArrayBuffer[VotingSchema.this.DerivativeSellerVote] = VotingSchema.this.derivativeSellerVotes.filter(((x$2: VotingSchema.this.DerivativeSellerVote) => x$2.event.~~(this)));
  def buyerTally: Int = NewsEventWithVotes.this.buyerVotes.length;
  def sellerTally: Int = NewsEventWithVotes.this.sellerVotes.length
}
NewsEventWithVotes: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=1.000
         isVotab buyerVo asVotab sellerV sellerT buyerTa

case class Won extends java.lang.Object with NewsSchema.this.Action with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val buyer: NewsSchema.this.P = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def buyer: NewsSchema.this.P = Won.this.buyer;
  <caseaccessor> <paramaccessor> private[this] val seller: NewsSchema.this.P = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def seller: NewsSchema.this.P = Won.this.seller;
  <caseaccessor> <paramaccessor> private[this] val derivative: model.Derivative = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def derivative: model.Derivative = Won.this.derivative;
  <caseaccessor> <paramaccessor> private[this] val buyerAside: model.Link[NewsSchema.this.BSA] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def buyerAside: model.Link[NewsSchema.this.BSA] = Won.this.buyerAside;
  <caseaccessor> <paramaccessor> private[this] val sellerAside: model.Link[NewsSchema.this.SSA] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def sellerAside: model.Link[NewsSchema.this.SSA] = Won.this.sellerAside;
  def this(buyer: NewsSchema.this.P, seller: NewsSchema.this.P, derivative: model.Derivative, buyerAside: model.Link[NewsSchema.this.BSA], sellerAside: model.Link[NewsSchema.this.SSA]): NewsSchema.this.Won = {
    Won.super.this();
    ()
  };
  <synthetic> def copy(buyer: NewsSchema.this.P = buyer, seller: NewsSchema.this.P = seller, derivative: model.Derivative = derivative, buyerAside: model.Link[NewsSchema.this.BSA] = buyerAside, sellerAside: model.Link[NewsSchema.this.SSA] = sellerAside): NewsSchema.this.Won = new NewsSchema.this.Won(buyer, seller, derivative, buyerAside, sellerAside);
  <synthetic> def copy$default$5: model.Link[NewsSchema.this.SSA] @scala.annotation.unchecked.uncheckedVariance = Won.this.sellerAside;
  <synthetic> def copy$default$4: model.Link[NewsSchema.this.BSA] @scala.annotation.unchecked.uncheckedVariance = Won.this.buyerAside;
  <synthetic> def copy$default$3: model.Derivative @scala.annotation.unchecked.uncheckedVariance = Won.this.derivative;
  <synthetic> def copy$default$2: NewsSchema.this.P @scala.annotation.unchecked.uncheckedVariance = Won.this.seller;
  <synthetic> def copy$default$1: NewsSchema.this.P @scala.annotation.unchecked.uncheckedVariance = Won.this.buyer;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(Won.this);
  override def toString(): String = ScalaRunTime.this._toString(Won.this);
  override def equals(x$1: Any): Boolean = Won.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (buyer: NewsSchema.this.P, seller: NewsSchema.this.P, derivative: model.Derivative, buyerAside: model.Link[NewsSchema.this.BSA], sellerAside: model.Link[NewsSchema.this.SSA])NewsSchema.this.Won((buyer$2 @ _), (seller$2 @ _), (derivative$5 @ _), (buyerAside$2 @ _), (sellerAside$2 @ _)) if buyer$2.==(buyer).&&(seller$2.==(seller)).&&(derivative$5.==(derivative)).&&(buyerAside$2.==(buyerAside)).&&(sellerAside$2.==(sellerAside)) => x$1.asInstanceOf[NewsSchema.this.Won].canEqual(Won.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "Won";
  override def productArity: Int = 5;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => buyer
    case 1 => seller
    case 2 => derivative
    case 3 => buyerAside
    case 4 => sellerAside
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[NewsSchema.this.Won]()
}
Won: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
   buyer
 sellerA
  seller
 buyerAs
 derivat

case class BigDecimalOptionFormatted extends java.lang.Object with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val b: Option[scala.math.BigDecimal] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def b: Option[scala.math.BigDecimal] = BigDecimalOptionFormatted.this.b;
  def this(b: Option[scala.math.BigDecimal]): formats.package.BigDecimalOptionFormatted = {
    BigDecimalOptionFormatted.super.this();
    ()
  };
  def $: String = BigDecimalOptionFormatted.this.b.map[String](((x$1: scala.math.BigDecimal) => package.this.bigDecimalFormatted(x$1).$)).getOrElse[String]("n/a");
  def %(): String = BigDecimalOptionFormatted.this.b.map[java.lang.String](((x$2: scala.math.BigDecimal) => x$2.toString().+("%"))).getOrElse[java.lang.String]("n/a");
  <synthetic> def copy(b: Option[scala.math.BigDecimal] = b): formats.package.BigDecimalOptionFormatted = new package.this.BigDecimalOptionFormatted(b);
  <synthetic> def copy$default$1: Option[scala.math.BigDecimal] @scala.annotation.unchecked.uncheckedVariance = BigDecimalOptionFormatted.this.b;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(BigDecimalOptionFormatted.this);
  override def toString(): String = ScalaRunTime.this._toString(BigDecimalOptionFormatted.this);
  override def equals(x$1: Any): Boolean = BigDecimalOptionFormatted.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (b: Option[scala.math.BigDecimal])formats.package.BigDecimalOptionFormatted((b$2 @ _)) if b$2.==(b) => x$1.asInstanceOf[formats.package.BigDecimalOptionFormatted].canEqual(BigDecimalOptionFormatted.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "BigDecimalOptionFormatted";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => b
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[formats.package.BigDecimalOptionFormatted]()
}
BigDecimalOptionFormatted: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
         $percen       $
       b     X       X  

class NeedRenderable extends java.lang.Object with intform.Renderable with ScalaObject {
  <paramaccessor> private[this] val r: () => scala.xml.NodeSeq = _;
  def this(r: () => scala.xml.NodeSeq): intform.Refreshable.NeedRenderable = {
    NeedRenderable.super.this();
    ()
  };
  def render: scala.xml.NodeSeq = NeedRenderable.this.r.apply()
}
NeedRenderable: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
          render
       r     X  

case class SecDerivative extends Security with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val name: String = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def name: String = SecDerivative.this.name;
  <caseaccessor> <paramaccessor> private[this] val scale: model.Scale = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def scale: model.Scale = SecDerivative.this.scale;
  def this(name: String, scale: model.Scale): model.SecDerivative = {
    SecDerivative.super.this();
    ()
  };
  def *(nextScale: model.Scale): model.SecDerivative = new model.SecDerivative(SecDerivative.this.name, SecDerivative.this.scale.*(nextScale));
  def spotValue: model.Dollars = try {
    schema.readDB[model.Dollars](schema.DerivativeLiability.byName(SecDerivative.this.name).derivative.spotValue.*(SecDerivative.this.scale))
  } catch {
    case schema.NoSuchDerivativeLiability => new model.Dollars(math.this.BigDecimal.int2bigDecimal(0))
  };
  <synthetic> def copy(name: String = name, scale: model.Scale = scale): model.SecDerivative = new model.this.SecDerivative(name, scale);
  <synthetic> def copy$default$2: model.Scale @scala.annotation.unchecked.uncheckedVariance = SecDerivative.this.scale;
  <synthetic> def copy$default$1: String @scala.annotation.unchecked.uncheckedVariance = SecDerivative.this.name;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(SecDerivative.this);
  override def toString(): String = ScalaRunTime.this._toString(SecDerivative.this);
  override def equals(x$1: Any): Boolean = SecDerivative.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (name: String, scale: model.Scale)model.SecDerivative((name$2 @ _), (scale$2 @ _)) if name$2.==(name).&&(scale$2.==(scale)) => x$1.asInstanceOf[model.SecDerivative].canEqual(SecDerivative.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "SecDerivative";
  override def productArity: Int = 2;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => name
    case 1 => scale
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[model.SecDerivative]()
}
SecDerivative: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=0.500
         spotVal  $times
    name     X       X  
   scale     X       X  

class UserPage extends java.lang.Object with intform.Page with net.liftweb.common.Loggable with ScalaObject {
  def this(): code.snippet.UserPage = {
    UserPage.super.this();
    ()
  };
  private[this] val nameParam: net.liftweb.common.Box[String] = net.liftweb.http.S.param("name");
  <stable> <accessor> def nameParam: net.liftweb.common.Box[String] = UserPage.this.nameParam;
  def render: scala.xml.NodeSeq = try {
    model.schema.readDB[scala.xml.NodeSeq]({
      val name: String = UserPage.this.nameParam.openOr[String](throw model.schema.NoSuchUser);
      val user: model.schema.User = model.schema.User.byName(name);
      val curUser: Option[model.schema.User] = try {
        new Some[model.schema.User](control.LoginManager.currentUser)
      } catch {
        case control.LoginManager.NotLoggedIn => scala.None
      };
      if (curUser.map[Boolean](((x$1: model.schema.User) => x$1.~~(user))).getOrElse[Boolean](false))
        xml.this.NodeSeq.seqToNodeSeq(myPage.apply())
      else
        theirPage.apply(user)
    })
  } catch {
    case (e @ (_: errors.package.BadUser)) => {
      {
        new scala.xml.Elem(null, "p", scala.xml.Null, scala.this.Predef.$scope, ({
          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
          $buf.&+(new scala.xml.Text("Sorry, "));
          $buf.&+(formats.`package`.standardMessage(e));
          $buf
        }: _*))
      }
    }
  }
}
UserPage: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
          render

final object BuyServlet extends  {
  def this() = _;
  private <static> val serialVersionUID: Long = _
}
BuyServlet: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

abstract trait DividendDatabase extends scala.AnyRef {
  def recentDividends(stock: stockdata.Stock): Seq[stockdata.Dividend]
}
DividendDatabase: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
 recentD

final object savedPortfolio extends net.liftweb.http.SessionVar[Option[model.package.Key]] with ScalaObject {
  def this(): object code.control.PortfolioSwitcher.savedPortfolio = {
    savedPortfolio.super.this(scala.None);
    ()
  }
}
savedPortfolio: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

abstract trait InnerFieldRender extends java.lang.Object with intform.Renderable with ScalaObject {
  def /*InnerFieldRender*/$init$(): Unit = {
    ()
  };
  def field: intform.Renderable;
  def render: scala.xml.NodeSeq = InnerFieldRender.this.field.render
}
InnerFieldRender: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
          render
   field     X  

final class $anon extends java.lang.Object with scalaz.Pure[Transactions.this.Transaction] {
  def this(): anonymous class $anon = {
    $anon.super.this();
    ()
  };
  def pure[A >: Nothing <: Any](a: => A): Transactions.this.Transaction[A] = Transactions.this.Transaction.apply[A](a)
}
$anon: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
            pure

final object package extends java.lang.Object with ScalaObject {
  def this(): object intform.package = {
    package.super.this();
    ()
  };
  implicit def hlistify1[T1 >: Nothing <: Any, A >: Nothing <: Any](m: T1 => A): up.HList.:+:[T1,up.HNil] => A = ((x0$1: up.HList.:+:[T1,up.HNil]) => x0$1 match {
    case up.HList.$colon$plus$colon.unapply[T1, up.HNil](<unapply-selector>) <unapply> ((t1 @ _), up.HNil) => m.apply(t1)
  });
  implicit def hlistify2[T1 >: Nothing <: Any, T2 >: Nothing <: Any, A >: Nothing <: Any](m: (T1, T2) => A): up.HList.:+:[T1,up.HList.:+:[T2,up.HNil]] => A = ((x0$2: up.HList.:+:[T1,up.HList.:+:[T2,up.HNil]]) => x0$2 match {
    case up.HList.$colon$plus$colon.unapply[T1, up.HList.:+:[T2,up.HNil]](<unapply-selector>) <unapply> ((t1 @ _), up.HList.$colon$plus$colon.unapply[T2, up.HNil](<unapply-selector>) <unapply> ((t2 @ _), up.HNil)) => m.apply(t1, t2)
  });
  implicit def hlistify3[T1 >: Nothing <: Any, T2 >: Nothing <: Any, T3 >: Nothing <: Any, A >: Nothing <: Any](m: (T1, T2, T3) => A): up.HList.:+:[T1,up.HList.:+:[T2,up.HList.:+:[T3,up.HNil]]] => A = ((x0$3: up.HList.:+:[T1,up.HList.:+:[T2,up.HList.:+:[T3,up.HNil]]]) => x0$3 match {
    case up.HList.$colon$plus$colon.unapply[T1, up.HList.:+:[T2,up.HList.:+:[T3,up.HNil]]](<unapply-selector>) <unapply> ((t1 @ _), up.HList.$colon$plus$colon.unapply[T2, up.HList.:+:[T3,up.HNil]](<unapply-selector>) <unapply> ((t2 @ _), up.HList.$colon$plus$colon.unapply[T3, up.HNil](<unapply-selector>) <unapply> ((t3 @ _), up.HNil))) => m.apply(t1, t2, t3)
  });
  implicit def hlistify4[T1 >: Nothing <: Any, T2 >: Nothing <: Any, T3 >: Nothing <: Any, T4 >: Nothing <: Any, A >: Nothing <: Any](m: (T1, T2, T3, T4) => A): up.HList.:+:[T1,up.HList.:+:[T2,up.HList.:+:[T3,up.HList.:+:[T4,up.HNil]]]] => A = ((x0$4: up.HList.:+:[T1,up.HList.:+:[T2,up.HList.:+:[T3,up.HList.:+:[T4,up.HNil]]]]) => x0$4 match {
    case up.HList.$colon$plus$colon.unapply[T1, up.HList.:+:[T2,up.HList.:+:[T3,up.HList.:+:[T4,up.HNil]]]](<unapply-selector>) <unapply> ((t1 @ _), up.HList.$colon$plus$colon.unapply[T2, up.HList.:+:[T3,up.HList.:+:[T4,up.HNil]]](<unapply-selector>) <unapply> ((t2 @ _), up.HList.$colon$plus$colon.unapply[T3, up.HList.:+:[T4,up.HNil]](<unapply-selector>) <unapply> ((t3 @ _), up.HList.$colon$plus$colon.unapply[T4, up.HNil](<unapply-selector>) <unapply> ((t4 @ _), up.HNil)))) => m.apply(t1, t2, t3, t4)
  });
  implicit def hlistify5[T1 >: Nothing <: Any, T2 >: Nothing <: Any, T3 >: Nothing <: Any, T4 >: Nothing <: Any, T5 >: Nothing <: Any, A >: Nothing <: Any](m: (T1, T2, T3, T4, T5) => A): up.HList.:+:[T1,up.HList.:+:[T2,up.HList.:+:[T3,up.HList.:+:[T4,up.HList.:+:[T5,up.HNil]]]]] => A = ((x0$5: up.HList.:+:[T1,up.HList.:+:[T2,up.HList.:+:[T3,up.HList.:+:[T4,up.HList.:+:[T5,up.HNil]]]]]) => x0$5 match {
    case up.HList.$colon$plus$colon.unapply[T1, up.HList.:+:[T2,up.HList.:+:[T3,up.HList.:+:[T4,up.HList.:+:[T5,up.HNil]]]]](<unapply-selector>) <unapply> ((t1 @ _), up.HList.$colon$plus$colon.unapply[T2, up.HList.:+:[T3,up.HList.:+:[T4,up.HList.:+:[T5,up.HNil]]]](<unapply-selector>) <unapply> ((t2 @ _), up.HList.$colon$plus$colon.unapply[T3, up.HList.:+:[T4,up.HList.:+:[T5,up.HNil]]](<unapply-selector>) <unapply> ((t3 @ _), up.HList.$colon$plus$colon.unapply[T4, up.HList.:+:[T5,up.HNil]](<unapply-selector>) <unapply> ((t4 @ _), up.HList.$colon$plus$colon.unapply[T5, up.HNil](<unapply-selector>) <unapply> ((t5 @ _), up.HNil))))) => m.apply(t1, t2, t3, t4, t5)
  });
  implicit def hlistify6[T1 >: Nothing <: Any, T2 >: Nothing <: Any, T3 >: Nothing <: Any, T4 >: Nothing <: Any, T5 >: Nothing <: Any, T6 >: Nothing <: Any, A >: Nothing <: Any](m: (T1, T2, T3, T4, T5, T6) => A): up.HList.:+:[T1,up.HList.:+:[T2,up.HList.:+:[T3,up.HList.:+:[T4,up.HList.:+:[T5,up.HList.:+:[T6,up.HNil]]]]]] => A = ((x0$6: up.HList.:+:[T1,up.HList.:+:[T2,up.HList.:+:[T3,up.HList.:+:[T4,up.HList.:+:[T5,up.HList.:+:[T6,up.HNil]]]]]]) => x0$6 match {
    case up.HList.$colon$plus$colon.unapply[T1, up.HList.:+:[T2,up.HList.:+:[T3,up.HList.:+:[T4,up.HList.:+:[T5,up.HList.:+:[T6,up.HNil]]]]]](<unapply-selector>) <unapply> ((t1 @ _), up.HList.$colon$plus$colon.unapply[T2, up.HList.:+:[T3,up.HList.:+:[T4,up.HList.:+:[T5,up.HList.:+:[T6,up.HNil]]]]](<unapply-selector>) <unapply> ((t2 @ _), up.HList.$colon$plus$colon.unapply[T3, up.HList.:+:[T4,up.HList.:+:[T5,up.HList.:+:[T6,up.HNil]]]](<unapply-selector>) <unapply> ((t3 @ _), up.HList.$colon$plus$colon.unapply[T4, up.HList.:+:[T5,up.HList.:+:[T6,up.HNil]]](<unapply-selector>) <unapply> ((t4 @ _), up.HList.$colon$plus$colon.unapply[T5, up.HList.:+:[T6,up.HNil]](<unapply-selector>) <unapply> ((t5 @ _), up.HList.$colon$plus$colon.unapply[T6, up.HNil](<unapply-selector>) <unapply> ((t6 @ _), up.HNil)))))) => m.apply(t1, t2, t3, t4, t5, t6)
  });
  implicit def hlistify7[T1 >: Nothing <: Any, T2 >: Nothing <: Any, T3 >: Nothing <: Any, T4 >: Nothing <: Any, T5 >: Nothing <: Any, T6 >: Nothing <: Any, T7 >: Nothing <: Any, A >: Nothing <: Any](m: (T1, T2, T3, T4, T5, T6, T7) => A): up.HList.:+:[T1,up.HList.:+:[T2,up.HList.:+:[T3,up.HList.:+:[T4,up.HList.:+:[T5,up.HList.:+:[T6,up.HList.:+:[T7,up.HNil]]]]]]] => A = ((x0$7: up.HList.:+:[T1,up.HList.:+:[T2,up.HList.:+:[T3,up.HList.:+:[T4,up.HList.:+:[T5,up.HList.:+:[T6,up.HList.:+:[T7,up.HNil]]]]]]]) => x0$7 match {
    case up.HList.$colon$plus$colon.unapply[T1, up.HList.:+:[T2,up.HList.:+:[T3,up.HList.:+:[T4,up.HList.:+:[T5,up.HList.:+:[T6,up.HList.:+:[T7,up.HNil]]]]]]](<unapply-selector>) <unapply> ((t1 @ _), up.HList.$colon$plus$colon.unapply[T2, up.HList.:+:[T3,up.HList.:+:[T4,up.HList.:+:[T5,up.HList.:+:[T6,up.HList.:+:[T7,up.HNil]]]]]](<unapply-selector>) <unapply> ((t2 @ _), up.HList.$colon$plus$colon.unapply[T3, up.HList.:+:[T4,up.HList.:+:[T5,up.HList.:+:[T6,up.HList.:+:[T7,up.HNil]]]]](<unapply-selector>) <unapply> ((t3 @ _), up.HList.$colon$plus$colon.unapply[T4, up.HList.:+:[T5,up.HList.:+:[T6,up.HList.:+:[T7,up.HNil]]]](<unapply-selector>) <unapply> ((t4 @ _), up.HList.$colon$plus$colon.unapply[T5, up.HList.:+:[T6,up.HList.:+:[T7,up.HNil]]](<unapply-selector>) <unapply> ((t5 @ _), up.HList.$colon$plus$colon.unapply[T6, up.HList.:+:[T7,up.HNil]](<unapply-selector>) <unapply> ((t6 @ _), up.HList.$colon$plus$colon.unapply[T7, up.HNil](<unapply-selector>) <unapply> ((t7 @ _), up.HNil))))))) => m.apply(t1, t2, t3, t4, t5, t6, t7)
  });
  implicit def hlistify8[T1 >: Nothing <: Any, T2 >: Nothing <: Any, T3 >: Nothing <: Any, T4 >: Nothing <: Any, T5 >: Nothing <: Any, T6 >: Nothing <: Any, T7 >: Nothing <: Any, T8 >: Nothing <: Any, A >: Nothing <: Any](m: (T1, T2, T3, T4, T5, T6, T7, T8) => A): up.HList.:+:[T1,up.HList.:+:[T2,up.HList.:+:[T3,up.HList.:+:[T4,up.HList.:+:[T5,up.HList.:+:[T6,up.HList.:+:[T7,up.HList.:+:[T8,up.HNil]]]]]]]] => A = ((x0$8: up.HList.:+:[T1,up.HList.:+:[T2,up.HList.:+:[T3,up.HList.:+:[T4,up.HList.:+:[T5,up.HList.:+:[T6,up.HList.:+:[T7,up.HList.:+:[T8,up.HNil]]]]]]]]) => x0$8 match {
    case up.HList.$colon$plus$colon.unapply[T1, up.HList.:+:[T2,up.HList.:+:[T3,up.HList.:+:[T4,up.HList.:+:[T5,up.HList.:+:[T6,up.HList.:+:[T7,up.HList.:+:[T8,up.HNil]]]]]]]](<unapply-selector>) <unapply> ((t1 @ _), up.HList.$colon$plus$colon.unapply[T2, up.HList.:+:[T3,up.HList.:+:[T4,up.HList.:+:[T5,up.HList.:+:[T6,up.HList.:+:[T7,up.HList.:+:[T8,up.HNil]]]]]]](<unapply-selector>) <unapply> ((t2 @ _), up.HList.$colon$plus$colon.unapply[T3, up.HList.:+:[T4,up.HList.:+:[T5,up.HList.:+:[T6,up.HList.:+:[T7,up.HList.:+:[T8,up.HNil]]]]]](<unapply-selector>) <unapply> ((t3 @ _), up.HList.$colon$plus$colon.unapply[T4, up.HList.:+:[T5,up.HList.:+:[T6,up.HList.:+:[T7,up.HList.:+:[T8,up.HNil]]]]](<unapply-selector>) <unapply> ((t4 @ _), up.HList.$colon$plus$colon.unapply[T5, up.HList.:+:[T6,up.HList.:+:[T7,up.HList.:+:[T8,up.HNil]]]](<unapply-selector>) <unapply> ((t5 @ _), up.HList.$colon$plus$colon.unapply[T6, up.HList.:+:[T7,up.HList.:+:[T8,up.HNil]]](<unapply-selector>) <unapply> ((t6 @ _), up.HList.$colon$plus$colon.unapply[T7, up.HList.:+:[T8,up.HNil]](<unapply-selector>) <unapply> ((t7 @ _), up.HList.$colon$plus$colon.unapply[T8, up.HNil](<unapply-selector>) <unapply> ((t8 @ _), up.HNil)))))))) => m.apply(t1, t2, t3, t4, t5, t6, t7, t8)
  });
  implicit def tuplist1[A >: Nothing <: Any](a: A): Seq[A] = collection.this.Seq.apply[A](a);
  implicit def tuplist2[A >: Nothing <: Any](a: (A, A)): Seq[A] = collection.this.Seq.apply[A](a._1, a._2);
  implicit def tuplist3[A >: Nothing <: Any](a: (A, A, A)): Seq[A] = collection.this.Seq.apply[A](a._1, a._2, a._3);
  implicit def tuplist4[A >: Nothing <: Any](a: (A, A, A, A)): Seq[A] = collection.this.Seq.apply[A](a._1, a._2, a._3, a._4);
  implicit def tuplist5[A >: Nothing <: Any](a: (A, A, A, A, A)): Seq[A] = collection.this.Seq.apply[A](a._1, a._2, a._3, a._4);
  implicit def klist1[K[_ >: Nothing <: Any] >: [+_]Nothing <: [+_]Any, A >: Nothing <: Any](a: K[A]): up.KList[K,up.HList.:+:[A,up.HNil]] = {
    <synthetic> val x$1: K[A] = a;
    up.KNil.:^:[K, A](x$1)
  };
  implicit def klist2[K[_ >: Nothing <: Any] >: [+_]Nothing <: [+_]Any, A >: Nothing <: Any, B >: Nothing <: Any](t: (K[A], K[B])): up.KList[K,up.HList.:+:[A,up.HList.:+:[B,up.HNil]]] = {
    <synthetic> val x$3: K[A] = t._1;
    {
  <synthetic> val x$2: K[B] = t._2;
  up.KNil.:^:[K, B](x$2)
}.:^:[[+X]K[X], A](x$3)
  };
  implicit def klist3[K[_ >: Nothing <: Any] >: [+_]Nothing <: [+_]Any, A >: Nothing <: Any, B >: Nothing <: Any, C >: Nothing <: Any](t: (K[A], K[B], K[C])): up.KList[K,up.HList.:+:[A,up.HList.:+:[B,up.HList.:+:[C,up.HNil]]]] = {
    <synthetic> val x$6: K[A] = t._1;
    {
  <synthetic> val x$5: K[B] = t._2;
  {
  <synthetic> val x$4: K[C] = t._3;
  up.KNil.:^:[K, C](x$4)
}.:^:[[+X]K[X], B](x$5)
}.:^:[[+X]K[X], A](x$6)
  };
  implicit def klist4[K[_ >: Nothing <: Any] >: [+_]Nothing <: [+_]Any, A >: Nothing <: Any, B >: Nothing <: Any, C >: Nothing <: Any, D >: Nothing <: Any](t: (K[A], K[B], K[C], K[D])): up.KList[K,up.HList.:+:[A,up.HList.:+:[B,up.HList.:+:[C,up.HList.:+:[D,up.HNil]]]]] = {
    <synthetic> val x$10: K[A] = t._1;
    {
  <synthetic> val x$9: K[B] = t._2;
  {
  <synthetic> val x$8: K[C] = t._3;
  {
  <synthetic> val x$7: K[D] = t._4;
  up.KNil.:^:[K, D](x$7)
}.:^:[[+X]K[X], C](x$8)
}.:^:[[+X]K[X], B](x$9)
}.:^:[[+X]K[X], A](x$10)
  };
  implicit def klist5[K[_ >: Nothing <: Any] >: [+_]Nothing <: [+_]Any, A >: Nothing <: Any, B >: Nothing <: Any, C >: Nothing <: Any, D >: Nothing <: Any, E >: Nothing <: Any](t: (K[A], K[B], K[C], K[D], K[E])): up.KList[K,up.HList.:+:[A,up.HList.:+:[B,up.HList.:+:[C,up.HList.:+:[D,up.HList.:+:[E,up.HNil]]]]]] = {
    <synthetic> val x$15: K[A] = t._1;
    {
  <synthetic> val x$14: K[B] = t._2;
  {
  <synthetic> val x$13: K[C] = t._3;
  {
  <synthetic> val x$12: K[D] = t._4;
  {
  <synthetic> val x$11: K[E] = t._5;
  up.KNil.:^:[K, E](x$11)
}.:^:[[+X]K[X], D](x$12)
}.:^:[[+X]K[X], C](x$13)
}.:^:[[+X]K[X], B](x$14)
}.:^:[[+X]K[X], A](x$15)
  };
  implicit def klist6[K[_ >: Nothing <: Any] >: [+_]Nothing <: [+_]Any, A >: Nothing <: Any, B >: Nothing <: Any, C >: Nothing <: Any, D >: Nothing <: Any, E >: Nothing <: Any, F >: Nothing <: Any](t: (K[A], K[B], K[C], K[D], K[E], K[F])): up.KList[K,up.HList.:+:[A,up.HList.:+:[B,up.HList.:+:[C,up.HList.:+:[D,up.HList.:+:[E,up.HList.:+:[F,up.HNil]]]]]]] = {
    <synthetic> val x$21: K[A] = t._1;
    {
  <synthetic> val x$20: K[B] = t._2;
  {
  <synthetic> val x$19: K[C] = t._3;
  {
  <synthetic> val x$18: K[D] = t._4;
  {
  <synthetic> val x$17: K[E] = t._5;
  {
  <synthetic> val x$16: K[F] = t._6;
  up.KNil.:^:[K, F](x$16)
}.:^:[[+X]K[X], E](x$17)
}.:^:[[+X]K[X], D](x$18)
}.:^:[[+X]K[X], C](x$19)
}.:^:[[+X]K[X], B](x$20)
}.:^:[[+X]K[X], A](x$21)
  };
  implicit def klist7[K[_ >: Nothing <: Any] >: [+_]Nothing <: [+_]Any, A >: Nothing <: Any, B >: Nothing <: Any, C >: Nothing <: Any, D >: Nothing <: Any, E >: Nothing <: Any, F >: Nothing <: Any, G >: Nothing <: Any](t: (K[A], K[B], K[C], K[D], K[E], K[F], K[G])): up.KList[K,up.HList.:+:[A,up.HList.:+:[B,up.HList.:+:[C,up.HList.:+:[D,up.HList.:+:[E,up.HList.:+:[F,up.HList.:+:[G,up.HNil]]]]]]]] = {
    <synthetic> val x$28: K[A] = t._1;
    {
  <synthetic> val x$27: K[B] = t._2;
  {
  <synthetic> val x$26: K[C] = t._3;
  {
  <synthetic> val x$25: K[D] = t._4;
  {
  <synthetic> val x$24: K[E] = t._5;
  {
  <synthetic> val x$23: K[F] = t._6;
  {
  <synthetic> val x$22: K[G] = t._7;
  up.KNil.:^:[K, G](x$22)
}.:^:[[+X]K[X], F](x$23)
}.:^:[[+X]K[X], E](x$24)
}.:^:[[+X]K[X], D](x$25)
}.:^:[[+X]K[X], C](x$26)
}.:^:[[+X]K[X], B](x$27)
}.:^:[[+X]K[X], A](x$28)
  };
  implicit def klist8[K[_ >: Nothing <: Any] >: [+_]Nothing <: [+_]Any, A >: Nothing <: Any, B >: Nothing <: Any, C >: Nothing <: Any, D >: Nothing <: Any, E >: Nothing <: Any, F >: Nothing <: Any, G >: Nothing <: Any, H >: Nothing <: Any](t: (K[A], K[B], K[C], K[D], K[E], K[F], K[G], K[H])): up.KList[K,up.HList.:+:[A,up.HList.:+:[B,up.HList.:+:[C,up.HList.:+:[D,up.HList.:+:[E,up.HList.:+:[F,up.HList.:+:[G,up.HList.:+:[H,up.HNil]]]]]]]]] = {
    <synthetic> val x$36: K[A] = t._1;
    {
  <synthetic> val x$35: K[B] = t._2;
  {
  <synthetic> val x$34: K[C] = t._3;
  {
  <synthetic> val x$33: K[D] = t._4;
  {
  <synthetic> val x$32: K[E] = t._5;
  {
  <synthetic> val x$31: K[F] = t._6;
  {
  <synthetic> val x$30: K[G] = t._7;
  {
  <synthetic> val x$29: K[H] = t._8;
  up.KNil.:^:[K, H](x$29)
}.:^:[[+X]K[X], G](x$30)
}.:^:[[+X]K[X], F](x$31)
}.:^:[[+X]K[X], E](x$32)
}.:^:[[+X]K[X], D](x$33)
}.:^:[[+X]K[X], C](x$34)
}.:^:[[+X]K[X], B](x$35)
}.:^:[[+X]K[X], A](x$36)
  };
  implicit def nodeSeqPlus(n: Seq[scala.xml.Node]): intform.package.NodeSeqPlus = new intform.package.NodeSeqPlus(xml.this.NodeSeq.seqToNodeSeq(n));
  implicit def nodeSeqPlus(n: scala.xml.NodeSeq): intform.package.NodeSeqPlus = new intform.package.NodeSeqPlus(n);
  implicit def nodePlus(n: scala.xml.Node): intform.package.NodePlus = new intform.package.NodePlus(n);
  case class NodeSeqPlus extends java.lang.Object with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val n: scala.xml.NodeSeq = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def n: scala.xml.NodeSeq = NodeSeqPlus.this.n;
    def this(n: scala.xml.NodeSeq): intform.package.NodeSeqPlus = {
      NodeSeqPlus.super.this();
      ()
    };
    def leafMap(f: scala.xml.Elem => scala.xml.Elem): scala.xml.NodeSeq = NodeSeqPlus.this.n.map[scala.xml.Node, scala.xml.NodeSeq](((x$37: scala.xml.Node) => package.this.nodePlus(x$37).leafMap(f)))(xml.this.NodeSeq.canBuildFrom);
    <synthetic> def copy(n: scala.xml.NodeSeq = n): intform.package.NodeSeqPlus = new package.this.NodeSeqPlus(n);
    <synthetic> def copy$default$1: scala.xml.NodeSeq @scala.annotation.unchecked.uncheckedVariance = NodeSeqPlus.this.n;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(NodeSeqPlus.this);
    override def toString(): String = ScalaRunTime.this._toString(NodeSeqPlus.this);
    override def equals(x$1: Any): Boolean = NodeSeqPlus.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (n: scala.xml.NodeSeq)intform.package.NodeSeqPlus((n$1 @ _)) if n$1.==(n) => x$1.asInstanceOf[intform.package.NodeSeqPlus].canEqual(NodeSeqPlus.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "NodeSeqPlus";
    override def productArity: Int = 1;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => n
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[intform.package.NodeSeqPlus]()
  };
  final <synthetic> object NodeSeqPlus extends scala.runtime.AbstractFunction1[scala.xml.NodeSeq,intform.package.NodeSeqPlus] with ScalaObject with Serializable {
    def this(): object intform.package.NodeSeqPlus = {
      NodeSeqPlus.super.this();
      ()
    };
    final override def toString(): java.lang.String = "NodeSeqPlus";
    case <synthetic> def unapply(x$0: intform.package.NodeSeqPlus): Option[scala.xml.NodeSeq] = if (x$0.==(null))
      scala.this.None
    else
      new Some[scala.xml.NodeSeq](x$0.n);
    case <synthetic> def apply(n: scala.xml.NodeSeq): intform.package.NodeSeqPlus = new package.this.NodeSeqPlus(n);
    protected def readResolve(): java.lang.Object = package.this.NodeSeqPlus
  };
  case class NodePlus extends java.lang.Object with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val n: scala.xml.Node = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def n: scala.xml.Node = NodePlus.this.n;
    def this(n: scala.xml.Node): intform.package.NodePlus = {
      NodePlus.super.this();
      ()
    };
    def leafMap(f: scala.xml.Elem => scala.xml.Elem): scala.xml.Node = NodePlus.this.n match {
      case (e @ (_: scala.xml.Elem)) => f.apply(scala.xml.Elem.apply(e.prefix, e.label, e.attributes, e.scope, (package.this.nodeSeqPlus(e.child).leafMap(f): _*)))
      case (x @ _) => x
    };
    <synthetic> def copy(n: scala.xml.Node = n): intform.package.NodePlus = new package.this.NodePlus(n);
    <synthetic> def copy$default$1: scala.xml.Node @scala.annotation.unchecked.uncheckedVariance = NodePlus.this.n;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(NodePlus.this);
    override def toString(): String = ScalaRunTime.this._toString(NodePlus.this);
    override def equals(x$1: Any): Boolean = NodePlus.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (n: scala.xml.Node)intform.package.NodePlus((n$2 @ _)) if n$2.==(n) => x$1.asInstanceOf[intform.package.NodePlus].canEqual(NodePlus.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "NodePlus";
    override def productArity: Int = 1;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => n
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[intform.package.NodePlus]()
  };
  final <synthetic> object NodePlus extends scala.runtime.AbstractFunction1[scala.xml.Node,intform.package.NodePlus] with ScalaObject with Serializable {
    def this(): object intform.package.NodePlus = {
      NodePlus.super.this();
      ()
    };
    final override def toString(): java.lang.String = "NodePlus";
    case <synthetic> def unapply(x$0: intform.package.NodePlus): Option[scala.xml.Node] = if (x$0.==(null))
      scala.this.None
    else
      new Some[scala.xml.Node](x$0.n);
    case <synthetic> def apply(n: scala.xml.Node): intform.package.NodePlus = new package.this.NodePlus(n);
    protected def readResolve(): java.lang.Object = package.this.NodePlus
  };
  class MergeAttr extends java.lang.Object with ScalaObject {
    <paramaccessor> private[this] val n1: scala.xml.NodeSeq = _;
    def this(n1: scala.xml.NodeSeq): intform.package.MergeAttr = {
      MergeAttr.super.this();
      ()
    };
    def &(n2: scala.xml.Node): scala.xml.NodeSeq = package.this.nodeSeqPlus(MergeAttr.this.n1).leafMap(((e: scala.xml.Elem) => if (e.label.==(n2.label))
      e.%(n2.head.attributes)
    else
      e))
  };
  implicit def mergeAttr(n1: scala.xml.NodeSeq): intform.package.MergeAttr = new package.this.MergeAttr(n1)
}
package: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.042
         hlistif hlistif hlistif tuplist nodePlu hlistif  klist2 tuplist  klist7 tuplist nodeSeq  klist8 tuplist  klist1  klist6 hlistif hlistif mergeAt  klist5  klist4 tuplist hlistif nodeSeq  klist3 hlistif

final case object OpenAuction extends Recipient with ScalaObject with Product with Serializable {
  def this(): object code.snippet.OpenAuction = {
    OpenAuction.super.this();
    ()
  };
  final override def hashCode(): Int = 809185401;
  final override def toString(): java.lang.String = "OpenAuction";
  override def productPrefix: java.lang.String = "OpenAuction";
  override def productArity: Int = 0;
  override def productElement(x$1: Int): Any = x$1 match {
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[object code.snippet.OpenAuction]();
  protected def readResolve(): java.lang.Object = snippet.this.OpenAuction
}
OpenAuction: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
         readRes

abstract trait Links extends java.lang.Object with ScalaObject {
  def /*Links*/$init$(): Unit = {
    ()
  };
  final case object NotFound extends scala.`package`.RuntimeException with ScalaObject with Product with Serializable {
    def this(): object Links.this.NotFound = {
      NotFound.super.this();
      ()
    };
    final override def hashCode(): Int = 1617964175;
    override def productPrefix: java.lang.String = "NotFound";
    override def productArity: Int = 0;
    override def productElement(x$1: Int): Any = x$1 match {
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[object Links.this.NotFound]()
  };
  @volatile <synthetic> private[this] var NotFound$module: object Links.this.NotFound = _;
  final case <stable> def NotFound: object Links.this.NotFound = new object Links.this.NotFound();
  implicit def idToLink[R >: Nothing <: model.KL](id: model.package.Key): model.Link[R] = new model.Link[R](id)
}
Links: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.500
         NotFoun idToLin
 NotFoun                

abstract trait RankingSchema extends java.lang.Object with ScalaObject { self: model.RankingSchema with model.DBMagic with model.UserSchema => 
  def /*RankingSchema*/$init$(): Unit = {
    ()
  };
  def systemRecalculateRankings(): List[Unit] = RankingSchema.this.editDB[List[Unit]](RankingSchema.this.recalculateRankings);
  def recalculateRankings: RankingSchema.this.Transaction[List[Unit]] = {
    val ports: List[RankingSchema.this.Portfolio] = RankingSchema.this.portfolios.toList.sortBy[model.Dollars](((x$1: RankingSchema.this.Portfolio) => x$1.spotValue.unary_-))(math.this.Ordering.ordered[model.Dollars](scala.this.Predef.conforms[model.Dollars]));
    val ranks: List[Int] = immutable.this.List.range[Int](1, ports.length.+(1))(math.this.Numeric.IntIsIntegral);
    val updates: List[RankingSchema.this.Transaction[Unit]] = ports.zip[RankingSchema.this.Portfolio, Int, List[(RankingSchema.this.Portfolio, Int)]](ranks)(immutable.this.List.canBuildFrom[(RankingSchema.this.Portfolio, Int)]).map[RankingSchema.this.Transaction[Unit], List[RankingSchema.this.Transaction[Unit]]](((x0$1: (RankingSchema.this.Portfolio, Int)) => x0$1 match {
      case (_1: RankingSchema.this.Portfolio, _2: Int)(RankingSchema.this.Portfolio, Int)((port @ _), (rank @ _)) => RankingSchema.this.toOps[RankingSchema.this.Portfolio](port).update(((p: RankingSchema.this.Portfolio) => {
        val x$2: Int = rank;
        val x$3: model.package.Key = p.copy$default$1;
        val x$4: model.Link[RankingSchema.this.League] = p.copy$default$2;
        val x$5: String = p.copy$default$3;
        val x$6: model.Dollars = p.copy$default$4;
        val x$7: model.Dollars = p.copy$default$5;
        p.copy(x$3, x$4, x$5, x$6, x$7, x$2)
      }))(RankingSchema.this.portfolios)
    }))(immutable.this.List.canBuildFrom[RankingSchema.this.Transaction[Unit]]);
    scalaz.Scalaz.SeqMA[List, RankingSchema.this.Transaction[Unit]](updates).sequence[RankingSchema.this.Transaction, Unit](scala.this.Predef.conforms[RankingSchema.this.Transaction[Unit]], scalaz.this.Traverse.TraversableTraverse[List](scalaz.this.CanBuildAnySelf.GenericCanBuildSelf[List](immutable.this.List.canBuildFrom[Nothing])), scalaz.this.Applicative.applicative[RankingSchema.this.Transaction](RankingSchema.this.TransactionPure, scalaz.this.Apply.FunctorBindApply[RankingSchema.this.Transaction](RankingSchema.this.TransactionFunctor, RankingSchema.this.TransactionBind)))
  }
}
RankingSchema: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=1.000
         systemR recalcu

class PortfolioInvites extends java.lang.Object with intform.Page with net.liftweb.common.Loggable with ScalaObject {
  def this(): code.snippet.PortfolioInvites = {
    PortfolioInvites.super.this();
    ()
  };
  def render: scala.xml.NodeSeq = PortfolioInvites.this.refreshable.render;
  private[this] val refreshable: intform.Refreshable.NeedRenderable with intform.Refreshable = intform.Refreshable.apply(PortfolioInvites.this.doRender);
  <stable> <accessor> def refreshable: intform.Refreshable.NeedRenderable with intform.Refreshable = PortfolioInvites.this.refreshable;
  def doRender: scala.xml.NodeSeq = {
    try {
      val user: model.schema.User = control.LoginManager.currentUser;
      val invites: List[model.schema.PortfolioInvite] = user.myPortfolioInvites;
      invites match {
        case immutable.this.Nil => (xml.this.NodeSeq.seqToNodeSeq(immutable.this.Nil): scala.xml.NodeSeq)
        case (invites @ _) => PortfolioInvites.this.formatInvites(user, invites)
      }
    } catch {
      case control.LoginManager.NotLoggedIn => (xml.this.NodeSeq.seqToNodeSeq(immutable.this.Nil): scala.xml.NodeSeq)
    }
  };
  def formatInvites(user: model.schema.User, invites: Seq[model.schema.PortfolioInvite]): scala.xml.Elem = {
    val list: Seq[scala.xml.Elem] = invites.map[scala.xml.Elem, Seq[scala.xml.Elem]](((invite: model.schema.PortfolioInvite) => {
      val accept: scala.xml.NodeSeq = intform.FormSubmit.rendered("Accept")({
        user.userAcceptInvite(invite);
        PortfolioInvites.this.refreshable.refresh()
      });
      val decline: scala.xml.NodeSeq = intform.FormSubmit.rendered("Decline")({
        user.userDeclineInvite(invite);
        PortfolioInvites.this.refreshable.refresh()
      });
      {
        {
          new scala.xml.Elem(null, "li", scala.xml.Null, scala.this.Predef.$scope, ({
            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
            $buf.&+(PortfolioLink.apply(invite.from));
            $buf.&+(new scala.xml.Text(" is asking you to join their team!\012                "));
            $buf.&+({
              {
                var $md: scala.xml.MetaData = scala.xml.Null;
                $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("button"), $md);
                new scala.xml.Elem(null, "span", $md, scala.this.Predef.$scope, ({
                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                  $buf.&+(accept);
                  $buf
                }: _*))
              }
            });
            $buf.&+(new scala.xml.Text(" "));
            $buf.&+({
              {
                var $md: scala.xml.MetaData = scala.xml.Null;
                $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("button"), $md);
                new scala.xml.Elem(null, "span", $md, scala.this.Predef.$scope, ({
                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                  $buf.&+(decline);
                  $buf
                }: _*))
              }
            });
            $buf.&+(new scala.xml.Text("\012            "));
            $buf
          }: _*))
        }
      }
    }))(collection.this.Seq.canBuildFrom[scala.xml.Elem]);
    {
      {
        var $md: scala.xml.MetaData = scala.xml.Null;
        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("block"), $md);
        new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
          $buf.&+(new scala.xml.Text("\012            "));
          $buf.&+({
            {
              new scala.xml.Elem(null, "ul", scala.xml.Null, scala.this.Predef.$scope, ({
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+(list);
                $buf
              }: _*))
            }
          });
          $buf.&+(new scala.xml.Text("\012        "));
          $buf
        }: _*))
      }
    }
  }
}
PortfolioInvites: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.333
          render formatI doRende

final object CaseField extends java.lang.Object with ScalaObject {
  def this(): object intform.CaseField = {
    CaseField.super.this();
    ()
  };
  def apply[A >: Nothing <: Any](c: Seq[intform.Field[A]], r: intform.CaseChoices => scala.xml.NodeSeq): intform.CaseField[A] = new intform.CaseField[A](c, r)
}
CaseField: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
           apply

final object tChart extends java.lang.Object with net.liftweb.common.Loggable with ScalaObject {
  def this(): object code.snippet.tChart = {
    tChart.super.this();
    ()
  };
  def apply(port: model.schema.Portfolio, currentUser: Option[model.schema.User], modifiable: Boolean): scala.xml.NodeSeq = {
    var showHidden: Boolean = false;
    lazy var refreshable$lzy: intform.Refreshable.NeedRenderable with intform.Refreshable = _;
    <stable> <accessor> lazy def refreshable: intform.Refreshable.NeedRenderable with intform.Refreshable = {
      refreshable$lzy = intform.Refreshable.apply(doRender);
      refreshable$lzy
    };
    def render: scala.xml.NodeSeq = refreshable.render;
    def doRender: scala.xml.NodeSeq = {
      val myStockAssets: Seq[model.schema.GroupedStockAsset] = port.myStockAssetsGrouped;
      val myCashAmount: model.Dollars = port.cash;
      val myDerivativeAssets: List[model.schema.DerivativeAsset] = port.myDerivativeAssets;
      val myDerivativeLiabilities: List[model.schema.DerivativeLiability] = port.myDerivativeLiabilities;
      lazy var result$lzy: scala.xml.Elem = _;
      <stable> <accessor> lazy def result: scala.xml.Elem = {
        result$lzy = {
          {
            var $md: scala.xml.MetaData = scala.xml.Null;
            $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("block"), $md);
            new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
              val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
              $buf.&+(new scala.xml.Text("\012            "));
              $buf.&+({
                {
                  new scala.xml.Elem(null, "h2", scala.xml.Null, scala.this.Predef.$scope, ({
                    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                    $buf.&+(new scala.xml.Text("Portfolio "));
                    $buf.&+(sharing);
                    $buf
                  }: _*))
                }
              });
              $buf.&+(new scala.xml.Text("\012            "));
              $buf.&+(table);
              $buf.&+(new scala.xml.Text("\012            "));
              $buf.&+(hiddenControls);
              $buf.&+(new scala.xml.Text("\012        "));
              $buf
            }: _*))
          }
        };
        result$lzy
      };
      lazy var sharing$lzy: scala.collection.immutable.Seq[scala.xml.Node] with Serializable = _;
      <stable> <accessor> lazy def sharing: scala.collection.immutable.Seq[scala.xml.Node] with Serializable = {
        sharing$lzy = currentUser.map[scala.collection.immutable.Seq[scala.xml.Node] with Serializable](((currentUser: model.schema.User) => {
  val others: List[model.schema.User] = port.owners.filter(((o: model.schema.User) => o.~~(currentUser).unary_!));
  this.logger.info("Shared with ".+(others));
  if (others.length.==(0))
    immutable.this.Nil
  else
    {
      val links: List[scala.xml.NodeSeq] = others.map[scala.xml.NodeSeq, List[scala.xml.NodeSeq]](((x$1: model.schema.User) => snippet.UserLink.apply(x$1)))(immutable.this.List.canBuildFrom[scala.xml.NodeSeq]);
      val list: scala.xml.NodeSeq = links.reduceLeft[scala.xml.NodeSeq](((a: scala.xml.NodeSeq, b: scala.xml.NodeSeq) => a.++[scala.xml.Node, scala.xml.NodeSeq]({
  {
    new scala.xml.Elem(null, "span", scala.xml.Null, scala.this.Predef.$scope, ({
      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
      $buf.&+(new scala.xml.Text(", "));
      $buf
    }: _*))
  }
})(xml.this.NodeSeq.canBuildFrom).++[scala.xml.Node, scala.xml.NodeSeq](b)(xml.this.NodeSeq.canBuildFrom)));
      {
        {
          var $md: scala.xml.MetaData = scala.xml.Null;
          $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("sharing"), $md);
          new scala.xml.Elem(null, "span", $md, scala.this.Predef.$scope, ({
            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
            $buf.&+(new scala.xml.Text("(Shared with "));
            $buf.&+(list);
            $buf.&+(new scala.xml.Text(")"));
            $buf
          }: _*))
        }
      }
    }
})).getOrElse[scala.collection.immutable.Seq[scala.xml.Node] with Serializable]({
          {
            new scala.xml.Elem(null, "span", scala.xml.Null, scala.this.Predef.$scope)
          }
        });
        sharing$lzy
      };
      lazy var table$lzy: scala.xml.Elem = _;
      <stable> <accessor> lazy def table: scala.xml.Elem = {
        table$lzy = {
          {
            var $md: scala.xml.MetaData = scala.xml.Null;
            $md = new scala.xml.UnprefixedAttribute("id", new scala.xml.Text("portfolio"), $md);
            $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("block container portfolio"), $md);
            new scala.xml.Elem(null, "table", $md, scala.this.Predef.$scope, ({
              val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
              $buf.&+(new scala.xml.Text("\012            "));
              $buf.&+({
                {
                  var $md: scala.xml.MetaData = scala.xml.Null;
                  $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("tchart-left1"), $md);
                  new scala.xml.Elem(null, "col", $md, scala.this.Predef.$scope)
                }
              });
              $buf.&+(new scala.xml.Text("\012            "));
              $buf.&+({
                {
                  var $md: scala.xml.MetaData = scala.xml.Null;
                  $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("tchart-left2"), $md);
                  new scala.xml.Elem(null, "col", $md, scala.this.Predef.$scope)
                }
              });
              $buf.&+(new scala.xml.Text("\012            "));
              $buf.&+({
                {
                  var $md: scala.xml.MetaData = scala.xml.Null;
                  $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("tchart-right1"), $md);
                  new scala.xml.Elem(null, "col", $md, scala.this.Predef.$scope)
                }
              });
              $buf.&+(new scala.xml.Text("\012            "));
              $buf.&+({
                {
                  var $md: scala.xml.MetaData = scala.xml.Null;
                  $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("tchart-right2"), $md);
                  new scala.xml.Elem(null, "col", $md, scala.this.Predef.$scope)
                }
              });
              $buf.&+(new scala.xml.Text("\012            "));
              $buf.&+({
                {
                  var $md: scala.xml.MetaData = scala.xml.Null;
                  $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("tchart-top"), $md);
                  new scala.xml.Elem(null, "tr", $md, scala.this.Predef.$scope, ({
                    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                    $buf.&+(new scala.xml.Text("\012                "));
                    $buf.&+({
                      {
                        var $md: scala.xml.MetaData = scala.xml.Null;
                        $md = new scala.xml.UnprefixedAttribute("colspan", new scala.xml.Text("2"), $md);
                        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("tchart-top"), $md);
                        new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(new scala.xml.Text("Assets"));
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012                "));
                    $buf.&+({
                      {
                        var $md: scala.xml.MetaData = scala.xml.Null;
                        $md = new scala.xml.UnprefixedAttribute("colspan", new scala.xml.Text("2"), $md);
                        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("tchart-top"), $md);
                        new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(new scala.xml.Text("Liabilities"));
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012            "));
                    $buf
                  }: _*))
                }
              });
              $buf.&+(new scala.xml.Text("\012            "));
              $buf.&+({
                {
                  new scala.xml.Elem(null, "tr", scala.xml.Null, scala.this.Predef.$scope, ({
                    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                    $buf.&+(new scala.xml.Text("\012                "));
                    $buf.&+({
                      {
                        var $md: scala.xml.MetaData = scala.xml.Null;
                        $md = new scala.xml.UnprefixedAttribute("colspan", new scala.xml.Text("2"), $md);
                        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("tchart-half"), $md);
                        new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(assetsTable);
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012                "));
                    $buf.&+({
                      {
                        var $md: scala.xml.MetaData = scala.xml.Null;
                        $md = new scala.xml.UnprefixedAttribute("colspan", new scala.xml.Text("2"), $md);
                        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("tchart-half"), $md);
                        new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(liabilitiesTable);
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012            "));
                    $buf
                  }: _*))
                }
              });
              $buf.&+(new scala.xml.Text("\012            "));
              $buf.&+({
                {
                  var $md: scala.xml.MetaData = scala.xml.Null;
                  $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("tchart-section tchart-total tchart"), $md);
                  new scala.xml.Elem(null, "tr", $md, scala.this.Predef.$scope, ({
                    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                    $buf.&+(new scala.xml.Text("\012                "));
                    $buf.&+({
                      {
                        new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(new scala.xml.Text("Total:"));
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012                "));
                    $buf.&+({
                      {
                        var $md: scala.xml.MetaData = scala.xml.Null;
                        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("tchart-dollars"), $md);
                        new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(total.$);
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012                "));
                    $buf.&+({
                      {
                        new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(new scala.xml.Text("Total:"));
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012                "));
                    $buf.&+({
                      {
                        var $md: scala.xml.MetaData = scala.xml.Null;
                        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("tchart-dollars"), $md);
                        new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(liabilitiesTotal.$);
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012            "));
                    $buf
                  }: _*))
                }
              });
              $buf.&+(new scala.xml.Text("\012            "));
              $buf.&+({
                {
                  var $md: scala.xml.MetaData = scala.xml.Null;
                  $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("tchart"), $md);
                  new scala.xml.Elem(null, "tr", $md, scala.this.Predef.$scope, ({
                    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                    $buf.&+(new scala.xml.Text("\012                "));
                    $buf.&+({
                      {
                        var $md: scala.xml.MetaData = scala.xml.Null;
                        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("tchart-section tchart-total"), $md);
                        new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(new scala.xml.Text("\012                    Equity:\012                "));
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012                "));
                    $buf.&+({
                      {
                        var $md: scala.xml.MetaData = scala.xml.Null;
                        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("tchart-section tchart-total tchart-dollars"), $md);
                        new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(new scala.xml.Text("\012                "));
                          $buf.&+(total.-(liabilitiesTotal).$);
                          $buf.&+(new scala.xml.Text("\012                "));
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012            "));
                    $buf
                  }: _*))
                }
              });
              $buf.&+(new scala.xml.Text("\012        "));
              $buf
            }: _*))
          }
        };
        table$lzy
      };
      lazy var assetsTable$lzy: scala.xml.Elem = _;
      <stable> <accessor> lazy def assetsTable: scala.xml.Elem = {
        assetsTable$lzy = {
          {
            var $md: scala.xml.MetaData = scala.xml.Null;
            $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("tchart assets"), $md);
            new scala.xml.Elem(null, "table", $md, scala.this.Predef.$scope, ({
              val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
              $buf.&+(new scala.xml.Text("\012            "));
              $buf.&+({
                {
                  var $md: scala.xml.MetaData = scala.xml.Null;
                  $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("tchart-section"), $md);
                  new scala.xml.Elem(null, "tr", $md, scala.this.Predef.$scope, ({
                    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                    $buf.&+(new scala.xml.Text("\012                "));
                    $buf.&+({
                      {
                        new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(new scala.xml.Text("Cash"));
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012                "));
                    $buf.&+({
                      {
                        new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope)
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012                "));
                    $buf.&+({
                      {
                        new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope)
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012                "));
                    $buf.&+({
                      {
                        var $md: scala.xml.MetaData = scala.xml.Null;
                        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("tchart-dollars"), $md);
                        new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(myCashAmount.$);
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012            "));
                    $buf
                  }: _*))
                }
              });
              $buf.&+(new scala.xml.Text("\012\012            "));
              $buf.&+({
                {
                  var $md: scala.xml.MetaData = scala.xml.Null;
                  $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("tchart-section"), $md);
                  new scala.xml.Elem(null, "tr", $md, scala.this.Predef.$scope, ({
                    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                    $buf.&+(new scala.xml.Text("\012                "));
                    $buf.&+({
                      {
                        var $md: scala.xml.MetaData = scala.xml.Null;
                        $md = new scala.xml.UnprefixedAttribute("colspan", new scala.xml.Text("2"), $md);
                        new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(new scala.xml.Text("Stocks"));
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012                "));
                    $buf.&+({
                      {
                        var $md: scala.xml.MetaData = scala.xml.Null;
                        $md = new scala.xml.UnprefixedAttribute("colspan", new scala.xml.Text("1"), $md);
                        new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope)
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012                "));
                    $buf.&+({
                      {
                        var $md: scala.xml.MetaData = scala.xml.Null;
                        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("tchart-dollars"), $md);
                        new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(stocksTotal.$);
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012            "));
                    $buf
                  }: _*))
                }
              });
              $buf.&+(new scala.xml.Text("\012            "));
              $buf.&+(stocks);
              $buf.&+(new scala.xml.Text("\012\012            "));
              $buf.&+({
                {
                  var $md: scala.xml.MetaData = scala.xml.Null;
                  $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("tchart-section"), $md);
                  new scala.xml.Elem(null, "tr", $md, scala.this.Predef.$scope, ({
                    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                    $buf.&+(new scala.xml.Text("\012                "));
                    $buf.&+({
                      {
                        var $md: scala.xml.MetaData = scala.xml.Null;
                        $md = new scala.xml.UnprefixedAttribute("colspan", new scala.xml.Text("2"), $md);
                        new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(new scala.xml.Text("Derivatives"));
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012                "));
                    $buf.&+({
                      {
                        new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope)
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012                "));
                    $buf.&+({
                      {
                        var $md: scala.xml.MetaData = scala.xml.Null;
                        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("tchart-dollars"), $md);
                        new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(new scala.xml.Text("**"));
                          $buf.&+(derivsTotal.$);
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012            "));
                    $buf
                  }: _*))
                }
              });
              $buf.&+(new scala.xml.Text("\012            "));
              $buf.&+(derivativeAssets);
              $buf.&+(new scala.xml.Text("\012        "));
              $buf
            }: _*))
          }
        };
        assetsTable$lzy
      };
      lazy var stocksTotal$lzy: model.Dollars = _;
      <stable> <accessor> lazy def stocksTotal: model.Dollars = {
        stocksTotal$lzy = myStockAssets.map[Option[model.Dollars], Seq[Option[model.Dollars]]]({
  ((asset: model.schema.GroupedStockAsset) => stockDollars(asset))
})(collection.this.Seq.canBuildFrom[Option[model.Dollars]]).map[model.Dollars, Seq[model.Dollars]](((x$2: Option[model.Dollars]) => x$2.getOrElse[model.Dollars](new model.Dollars(math.this.BigDecimal.int2bigDecimal(0)))))(collection.this.Seq.canBuildFrom[model.Dollars]).foldLeft[model.Dollars](model.Dollars.apply("0"))(((x$3: model.Dollars, x$4: model.Dollars) => x$3.+(x$4)));
        stocksTotal$lzy
      };
      lazy var derivsTotal$lzy: model.Dollars = _;
      <stable> <accessor> lazy def derivsTotal: model.Dollars = {
        derivsTotal$lzy = myDerivativeAssets.map[model.Derivative, List[model.Derivative]](((x$5: model.schema.DerivativeAsset) => x$5.derivative))(immutable.this.List.canBuildFrom[model.Derivative]).map[model.Dollars, List[model.Dollars]](((x$6: model.Derivative) => x$6.spotValue))(immutable.this.List.canBuildFrom[model.Dollars]).foldLeft[model.Dollars](model.Dollars.apply("0"))(((x$7: model.Dollars, x$8: model.Dollars) => x$7.+(x$8)));
        derivsTotal$lzy
      };
      lazy var total$lzy: model.Dollars = _;
      <stable> <accessor> lazy def total: model.Dollars = {
        total$lzy = stocksTotal.+(myCashAmount).+(derivsTotal);
        total$lzy
      };
      lazy var stocks$lzy: Seq[scala.xml.Node] = _;
      <stable> <accessor> lazy def stocks: Seq[scala.xml.Node] = {
        stocks$lzy = if (myStockAssets.isEmpty)
          {
            {
              new scala.xml.Elem(null, "tr", scala.xml.Null, scala.this.Predef.$scope, ({
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+({
                  {
                    var $md: scala.xml.MetaData = scala.xml.Null;
                    $md = new scala.xml.UnprefixedAttribute("colspan", new scala.xml.Text("4"), $md);
                    new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope, ({
                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                      $buf.&+(new scala.xml.Text("none"));
                      $buf
                    }: _*))
                  }
                });
                $buf
              }: _*))
            }
          }
        else
          myStockAssets.map[scala.xml.Elem, Seq[scala.xml.Elem]](((asset: model.schema.GroupedStockAsset) => {
            {
              new scala.xml.Elem(null, "tr", scala.xml.Null, scala.this.Predef.$scope, ({
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+(new scala.xml.Text("\012                    "));
                $buf.&+({
                  {
                    var $md: scala.xml.MetaData = scala.xml.Null;
                    $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("tchart-ticker"), $md);
                    new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope, ({
                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                      $buf.&+(asset.ticker);
                      $buf
                    }: _*))
                  }
                });
                $buf.&+(new scala.xml.Text("\012                    "));
                $buf.&+({
                  {
                    var $md: scala.xml.MetaData = scala.xml.Null;
                    $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("tchart-price"), $md);
                    new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope, ({
                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                      $buf.&+(new scala.xml.Text("("));
                      $buf.&+(asset.shares.###().+(" @ ").+(mehPrice(asset)));
                      $buf.&+(new scala.xml.Text(")"));
                      $buf
                    }: _*))
                  }
                });
                $buf.&+(new scala.xml.Text("\012                    "));
                $buf.&+({
                  {
                    var $md: scala.xml.MetaData = scala.xml.Null;
                    $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("buttons"), $md);
                    new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope, ({
                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                      $buf.&+(new scala.xml.Text("\012                    "));
                      $buf.&+(if (modifiable)
                        snippet.SellThisStock.apply(asset.ticker)
                      else
                        immutable.this.Nil);
                      $buf.&+(new scala.xml.Text("\012                    "));
                      $buf
                    }: _*))
                  }
                });
                $buf.&+(new scala.xml.Text("\012                    "));
                $buf.&+({
                  {
                    var $md: scala.xml.MetaData = scala.xml.Null;
                    $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("tchart-dollars"), $md);
                    new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope, ({
                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                      $buf.&+(mehDollars(asset));
                      $buf
                    }: _*))
                  }
                });
                $buf.&+(new scala.xml.Text("\012                "));
                $buf
              }: _*))
            }
          }))(collection.this.Seq.canBuildFrom[scala.xml.Elem]);
        stocks$lzy
      };
      lazy var derivativeAssets$lzy: scala.collection.immutable.Seq[scala.xml.Node] = _;
      <stable> <accessor> lazy def derivativeAssets: scala.collection.immutable.Seq[scala.xml.Node] = {
        derivativeAssets$lzy = if (myDerivativeAssets.isEmpty)
          {
            {
              var $md: scala.xml.MetaData = scala.xml.Null;
              $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("deriv-row deriv-header"), $md);
              new scala.xml.Elem(null, "tr", $md, scala.this.Predef.$scope, ({
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+({
                  {
                    var $md: scala.xml.MetaData = scala.xml.Null;
                    $md = new scala.xml.UnprefixedAttribute("colspan", new scala.xml.Text("3"), $md);
                    new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope, ({
                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                      $buf.&+(new scala.xml.Text("none"));
                      $buf
                    }: _*))
                  }
                });
                $buf
              }: _*))
            }
          }
        else
          myDerivativeAssets.flatMap[scala.xml.Node, List[scala.xml.Node]]({
            ((asset: model.schema.DerivativeAsset) => renderDerivativeAsset(asset))
          })(immutable.this.List.canBuildFrom[scala.xml.Node]);
        derivativeAssets$lzy
      };
      def renderDerivativeAsset(asset: model.schema.DerivativeAsset): Seq[scala.xml.Node] with Serializable = if (asset.hidden.&&(showHidden.unary_!))
        immutable.this.Nil
      else
        {
          val deriv: model.Derivative = asset.derivative;
          val liab: model.Link[model.schema.DerivativeLiability] = asset.peer;
          {
            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
            $buf.&+({
              {
                var $md: scala.xml.MetaData = scala.xml.Null;
                $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("deriv-row deriv-header"), $md);
                new scala.xml.Elem(null, "tr", $md, scala.this.Predef.$scope, ({
                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                  $buf.&+(new scala.xml.Text("\012                "));
                  $buf.&+({
                    {
                      new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                        $buf.&+(new scala.xml.Text("Secs:"));
                        $buf
                      }: _*))
                    }
                  });
                  $buf.&+(new scala.xml.Text("\012                "));
                  $buf.&+({
                    {
                      new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                        $buf.&+(formats.`package`.securitiesFormatted(deriv.securities).toHumanString);
                        $buf
                      }: _*))
                    }
                  });
                  $buf.&+(new scala.xml.Text("\012                "));
                  $buf.&+({
                    {
                      var $md: scala.xml.MetaData = scala.xml.Null;
                      $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("buttons"), $md);
                      new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope, ({
                        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                        $buf.&+(if (modifiable.&&(asset.derivative.early))
                          execDerivative(asset)
                        else
                          immutable.this.Nil);
                        $buf
                      }: _*))
                    }
                  });
                  $buf.&+(new scala.xml.Text("\012                "));
                  $buf.&+({
                    {
                      var $md: scala.xml.MetaData = scala.xml.Null;
                      $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("tchart-dollars"), $md);
                      new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope, ({
                        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                        $buf.&+(new scala.xml.Text("**"));
                        $buf.&+(deriv.spotValue.$);
                        $buf
                      }: _*))
                    }
                  });
                  $buf.&+(new scala.xml.Text("\012            "));
                  $buf
                }: _*))
              }
            });
            $buf.&+({
              {
                var $md: scala.xml.MetaData = scala.xml.Null;
                $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("deriv-row"), $md);
                new scala.xml.Elem(null, "tr", $md, scala.this.Predef.$scope, ({
                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                  $buf.&+(new scala.xml.Text("\012                "));
                  $buf.&+({
                    {
                      new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                        $buf.&+(new scala.xml.Text("From:"));
                        $buf
                      }: _*))
                    }
                  });
                  $buf.&+(new scala.xml.Text("\012                "));
                  $buf.&+({
                    {
                      var $md: scala.xml.MetaData = scala.xml.Null;
                      $md = new scala.xml.UnprefixedAttribute("colspan", new scala.xml.Text("3"), $md);
                      new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope, ({
                        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                        $buf.&+(PortfolioLink.apply(model.this.Link.extract[model.schema.Portfolio](model.this.Link.extract[model.schema.DerivativeLiability](liab)(model.this.schema.derivativeLiabilities).owner)(model.schema.portfolios)));
                        $buf
                      }: _*))
                    }
                  });
                  $buf.&+(new scala.xml.Text("\012            "));
                  $buf
                }: _*))
              }
            });
            $buf.&+({
              {
                var $md: scala.xml.MetaData = scala.xml.Null;
                $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("deriv-row"), $md);
                new scala.xml.Elem(null, "tr", $md, scala.this.Predef.$scope, ({
                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                  $buf.&+(new scala.xml.Text("\012                "));
                  $buf.&+({
                    {
                      new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                        $buf.&+(new scala.xml.Text("On:"));
                        $buf
                      }: _*))
                    }
                  });
                  $buf.&+(new scala.xml.Text("\012                "));
                  $buf.&+({
                    {
                      var $md: scala.xml.MetaData = scala.xml.Null;
                      $md = new scala.xml.UnprefixedAttribute("colspan", new scala.xml.Text("3"), $md);
                      new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope, ({
                        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                        $buf.&+(formats.`package`.dateTimeFormatted(deriv.exec).toNearbyString);
                        $buf
                      }: _*))
                    }
                  });
                  $buf.&+(new scala.xml.Text("\012            "));
                  $buf
                }: _*))
              }
            });
            $buf.&+({
              {
                var $md: scala.xml.MetaData = scala.xml.Null;
                $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("deriv-row"), $md);
                new scala.xml.Elem(null, "tr", $md, scala.this.Predef.$scope, ({
                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                  $buf.&+(new scala.xml.Text("\012                "));
                  $buf.&+({
                    {
                      new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                        $buf.&+(new scala.xml.Text("If:"));
                        $buf
                      }: _*))
                    }
                  });
                  $buf.&+(new scala.xml.Text("\012                "));
                  $buf.&+({
                    {
                      var $md: scala.xml.MetaData = scala.xml.Null;
                      $md = new scala.xml.UnprefixedAttribute("colspan", new scala.xml.Text("3"), $md);
                      new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope, ({
                        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                        $buf.&+(formats.`package`.conditionFormatted(deriv.condition).toHumanString);
                        $buf
                      }: _*))
                    }
                  });
                  $buf.&+(new scala.xml.Text("\012            "));
                  $buf
                }: _*))
              }
            });
            $buf
          }
        };
      lazy var liabilitiesTable$lzy: scala.xml.Elem = _;
      <stable> <accessor> lazy def liabilitiesTable: scala.xml.Elem = {
        liabilitiesTable$lzy = {
          {
            var $md: scala.xml.MetaData = scala.xml.Null;
            $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("tchart liabilities"), $md);
            new scala.xml.Elem(null, "table", $md, scala.this.Predef.$scope, ({
              val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
              $buf.&+(new scala.xml.Text("\012            "));
              $buf.&+({
                {
                  var $md: scala.xml.MetaData = scala.xml.Null;
                  $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("tchart-section"), $md);
                  new scala.xml.Elem(null, "tr", $md, scala.this.Predef.$scope, ({
                    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                    $buf.&+(new scala.xml.Text("\012                "));
                    $buf.&+({
                      {
                        var $md: scala.xml.MetaData = scala.xml.Null;
                        $md = new scala.xml.UnprefixedAttribute("colspan", new scala.xml.Text("2"), $md);
                        new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(new scala.xml.Text("Derivatives"));
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012                "));
                    $buf.&+({
                      {
                        new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope)
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012                "));
                    $buf.&+({
                      {
                        var $md: scala.xml.MetaData = scala.xml.Null;
                        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("tchart-dollars"), $md);
                        new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(new scala.xml.Text("**"));
                          $buf.&+(derivativeLiabilitiesTotal.$);
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012            "));
                    $buf
                  }: _*))
                }
              });
              $buf.&+(new scala.xml.Text("\012            "));
              $buf.&+(derivativeLiabilities);
              $buf.&+(new scala.xml.Text("\012        "));
              $buf
            }: _*))
          }
        };
        liabilitiesTable$lzy
      };
      lazy var valuedDerivativeLiabilities$lzy: List[(model.schema.DerivativeLiability, model.Dollars)] = _;
      <stable> <accessor> lazy def valuedDerivativeLiabilities: List[(model.schema.DerivativeLiability, model.Dollars)] = {
        valuedDerivativeLiabilities$lzy = myDerivativeLiabilities.map[(model.schema.DerivativeLiability, model.Dollars), List[(model.schema.DerivativeLiability, model.Dollars)]](((lia: model.schema.DerivativeLiability) => new (model.schema.DerivativeLiability, model.Dollars)(lia, lia.derivative.spotValue.*(lia.remaining))))(immutable.this.List.canBuildFrom[(model.schema.DerivativeLiability, model.Dollars)]);
        valuedDerivativeLiabilities$lzy
      };
      lazy var derivativeLiabilities$lzy: scala.collection.immutable.Seq[scala.xml.Node] = _;
      <stable> <accessor> lazy def derivativeLiabilities: scala.collection.immutable.Seq[scala.xml.Node] = {
        derivativeLiabilities$lzy = if (myDerivativeLiabilities.isEmpty)
          {
            {
              new scala.xml.Elem(null, "tr", scala.xml.Null, scala.this.Predef.$scope, ({
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+({
                  {
                    var $md: scala.xml.MetaData = scala.xml.Null;
                    $md = new scala.xml.UnprefixedAttribute("colspan", new scala.xml.Text("4"), $md);
                    new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope, ({
                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                      $buf.&+(new scala.xml.Text("none"));
                      $buf
                    }: _*))
                  }
                });
                $buf
              }: _*))
            }
          }
        else
          valuedDerivativeLiabilities.flatMap[scala.xml.Node, List[scala.xml.Node]]({
  ((liability: model.schema.DerivativeLiability, dollars: model.Dollars) => renderDerivativeLiability(liability, dollars))
}.tupled)(immutable.this.List.canBuildFrom[scala.xml.Node]);
        derivativeLiabilities$lzy
      };
      def renderDerivativeLiability(liability: model.schema.DerivativeLiability, dollars: model.Dollars): Seq[scala.xml.Node] with Serializable = if (liability.hidden.&&(showHidden.unary_!))
        immutable.this.Nil
      else
        {
          val deriv: model.Derivative = liability.derivative;
          {
            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
            $buf.&+({
              {
                var $md: scala.xml.MetaData = scala.xml.Null;
                $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("deriv-row deriv-header"), $md);
                new scala.xml.Elem(null, "tr", $md, scala.this.Predef.$scope, ({
                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                  $buf.&+(new scala.xml.Text("\012                "));
                  $buf.&+({
                    {
                      new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                        $buf.&+(new scala.xml.Text("Secs:"));
                        $buf
                      }: _*))
                    }
                  });
                  $buf.&+(new scala.xml.Text("\012                "));
                  $buf.&+({
                    {
                      new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                        $buf.&+(formats.`package`.securitiesFormatted(deriv.securities).toHumanString);
                        $buf
                      }: _*))
                    }
                  });
                  $buf.&+(new scala.xml.Text("\012                "));
                  $buf.&+({
                    {
                      new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                        $buf.&+(new scala.xml.Text(" "));
                        $buf
                      }: _*))
                    }
                  });
                  $buf.&+(new scala.xml.Text("\012                "));
                  $buf.&+({
                    {
                      var $md: scala.xml.MetaData = scala.xml.Null;
                      $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("tchart-dollars"), $md);
                      new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope, ({
                        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                        $buf.&+(new scala.xml.Text("**"));
                        $buf.&+(dollars.$);
                        $buf
                      }: _*))
                    }
                  });
                  $buf.&+(new scala.xml.Text("\012            "));
                  $buf
                }: _*))
              }
            });
            $buf.&+({
              {
                var $md: scala.xml.MetaData = scala.xml.Null;
                $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("deriv-row"), $md);
                new scala.xml.Elem(null, "tr", $md, scala.this.Predef.$scope, ({
                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                  $buf.&+(new scala.xml.Text("\012                "));
                  $buf.&+({
                    {
                      new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                        $buf.&+(new scala.xml.Text("On:"));
                        $buf
                      }: _*))
                    }
                  });
                  $buf.&+(new scala.xml.Text("\012                "));
                  $buf.&+({
                    {
                      new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                        $buf.&+(formats.`package`.dateTimeFormatted(deriv.exec).toNearbyString);
                        $buf
                      }: _*))
                    }
                  });
                  $buf.&+(new scala.xml.Text("\012            "));
                  $buf
                }: _*))
              }
            });
            $buf.&+({
              {
                var $md: scala.xml.MetaData = scala.xml.Null;
                $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("deriv-row"), $md);
                new scala.xml.Elem(null, "tr", $md, scala.this.Predef.$scope, ({
                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                  $buf.&+(new scala.xml.Text("\012                "));
                  $buf.&+({
                    {
                      new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                        $buf.&+(new scala.xml.Text("If:"));
                        $buf
                      }: _*))
                    }
                  });
                  $buf.&+(new scala.xml.Text("\012                "));
                  $buf.&+({
                    {
                      new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                        $buf.&+(formats.`package`.conditionFormatted(deriv.condition).toHumanString);
                        $buf
                      }: _*))
                    }
                  });
                  $buf.&+(new scala.xml.Text("\012            "));
                  $buf
                }: _*))
              }
            });
            $buf
          }
        };
      lazy var derivativeLiabilitiesTotal$lzy: model.Dollars = _;
      <stable> <accessor> lazy def derivativeLiabilitiesTotal: model.Dollars = {
        derivativeLiabilitiesTotal$lzy = valuedDerivativeLiabilities.map[model.Dollars, List[model.Dollars]](((x$9: (model.schema.DerivativeLiability, model.Dollars)) => x$9._2))(immutable.this.List.canBuildFrom[model.Dollars]).foldLeft[model.Dollars](new model.Dollars(math.this.BigDecimal.int2bigDecimal(0)))(((x$10: model.Dollars, x$11: model.Dollars) => x$10.+(x$11)));
        derivativeLiabilitiesTotal$lzy
      };
      lazy var liabilitiesTotal$lzy: model.Dollars = _;
      <stable> <accessor> lazy def liabilitiesTotal: model.Dollars = {
        liabilitiesTotal$lzy = derivativeLiabilitiesTotal;
        liabilitiesTotal$lzy
      };
      result
    };
    def execDerivative(da: model.schema.DerivativeAsset): scala.xml.NodeSeq = intform.FormSubmit.rendered("Exercise")(try {
      js.this.JsCmd.unitToJsCmd(da.userExecuteManually())
    } catch {
      case model.schema.NoSuchDerivativeAsset => throw new intform.BadInput("No longer exists")
    });
    def mehDollars(asset: model.schema.GroupedStockAsset): String = stockDollars(asset).map[String](((x$12: model.Dollars) => x$12.$)).getOrElse[String]("???");
    def stockDollars(asset: model.schema.GroupedStockAsset): Option[model.Dollars] = stockPrice(asset).map[model.Dollars](((x$13: model.Price) => x$13.*(asset.shares)));
    def mehPrice(asset: model.schema.GroupedStockAsset): String = stockPrice(asset).map[String](((x$14: model.Price) => x$14.$)).getOrElse[String]("???");
    def stockPrice(asset: model.schema.GroupedStockAsset): Option[model.Price] = try {
      new Some[model.Price](model.Stocks.stockPrice(asset.ticker))
    } catch {
      case (e @ (_: stockdata.NoSuchStockException)) => {
        tChart.this.logger.error("Ugh", e);
        scala.None
      }
      case (e @ (_: stockdata.DatabaseException)) => {
        scala.None;
        tChart.this.logger.error("Ugh", e);
        scala.None
      }
    };
    def hiddenControls: scala.collection.immutable.Seq[scala.xml.Node] with Serializable = if (port.myDerivativeAssets.exists(((x$15: model.schema.DerivativeAsset) => x$15.hidden)).||(port.myDerivativeLiabilities.exists(((x$16: model.schema.DerivativeLiability) => x$16.hidden))))
      {
        lazy var showLink$lzy: scala.xml.NodeSeq = _;
        <stable> <accessor> lazy def showLink: scala.xml.NodeSeq = {
          showLink$lzy = intform.FormSubmit.rendered("Show Hidden")({
            showHidden = true;
            refreshable.refresh()
          });
          showLink$lzy
        };
        lazy var hideLink$lzy: scala.xml.NodeSeq = _;
        <stable> <accessor> lazy def hideLink: scala.xml.NodeSeq = {
          hideLink$lzy = intform.FormSubmit.rendered("Hide Hidden")({
            showHidden = false;
            refreshable.refresh()
          });
          hideLink$lzy
        };
        if (showHidden)
          {
            {
              new scala.xml.Elem(null, "p", scala.xml.Null, scala.this.Predef.$scope, ({
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+(new scala.xml.Text("show hidden "));
                $buf.&+({
                  {
                    var $md: scala.xml.MetaData = scala.xml.Null;
                    $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("button"), $md);
                    new scala.xml.Elem(null, "span", $md, scala.this.Predef.$scope, ({
                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                      $buf.&+(hideLink);
                      $buf
                    }: _*))
                  }
                });
                $buf
              }: _*))
            }
          }
        else
          {
            {
              new scala.xml.Elem(null, "p", scala.xml.Null, scala.this.Predef.$scope, ({
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+({
                  {
                    var $md: scala.xml.MetaData = scala.xml.Null;
                    $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("button"), $md);
                    new scala.xml.Elem(null, "span", $md, scala.this.Predef.$scope, ({
                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                      $buf.&+(showLink);
                      $buf
                    }: _*))
                  }
                });
                $buf.&+(new scala.xml.Text(" hide hidden"));
                $buf
              }: _*))
            }
          }
      }
    else
      immutable.this.Nil;
    render
  }
}
tChart: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
           apply

class SearchPipeline extends java.lang.Object with intform.Page with net.liftweb.common.Loggable with ScalaObject {
  def this(): code.snippet.SearchPipeline = {
    SearchPipeline.super.this();
    ()
  };
  private[this] val searchForm: code.snippet.SearchBar = new SearchBar();
  <stable> <accessor> def searchForm: code.snippet.SearchBar = SearchPipeline.this.searchForm;
  private[this] val actionForm: code.snippet.StockOrderer = new StockOrderer();
  <stable> <accessor> def actionForm: code.snippet.StockOrderer = SearchPipeline.this.actionForm;
  private[this] val derivativeForm: code.snippet.DerivativeBuilder = new DerivativeBuilder();
  <stable> <accessor> def derivativeForm: code.snippet.DerivativeBuilder = SearchPipeline.this.derivativeForm;
  SearchPipeline.this.searchForm.listen(((x$1: SearchPipeline.this.searchForm.Status) => x$1 match {
    case (quote: stockdata.Quote)SearchPipeline.this.searchForm.HaveQuote((quote @ _)) => SearchPipeline.this.actionForm.changeQuote(quote)
    case _ => SearchPipeline.this.actionForm.clearQuote.&(new net.liftweb.http.js.JsCmds.Focus("search-query-field"))
  }));
  SearchPipeline.this.actionForm.listen(((x$2: code.snippet.StockOrder) => x$2 match {
    case (_: code.snippet.NoOrder) => SearchPipeline.this.searchForm.clear.&(new net.liftweb.http.js.JsCmds.Focus("search-query-field"))
    case (_: code.snippet.BuyShares) => SearchPipeline.this.searchForm.clear.&(new net.liftweb.http.js.JsCmds.Focus("search-query-field"))
    case (order @ (_: code.snippet.AddToDerivative)) => SearchPipeline.this.searchForm.clear.&(SearchPipeline.this.derivativeForm.addOrder(order)).&(new net.liftweb.http.js.JsCmds.Focus("to-user-name"))
  }));
  private[this] val refreshable: intform.Refreshable.NeedRenderable with intform.Refreshable = intform.Refreshable.apply({
    {
      var $md: scala.xml.MetaData = scala.xml.Null;
      $md = new scala.xml.UnprefixedAttribute("id", new scala.xml.Text("search"), $md);
      $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("container"), $md);
      new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
        $buf.&+(new scala.xml.Text("\012            "));
        $buf.&+(SearchPipeline.this.searchForm.render);
        $buf.&+(new scala.xml.Text("\012            "));
        $buf.&+(SearchPipeline.this.actionForm.render);
        $buf.&+(new scala.xml.Text("\012            "));
        $buf.&+(SearchPipeline.this.derivativeForm.render);
        $buf.&+(new scala.xml.Text("\012        "));
        $buf
      }: _*))
    }
  });
  private <stable> <accessor> def refreshable: intform.Refreshable.NeedRenderable with intform.Refreshable = SearchPipeline.this.refreshable;
  def render: scala.xml.NodeSeq = SearchPipeline.this.refreshable.render
}
SearchPipeline: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
          render
     $md        

final case object Idle extends java.lang.Object with SearchBar.this.Status with ScalaObject with Product with Serializable {
  def this(): object SearchBar.this.Idle = {
    Idle.super.this();
    ()
  };
  final override def hashCode(): Int = 2274292;
  final override def toString(): java.lang.String = "Idle";
  override def productPrefix: java.lang.String = "Idle";
  override def productArity: Int = 0;
  override def productElement(x$1: Int): Any = x$1 match {
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[object SearchBar.this.Idle]()
}
Idle: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

case class PortfolioInvite extends java.lang.Object with model.KL with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val id: model.package.Key = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def id: model.package.Key = PortfolioInvite.this.id;
  <caseaccessor> <paramaccessor> private[this] val from: UserSchema.this.Portfolio = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def from: UserSchema.this.Portfolio = PortfolioInvite.this.from;
  <caseaccessor> <paramaccessor> private[this] val to: UserSchema.this.User = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def to: UserSchema.this.User = PortfolioInvite.this.to;
  def this(id: model.package.Key = model.this.`package`.nextID, from: UserSchema.this.Portfolio, to: UserSchema.this.User): UserSchema.this.PortfolioInvite = {
    PortfolioInvite.super.this();
    ()
  };
  <synthetic> def copy(id: model.package.Key = id, from: UserSchema.this.Portfolio = from, to: UserSchema.this.User = to): UserSchema.this.PortfolioInvite = new UserSchema.this.PortfolioInvite(id, from, to);
  <synthetic> def copy$default$3: UserSchema.this.User @scala.annotation.unchecked.uncheckedVariance = PortfolioInvite.this.to;
  <synthetic> def copy$default$2: UserSchema.this.Portfolio @scala.annotation.unchecked.uncheckedVariance = PortfolioInvite.this.from;
  <synthetic> def copy$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = PortfolioInvite.this.id;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(PortfolioInvite.this);
  override def toString(): String = ScalaRunTime.this._toString(PortfolioInvite.this);
  override def equals(x$1: Any): Boolean = PortfolioInvite.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (id: model.package.Key, from: UserSchema.this.Portfolio, to: UserSchema.this.User)UserSchema.this.PortfolioInvite((id$4 @ _), (from$1 @ _), (to$1 @ _)) if id$4.==(id).&&(from$1.==(from)).&&(to$1.==(to)) => x$1.asInstanceOf[UserSchema.this.PortfolioInvite].canEqual(PortfolioInvite.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "PortfolioInvite";
  override def productArity: Int = 3;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => id
    case 1 => from
    case 2 => to
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[UserSchema.this.PortfolioInvite]()
}
PortfolioInvite: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
      to
      id
    from

class SwitchPortfolio extends java.lang.Object with intform.Page with net.liftweb.common.Loggable with ScalaObject {
  def this(): code.snippet.SwitchPortfolio = {
    SwitchPortfolio.super.this();
    ()
  };
  private[this] val nameParam: net.liftweb.common.Box[String] = net.liftweb.http.S.param("name");
  <stable> <accessor> def nameParam: net.liftweb.common.Box[String] = SwitchPortfolio.this.nameParam;
  def render: scala.xml.NodeSeq = {
    val user: model.schema.User = control.LoginManager.currentUser;
    try {
      SwitchPortfolio.this.nameParam match {
        case (value: String)net.liftweb.common.Full[String]((key @ _)) => control.PortfolioSwitcher.switchPortfolio(key)
        case _ => ()
      };
      xml.this.NodeSeq.seqToNodeSeq(myPage.apply())
    } catch {
      case control.LoginManager.NotLoggedIn => {
        {
          new scala.xml.Elem(null, "p", scala.xml.Null, scala.this.Predef.$scope, ({
            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
            $buf.&+(new scala.xml.Text("You don\'t seemed to be logged in. How sad ;(;(;("));
            $buf
          }: _*))
        }
      }
    }
  }
}
SwitchPortfolio: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
          render

final object SelectField extends java.lang.Object with ScalaObject {
  def this(): object code.snippet.SelectField = {
    SelectField.super.this();
    ()
  };
  def apply[A >: Nothing <: Any](c: Seq[(A, String)], a: A): code.snippet.SelectField[A] = {
    val v: scala.collection.immutable.Vector[(A, String)] = scala.`package`.Vector.apply[(A, String)]((c: _*));
    val i: Int = v.map[A, scala.collection.immutable.Vector[A]](((x$2: (A, String)) => x$2._1))(immutable.this.Vector.canBuildFrom[A]).indexOf[A](a);
    scala.this.Predef.assert(i.!=(-1), scala.this.Predef.augmentString("That\'s not a valid option %s in %s").format(a, c));
    new code.snippet.SelectField[A](v, i)
  }
}
SelectField: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
           apply

abstract trait SelectRender extends java.lang.Object with intform.FieldRender with net.liftweb.common.Loggable with ScalaObject {
  def /*SelectRender*/$init$(): Unit = {
    ()
  };
  def names: Vector[String];
  <accessor> def chosen: Int;
  <accessor> def chosen_=(x$1: Int): Unit;
  def main: scala.xml.Elem = {
    val ids: scala.collection.immutable.Vector[java.lang.String] = SelectRender.this.names.map[java.lang.String, scala.collection.immutable.Vector[java.lang.String]](((x$3: String) => java.util.UUID.randomUUID().toString()))(immutable.this.Vector.canBuildFrom[java.lang.String]);
    val chosenID: java.lang.String = ids.apply(SelectRender.this.chosen);
    net.liftweb.http.SHtml.select(ids.zip[java.lang.String, String, Seq[(String, String)]](SelectRender.this.names)(immutable.this.Vector.canBuildFrom[(java.lang.String, String)]), common.this.Box.option2Box[java.lang.String](new Some[java.lang.String](chosenID)), ((n: String) => SelectRender.this.chosen_=({
      val i: Int = ids.indexOf[java.lang.String](n);
      if (i.==(-1))
        0
      else
        i
    })))
  }
}
SelectRender: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
            main
   names     X  
  chosen     X  
 chosen_     X  

abstract trait QueryService extends scala.AnyRef {
  def query(url: java.net.URL): String
}
QueryService: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
   query

final object package extends java.lang.Object with ScalaObject {
  def this(): object texttrading.package = {
    package.super.this();
    ()
  };
  private[this] val commandIntro: String = scala.this.Predef.augmentString("|\"buy $150 of MSFT\",\012           |\"sell 50 shares of MSFT\",\012           |\"sell MSFT\" (sells all),\012           |\"how much MSFT\",\012           |or \"portfolio\"\012           |").stripMargin;
  <stable> <accessor> def commandIntro: String = package.this.commandIntro
}
package: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

abstract trait Backend extends scala.AnyRef {
  def perform(request: texttrading.Request): texttrading.Response
}
Backend: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
 perform

case class Response extends java.lang.Object with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val status: texttrading.Status = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def status: texttrading.Status = Response.this.status;
  <caseaccessor> <paramaccessor> private[this] val extraMsgs: Seq[String] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def extraMsgs: Seq[String] = Response.this.extraMsgs;
  def this(status: texttrading.Status, extraMsgs: Seq[String]): texttrading.Response = {
    Response.super.this();
    ()
  };
  <synthetic> def copy(status: texttrading.Status = status, extraMsgs: Seq[String] = extraMsgs): texttrading.Response = new texttrading.this.Response(status, extraMsgs);
  <synthetic> def copy$default$2: Seq[String] @scala.annotation.unchecked.uncheckedVariance = Response.this.extraMsgs;
  <synthetic> def copy$default$1: texttrading.Status @scala.annotation.unchecked.uncheckedVariance = Response.this.status;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(Response.this);
  override def toString(): String = ScalaRunTime.this._toString(Response.this);
  override def equals(x$1: Any): Boolean = Response.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (status: texttrading.Status, extraMsgs: Seq[String])texttrading.Response((status$1 @ _), (extraMsgs$1 @ _)) if status$1.==(status).&&(extraMsgs$1.==(extraMsgs)) => x$1.asInstanceOf[texttrading.Response].canEqual(Response.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "Response";
  override def productArity: Int = 2;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => status
    case 1 => extraMsgs
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[texttrading.Response]()
}
Response: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
 extraMs
  status

class SelectField[A >: Nothing <: Any] extends intform.Field[A] with code.snippet.SelectRender with ScalaObject {
  <paramaccessor> private[this] val choices: Vector[(A, String)] = _;
  <stable> <accessor> <paramaccessor> def choices: Vector[(A, String)] = SelectField.this.choices;
  <paramaccessor> private[this] val initState: Int = _;
  def this(choices: Vector[(A, String)], initState: Int): code.snippet.SelectField[A] = {
    SelectField.super.this();
    ()
  };
  private[this] val names: scala.collection.immutable.Vector[String] = SelectField.this.choices.map[String, scala.collection.immutable.Vector[String]](((x$1: (A, String)) => x$1._2))(immutable.this.Vector.canBuildFrom[String]);
  <stable> <accessor> def names: scala.collection.immutable.Vector[String] = SelectField.this.names;
  private[this] var chosen: Int = SelectField.this.initState;
  <accessor> def chosen: Int = SelectField.this.chosen;
  <accessor> def chosen_=(x$1: Int): Unit = SelectField.this.chosen = x$1;
  def reset(): Unit = SelectField.this.chosen_=(SelectField.this.initState);
  def produce(): intform.OK[A] = new intform.OK[A](SelectField.this.choices.apply(SelectField.this.chosen)._1)
}
SelectField: SCOM=0.500 CC=0.333 LSCC=0.333 CAMC=1.000
           reset produce
  chosen     X       X  
 initSta     X          
 choices             X  

abstract trait DerivativeAssetOps extends java.lang.Object with ScalaObject { self: DerivativeSchema.this.DerivativeAsset => 
  def /*DerivativeAssetOps*/$init$(): Unit = {
    ()
  };
  def derivative: model.Derivative = model.this.Link.extract[DerivativeSchema.this.DerivativeLiability](DerivativeAssetOps.this.peer)(DerivativeSchema.this.derivativeLiabilities).derivative;
  def userExecuteManually(): Unit = scala.sys.`package`.error("Not implemented");
  def spotValue: model.Dollars = DerivativeAssetOps.this.derivative.spotValue.*(DerivativeAssetOps.this.scale)
}
DerivativeAssetOps: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=1.000
         spotVal derivat userExe

abstract trait FieldRender extends java.lang.Object with intform.Renderable with ScalaObject {
  def /*FieldRender*/$init$(): Unit = {
    ()
  };
  def render: scala.xml.NodeSeq = FieldRender.this.main;
  def main: scala.xml.NodeSeq
}
FieldRender: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
          render
    main     X  

case class DerivativeAsset extends java.lang.Object with model.KL with DerivativeSchema.this.DerivativeAssetOps with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val id: model.package.Key = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def id: model.package.Key = DerivativeAsset.this.id;
  <caseaccessor> <paramaccessor> private[this] val peer: model.Link[DerivativeSchema.this.DerivativeLiability] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def peer: model.Link[DerivativeSchema.this.DerivativeLiability] = DerivativeAsset.this.peer;
  <caseaccessor> <paramaccessor> private[this] val scale: model.Scale = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def scale: model.Scale = DerivativeAsset.this.scale;
  <caseaccessor> <paramaccessor> private[this] val owner: model.Link[DerivativeSchema.this.Portfolio] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def owner: model.Link[DerivativeSchema.this.Portfolio] = DerivativeAsset.this.owner;
  <caseaccessor> <paramaccessor> private[this] val hidden: Boolean = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def hidden: Boolean = DerivativeAsset.this.hidden;
  def this(id: model.package.Key = model.this.`package`.nextID, peer: model.Link[DerivativeSchema.this.DerivativeLiability], scale: model.Scale, owner: model.Link[DerivativeSchema.this.Portfolio], hidden: Boolean): DerivativeSchema.this.DerivativeAsset = {
    DerivativeAsset.super.this();
    ()
  };
  <synthetic> def copy(id: model.package.Key = id, peer: model.Link[DerivativeSchema.this.DerivativeLiability] = peer, scale: model.Scale = scale, owner: model.Link[DerivativeSchema.this.Portfolio] = owner, hidden: Boolean = hidden): DerivativeSchema.this.DerivativeAsset = new DerivativeSchema.this.DerivativeAsset(id, peer, scale, owner, hidden);
  <synthetic> def copy$default$5: Boolean @scala.annotation.unchecked.uncheckedVariance = DerivativeAsset.this.hidden;
  <synthetic> def copy$default$4: model.Link[DerivativeSchema.this.Portfolio] @scala.annotation.unchecked.uncheckedVariance = DerivativeAsset.this.owner;
  <synthetic> def copy$default$3: model.Scale @scala.annotation.unchecked.uncheckedVariance = DerivativeAsset.this.scale;
  <synthetic> def copy$default$2: model.Link[DerivativeSchema.this.DerivativeLiability] @scala.annotation.unchecked.uncheckedVariance = DerivativeAsset.this.peer;
  <synthetic> def copy$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = DerivativeAsset.this.id;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(DerivativeAsset.this);
  override def toString(): String = ScalaRunTime.this._toString(DerivativeAsset.this);
  override def equals(x$1: Any): Boolean = DerivativeAsset.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (id: model.package.Key, peer: model.Link[DerivativeSchema.this.DerivativeLiability], scale: model.Scale, owner: model.Link[DerivativeSchema.this.Portfolio], hidden: Boolean)DerivativeSchema.this.DerivativeAsset((id$1 @ _), (peer$1 @ _), (scale$1 @ _), (owner$1 @ _), (hidden$1 @ _)) if id$1.==(id).&&(peer$1.==(peer)).&&(scale$1.==(scale)).&&(owner$1.==(owner)).&&(hidden$1.==(hidden)) => x$1.asInstanceOf[DerivativeSchema.this.DerivativeAsset].canEqual(DerivativeAsset.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "DerivativeAsset";
  override def productArity: Int = 5;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => id
    case 1 => peer
    case 2 => scale
    case 3 => owner
    case 4 => hidden
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[DerivativeSchema.this.DerivativeAsset]()
}
DerivativeAsset: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
    peer
   owner
  hidden
      id
   scale

final object DateField extends java.lang.Object with ScalaObject {
  def this(): object intform.DateField = {
    DateField.super.this();
    ()
  };
  def apply(initText: String = ""): intform.DateField = new DateField(initText);
  <synthetic> def apply$default$1: String @scala.annotation.unchecked.uncheckedVariance = "";
  private[this] val formatSpec: java.lang.String = "MM/dd";
  <stable> <accessor> def formatSpec: java.lang.String = DateField.this.formatSpec;
  private[this] val format: org.joda.time.format.DateTimeFormatter = org.joda.time.format.DateTimeFormat.forPattern(DateField.this.formatSpec);
  <stable> <accessor> def format: org.joda.time.format.DateTimeFormatter = DateField.this.format
}
DateField: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
           apply

abstract trait PortfolioWithVotes extends java.lang.Object with ScalaObject { self: VotingSchema.this.Portfolio => 
  def /*PortfolioWithVotes*/$init$(): Unit = {
    ()
  };
  def userVoteUp(ev: VotingSchema.this.NewsEvent, aside: VotingSchema.this.DerivativeBuyerSetAside): Unit = VotingSchema.this.editDB[Unit](VotingSchema.this.toOps[VotingSchema.this.Portfolio](this).refetch(VotingSchema.this.portfolios).voteUp(ev, VotingSchema.this.toOps[VotingSchema.this.DerivativeBuyerSetAside](aside).refetch(VotingSchema.this.derivativeBuyerSetAsides)));
  def userVoteDown(ev: VotingSchema.this.NewsEvent, aside: VotingSchema.this.DerivativeSellerSetAside): Unit = VotingSchema.this.editDB[Unit](VotingSchema.this.toOps[VotingSchema.this.Portfolio](this).refetch(VotingSchema.this.portfolios).voteDown(ev, VotingSchema.this.toOps[VotingSchema.this.DerivativeSellerSetAside](aside).refetch(VotingSchema.this.derivativeSellerSetAsides)));
  private[model] def voteUp(ev: VotingSchema.this.NewsEvent, aside: VotingSchema.this.DerivativeBuyerSetAside): VotingSchema.this.Transaction[Unit] = {
    val take: model.Scale = aside.remaining.*(Scale.apply("0.5"));
    val price: model.Dollars = aside.price.*(take);
    VotingSchema.this.toOps[VotingSchema.this.DerivativeBuyerVote]({
  val x$15: model.Link[VotingSchema.this.Portfolio] = model.this.KL.toLink[VotingSchema.this.Portfolio](this);
  val x$16: model.Link[VotingSchema.this.NewsEvent] = model.this.KL.toLink[VotingSchema.this.NewsEvent](ev);
  val x$17: model.package.Key = VotingSchema.this.DerivativeBuyerVote.apply$default$1;
  new VotingSchema.this.DerivativeBuyerVote(x$17, x$15, x$16)
}).insert(VotingSchema.this.derivativeBuyerVotes).flatMap[Unit](((_: VotingSchema.this.DerivativeBuyerVote) => PortfolioWithVotes.this.enterContract(model.this.Link.extract[VotingSchema.this.Portfolio](aside.seller)(VotingSchema.this.portfolios), aside.derivative.*(take), price, true).flatMap[Unit](((_: Unit) => VotingSchema.this.toOps[VotingSchema.this.DerivativeBuyerSetAside](aside).update(((a: VotingSchema.this.DerivativeBuyerSetAside) => {
  val x$18: model.Scale = a.remaining.-(take);
  val x$19: model.package.Key = a.copy$default$1;
  val x$20: model.Link[VotingSchema.this.Portfolio] = a.copy$default$2;
  val x$21: model.Link[VotingSchema.this.Portfolio] = a.copy$default$3;
  val x$22: model.Derivative = a.copy$default$4;
  val x$23: model.Dollars = a.copy$default$5;
  a.copy(x$19, x$20, x$21, x$22, x$23, x$18)
}))(VotingSchema.this.derivativeBuyerSetAsides).map[Unit](((_: Unit) => ()))))))
  };
  private[model] def voteDown(ev: VotingSchema.this.NewsEvent, aside: VotingSchema.this.DerivativeSellerSetAside): VotingSchema.this.Transaction[Unit] = {
    val take: model.Scale = aside.remaining.*(Scale.apply("0.5"));
    val price: model.Dollars = aside.price.*(take);
    VotingSchema.this.toOps[VotingSchema.this.DerivativeSellerVote]({
  val x$24: model.Link[VotingSchema.this.Portfolio] = model.this.KL.toLink[VotingSchema.this.Portfolio](this);
  val x$25: model.Link[VotingSchema.this.NewsEvent] = model.this.KL.toLink[VotingSchema.this.NewsEvent](ev);
  val x$26: model.package.Key = VotingSchema.this.DerivativeSellerVote.apply$default$1;
  new VotingSchema.this.DerivativeSellerVote(x$26, x$24, x$25)
}).insert(VotingSchema.this.derivativeSellerVotes).flatMap[Unit](((_: VotingSchema.this.DerivativeSellerVote) => model.this.Link.extract[VotingSchema.this.Portfolio](aside.buyer)(VotingSchema.this.portfolios).enterContract(this, aside.derivative.*(take), price, true).flatMap[Unit](((_: Unit) => VotingSchema.this.toOps[VotingSchema.this.DerivativeSellerSetAside](aside).update(((a: VotingSchema.this.DerivativeSellerSetAside) => {
  val x$27: model.Scale = a.remaining.-(take);
  val x$28: model.package.Key = a.copy$default$1;
  val x$29: model.Link[VotingSchema.this.Portfolio] = a.copy$default$2;
  val x$30: model.Link[VotingSchema.this.Portfolio] = a.copy$default$3;
  val x$31: model.Derivative = a.copy$default$4;
  val x$32: model.Dollars = a.copy$default$5;
  a.copy(x$28, x$29, x$30, x$31, x$32, x$27)
}))(VotingSchema.this.derivativeSellerSetAsides).map[Unit](((_: Unit) => ()))))))
  };
  private[model] def setupSetAside(buyer: VotingSchema.this.Portfolio, seller: VotingSchema.this.Portfolio, deriv: model.Derivative, price: model.Dollars): VotingSchema.this.Transaction[(VotingSchema.this.DerivativeBuyerSetAside, VotingSchema.this.DerivativeSellerSetAside)] = VotingSchema.this.toOps[VotingSchema.this.DerivativeBuyerSetAside]({
  val x$3: model.Link[VotingSchema.this.Portfolio] = model.this.KL.toLink[VotingSchema.this.Portfolio](buyer);
  val x$4: model.Link[VotingSchema.this.Portfolio] = model.this.KL.toLink[VotingSchema.this.Portfolio](seller);
  val x$5: model.Derivative = deriv;
  val x$6: model.Dollars = price;
  val x$7: model.Scale = VotingSchema.this.setAsideFraction;
  val x$8: model.package.Key = VotingSchema.this.DerivativeBuyerSetAside.apply$default$1;
  new VotingSchema.this.DerivativeBuyerSetAside(x$8, x$3, x$4, x$5, x$6, x$7)
}).insert(VotingSchema.this.derivativeBuyerSetAsides).flatMap[(VotingSchema.this.DerivativeBuyerSetAside, VotingSchema.this.DerivativeSellerSetAside)](((buyerSetAside: VotingSchema.this.DerivativeBuyerSetAside) => VotingSchema.this.toOps[VotingSchema.this.DerivativeSellerSetAside]({
  val x$9: model.Link[VotingSchema.this.Portfolio] = model.this.KL.toLink[VotingSchema.this.Portfolio](buyer);
  val x$10: model.Link[VotingSchema.this.Portfolio] = model.this.KL.toLink[VotingSchema.this.Portfolio](seller);
  val x$11: model.Derivative = deriv;
  val x$12: model.Dollars = price;
  val x$13: model.Scale = VotingSchema.this.setAsideFraction;
  val x$14: model.package.Key = VotingSchema.this.DerivativeSellerSetAside.apply$default$1;
  new VotingSchema.this.DerivativeSellerSetAside(x$14, x$9, x$10, x$11, x$12, x$13)
}).insert(VotingSchema.this.derivativeSellerSetAsides).map[(VotingSchema.this.DerivativeBuyerSetAside, VotingSchema.this.DerivativeSellerSetAside)](((sellerSetAside: VotingSchema.this.DerivativeSellerSetAside) => new (VotingSchema.this.DerivativeBuyerSetAside, VotingSchema.this.DerivativeSellerSetAside)(buyerSetAside, sellerSetAside)))))
}
PortfolioWithVotes: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.367
          voteUp userVot setupSe userVot voteDow

final object NewsEvent extends java.lang.Object with ScalaObject with Serializable {
  def this(): object NewsSchema.this.NewsEvent = {
    NewsEvent.super.this();
    ()
  };
  def byID(id: model.package.Key): NewsSchema.this.NewsEvent = NewsSchema.this.newsEvents.lookup(id).getOrElse[NewsSchema.this.NewsEvent](throw NewsSchema.this.NoSuchEvent);
  <synthetic> def init$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
  <synthetic> def apply$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
  case <synthetic> def unapply(x$0: NewsSchema.this.NewsEvent): Option[(model.package.Key, org.joda.time.DateTime, NewsSchema.this.Action)] = if (x$0.==(null))
    scala.this.None
  else
    new Some[(model.package.Key, org.joda.time.DateTime, NewsSchema.this.Action)](new (model.package.Key, org.joda.time.DateTime, NewsSchema.this.Action)(x$0.id, x$0.when, x$0.action));
  case <synthetic> def apply(id: model.package.Key = model.this.`package`.nextID, when: org.joda.time.DateTime, action: NewsSchema.this.Action): NewsSchema.this.NewsEvent = new NewsSchema.this.NewsEvent(id, when, action)
}
NewsEvent: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
            byID

class TextAreaField extends intform.Field[String] with intform.TextAreaRender with ScalaObject {
  <paramaccessor> private[this] val initText: String = _;
  <stable> <accessor> <paramaccessor> def initText: String = TextAreaField.this.initText;
  def this(initText: String): intform.TextAreaField = {
    TextAreaField.super.this();
    ()
  };
  private[this] var text: String = TextAreaField.this.initText;
  <accessor> def text: String = TextAreaField.this.text;
  <accessor> def text_=(x$1: String): Unit = TextAreaField.this.text = x$1;
  def produce(): intform.OK[String] = new intform.OK[String](TextAreaField.this.text);
  def reset(): Unit = TextAreaField.this.text_=(TextAreaField.this.initText)
}
TextAreaField: SCOM=1.000 CC=0.500 LSCC=0.500 CAMC=1.000
           reset produce
    text     X       X  
 initTex     X          

class HttpQueryService extends java.lang.Object with stockdata.QueryService with net.liftweb.common.Loggable with ScalaObject {
  <paramaccessor> private[this] val method: String = _;
  def this(method: String): stockdata.HttpQueryService = {
    HttpQueryService.super.this();
    ()
  };
  def query(url: java.net.URL): String = {
    val connection: java.net.HttpURLConnection = url.openConnection().asInstanceOf[java.net.HttpURLConnection];
    connection.setRequestMethod(HttpQueryService.this.method);
    val responseCode: Int = connection.getResponseCode();
    if (responseCode.!=(200))
      {
        HttpQueryService.this.logger.error("Querying failed");
        HttpQueryService.this.logger.error(scala.io.Source.fromInputStream(connection.getInputStream())(io.this.Codec.fallbackSystemCodec).mkString);
        throw new java.io.IOException(scala.this.Predef.augmentString("Request returned response code %s.").format(responseCode))
      }
    else
      ();
    val responseStream: java.io.InputStream = connection.getInputStream();
    val responseString: String = scala.io.Source.fromInputStream(responseStream)(io.this.Codec.fallbackSystemCodec).mkString;
    connection.disconnect();
    responseString
  }
}
HttpQueryService: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
           query
  method     X  

final class $anon extends java.lang.Object with texttrading.Reply {
  def this(): anonymous class $anon = {
    $anon.super.this();
    ()
  };
  def reply(text: String): Unit = scala.this.Predef.println(text)
}
$anon: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
           reply

abstract class Field[A >: Nothing <: Any] extends java.lang.Object with intform.BasicErrors with ScalaObject {
  def this(): intform.Field[A] = {
    Field.super.this();
    ()
  };
  def produce(): intform.SubmitResult[A];
  def process(): Option[A] = Field.this.produce() match {
    case (res: A)intform.OK[A]((a @ _)) => {
      Field.this.error_=(scala.None);
      new Some[A](a)
    }
    case (msg: String)intform.Error((msg @ _)) => {
      Field.this.error_=(new Some[String](msg));
      scala.None
    }
    case ChildError => {
      Field.this.error_=(scala.None);
      scala.None
    }
  };
  def reset(): Unit
}
Field: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
         process
   reset        
 produce     X  

final object package extends java.lang.Object with ScalaObject {
  def this(): object sessions.package = {
    package.super.this();
    ()
  };
  class ColonEq[A >: Nothing <: Any] extends java.lang.Object with ScalaObject {
    <paramaccessor> private[this] val c: net.liftweb.http.SessionVar[A] = _;
    def this(c: net.liftweb.http.SessionVar[A]): sessions.package.ColonEq[A] = {
      ColonEq.super.this();
      ()
    };
    def :=(a: A): A = ColonEq.this.c.apply(a)
  };
  implicit def toColon[A >: Nothing <: Any](c: net.liftweb.http.SessionVar[A]): sessions.package.ColonEq[A] = new sessions.package.ColonEq[A](c)
}
package: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
         toColon

final object DividendSource extends stockdata.CachedDividendDatabase with ScalaObject {
  def this(): object model.DividendSource = {
    DividendSource.super.this(new stockdata.YahooDividendDatabase(new stockdata.HttpQueryService("GET")));
    ()
  }
}
DividendSource: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

case class QuoteInfo extends java.lang.Object with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val percentChange: Option[BigDecimal] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def percentChange: Option[BigDecimal] = QuoteInfo.this.percentChange;
  <caseaccessor> <paramaccessor> private[this] val openPrice: Option[BigDecimal] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def openPrice: Option[BigDecimal] = QuoteInfo.this.openPrice;
  <caseaccessor> <paramaccessor> private[this] val lowPrice: Option[BigDecimal] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def lowPrice: Option[BigDecimal] = QuoteInfo.this.lowPrice;
  <caseaccessor> <paramaccessor> private[this] val highPrice: Option[BigDecimal] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def highPrice: Option[BigDecimal] = QuoteInfo.this.highPrice;
  <caseaccessor> <paramaccessor> private[this] val dividendShare: Option[BigDecimal] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def dividendShare: Option[BigDecimal] = QuoteInfo.this.dividendShare;
  def this(percentChange: Option[BigDecimal], openPrice: Option[BigDecimal], lowPrice: Option[BigDecimal], highPrice: Option[BigDecimal], dividendShare: Option[BigDecimal]): stockdata.QuoteInfo = {
    QuoteInfo.super.this();
    ()
  };
  <synthetic> def copy(percentChange: Option[BigDecimal] = percentChange, openPrice: Option[BigDecimal] = openPrice, lowPrice: Option[BigDecimal] = lowPrice, highPrice: Option[BigDecimal] = highPrice, dividendShare: Option[BigDecimal] = dividendShare): stockdata.QuoteInfo = new stockdata.this.QuoteInfo(percentChange, openPrice, lowPrice, highPrice, dividendShare);
  <synthetic> def copy$default$5: Option[BigDecimal] @scala.annotation.unchecked.uncheckedVariance = QuoteInfo.this.dividendShare;
  <synthetic> def copy$default$4: Option[BigDecimal] @scala.annotation.unchecked.uncheckedVariance = QuoteInfo.this.highPrice;
  <synthetic> def copy$default$3: Option[BigDecimal] @scala.annotation.unchecked.uncheckedVariance = QuoteInfo.this.lowPrice;
  <synthetic> def copy$default$2: Option[BigDecimal] @scala.annotation.unchecked.uncheckedVariance = QuoteInfo.this.openPrice;
  <synthetic> def copy$default$1: Option[BigDecimal] @scala.annotation.unchecked.uncheckedVariance = QuoteInfo.this.percentChange;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(QuoteInfo.this);
  override def toString(): String = ScalaRunTime.this._toString(QuoteInfo.this);
  override def equals(x$1: Any): Boolean = QuoteInfo.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (percentChange: Option[BigDecimal], openPrice: Option[BigDecimal], lowPrice: Option[BigDecimal], highPrice: Option[BigDecimal], dividendShare: Option[BigDecimal])stockdata.QuoteInfo((percentChange$1 @ _), (openPrice$1 @ _), (lowPrice$1 @ _), (highPrice$1 @ _), (dividendShare$1 @ _)) if percentChange$1.==(percentChange).&&(openPrice$1.==(openPrice)).&&(lowPrice$1.==(lowPrice)).&&(highPrice$1.==(highPrice)).&&(dividendShare$1.==(dividendShare)) => x$1.asInstanceOf[stockdata.QuoteInfo].canEqual(QuoteInfo.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "QuoteInfo";
  override def productArity: Int = 5;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => percentChange
    case 1 => openPrice
    case 2 => lowPrice
    case 3 => highPrice
    case 4 => dividendShare
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[stockdata.QuoteInfo]()
}
QuoteInfo: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
 openPri
 highPri
 dividen
 percent
 lowPric

final object UserField extends java.lang.Object with ScalaObject {
  def this(): object code.snippet.UserField = {
    UserField.super.this();
    ()
  };
  def apply(i: String = ""): code.snippet.UserField = new UserField(i);
  <synthetic> def apply$default$1: String @scala.annotation.unchecked.uncheckedVariance = ""
}
UserField: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
           apply

final object PortfolioField extends java.lang.Object with ScalaObject {
  def this(): object code.snippet.PortfolioField = {
    PortfolioField.super.this();
    ()
  };
  def apply(i: String = ""): code.snippet.PortfolioField = new PortfolioField(i);
  <synthetic> def apply$default$1: String @scala.annotation.unchecked.uncheckedVariance = ""
}
PortfolioField: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
           apply

abstract trait DBMagic extends java.lang.Object with model.Transactions with ScalaObject {
  def /*DBMagic*/$init$(): Unit = {
    ()
  };
  private[this] var tables: Seq[model.Table[_]] = collection.this.Seq.apply[Nothing]();
  <accessor> def tables: Seq[model.Table[_]] = DBMagic.this.tables;
  <accessor> def tables_=(x$1: Seq[model.Table[_]]): Unit = DBMagic.this.tables = x$1;
  def table[R >: Nothing <: model.KL]: model.Table[R] = {
    val t: model.Table[R] = new model.Table[R]();
    DBMagic.this.tables_=(DBMagic.this.tables.:+[model.Table[_], Seq[model.Table[_]]](t)(collection.this.Seq.canBuildFrom[model.Table[_]]));
    t
  }
}
DBMagic: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
           table
  tables     X  

final object email extends  {
  def this() = _;
  <static> def main(args: scala.Array[String] = _): Unit = _
}
email: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
            main

final object PortfolioLink extends java.lang.Object with ScalaObject {
  def this(): object code.snippet.PortfolioLink = {
    PortfolioLink.super.this();
    ()
  };
  def apply(port: model.schema.Portfolio): scala.xml.NodeSeq = model.schema.readDB[scala.xml.NodeSeq]({
    val name: String = port.name;
    val wealth: model.Dollars = port.spotValue;
    val rank: Int = port.rank;
    val big: Boolean = rank.<=(10);
    val standing: scala.xml.Elem = if (big)
      {
        {
          new scala.xml.Elem(null, "span", scala.xml.Null, scala.this.Predef.$scope, ({
            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
            $buf.&+(new scala.xml.Text("(#"));
            $buf.&+(rank);
            $buf.&+(new scala.xml.Text(" "));
            $buf.&+(wealth.$short);
            $buf.&+(new scala.xml.Text(")"));
            $buf
          }: _*))
        }
      }
    else
      {
        {
          new scala.xml.Elem(null, "span", scala.xml.Null, scala.this.Predef.$scope, ({
            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
            $buf.&+(new scala.xml.Text("("));
            $buf.&+(wealth.$short);
            $buf.&+(new scala.xml.Text(")"));
            $buf
          }: _*))
        }
      };
    if (big)
      {
        {
          var $md: scala.xml.MetaData = scala.xml.Null;
          $md = new scala.xml.UnprefixedAttribute("href", scala.this.Predef.augmentString("/portfolio?name=%s").format(name), $md);
          $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("big-name"), $md);
          new scala.xml.Elem(null, "a", $md, scala.this.Predef.$scope, ({
            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
            $buf.&+(name);
            $buf.&+(new scala.xml.Text(" "));
            $buf.&+(standing);
            $buf
          }: _*))
        }
      }
    else
      {
        {
          var $md: scala.xml.MetaData = scala.xml.Null;
          $md = new scala.xml.UnprefixedAttribute("href", scala.this.Predef.augmentString("/portfolio?name=%s").format(name), $md);
          new scala.xml.Elem(null, "a", $md, scala.this.Predef.$scope, ({
            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
            $buf.&+(name);
            $buf.&+(new scala.xml.Text(" "));
            $buf.&+(standing);
            $buf
          }: _*))
        }
      }
  })
}
PortfolioLink: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
           apply

final case object ChildError extends intform.SubmitResult[Nothing] with ScalaObject with Product with Serializable {
  def this(): object intform.ChildError = {
    ChildError.super.this();
    ()
  };
  final override def hashCode(): Int = -970417556;
  final override def toString(): java.lang.String = "ChildError";
  override def productPrefix: java.lang.String = "ChildError";
  override def productArity: Int = 0;
  override def productElement(x$1: Int): Any = x$1 match {
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[object intform.ChildError]();
  protected def readResolve(): java.lang.Object = intform.this.ChildError
}
ChildError: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
         readRes

final case object NoSuchEvent extends java.lang.RuntimeException with errors.package.BadUser with ScalaObject with Product with Serializable {
  def this(): object SchemaErrors.this.NoSuchEvent = {
    NoSuchEvent.super.this();
    ()
  };
  final override def hashCode(): Int = 2387890;
  override def productPrefix: java.lang.String = "NoSuchEvent";
  override def productArity: Int = 0;
  override def productElement(x$1: Int): Any = x$1 match {
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[object SchemaErrors.this.NoSuchEvent]()
}
NoSuchEvent: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

class FailoverStockDatabase extends java.lang.Object with stockdata.StockDatabase with net.liftweb.common.Loggable with ScalaObject {
  <paramaccessor> private[this] val databases: List[stockdata.StockDatabase] = _;
  def this(databases: List[stockdata.StockDatabase]): stockdata.FailoverStockDatabase = {
    FailoverStockDatabase.super.this();
    ()
  };
  case class ResponseOption extends java.lang.Object with ScalaObject with Product with Serializable {
    def this(): FailoverStockDatabase.this.ResponseOption = {
      ResponseOption.super.this();
      ()
    };
    override def hashCode(): Int = ScalaRunTime.this._hashCode(ResponseOption.this);
    override def toString(): String = ScalaRunTime.this._toString(ResponseOption.this);
    override def equals(x$1: Any): Boolean = ResponseOption.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case ()FailoverStockDatabase.this.ResponseOption() => x$1.asInstanceOf[FailoverStockDatabase.this.ResponseOption].canEqual(ResponseOption.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "ResponseOption";
    override def productArity: Int = 0;
    override def productElement(x$1: Int): Any = x$1 match {
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[FailoverStockDatabase.this.ResponseOption]()
  };
  final <synthetic> object ResponseOption extends scala.runtime.AbstractFunction0[FailoverStockDatabase.this.ResponseOption] with ScalaObject with Serializable {
    def this(): object FailoverStockDatabase.this.ResponseOption = {
      ResponseOption.super.this();
      ()
    };
    final override def toString(): java.lang.String = "ResponseOption";
    case <synthetic> def unapply(x$0: FailoverStockDatabase.this.ResponseOption): Boolean = if (x$0.==(null))
      false
    else
      true;
    case <synthetic> def apply(): FailoverStockDatabase.this.ResponseOption = new FailoverStockDatabase.this.ResponseOption()
  };
  @volatile <synthetic> private[this] var ResponseOption$module: object FailoverStockDatabase.this.ResponseOption = _;
  final <synthetic> <stable> def ResponseOption: object FailoverStockDatabase.this.ResponseOption = {
    FailoverStockDatabase.this.ResponseOption$module = new object FailoverStockDatabase.this.ResponseOption();
    FailoverStockDatabase.this.ResponseOption$module
  };
  case class ResponseValid extends java.lang.Object with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val quotes: Iterable[stockdata.Quote] = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def quotes: Iterable[stockdata.Quote] = ResponseValid.this.quotes;
    def this(quotes: Iterable[stockdata.Quote]): FailoverStockDatabase.this.ResponseValid = {
      ResponseValid.super.this();
      ()
    };
    <synthetic> def copy(quotes: Iterable[stockdata.Quote] = quotes): FailoverStockDatabase.this.ResponseValid = new FailoverStockDatabase.this.ResponseValid(quotes);
    <synthetic> def copy$default$1: Iterable[stockdata.Quote] @scala.annotation.unchecked.uncheckedVariance = ResponseValid.this.quotes;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(ResponseValid.this);
    override def toString(): String = ScalaRunTime.this._toString(ResponseValid.this);
    override def equals(x$1: Any): Boolean = ResponseValid.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (quotes: Iterable[stockdata.Quote])FailoverStockDatabase.this.ResponseValid((quotes$1 @ _)) if quotes$1.==(quotes) => x$1.asInstanceOf[FailoverStockDatabase.this.ResponseValid].canEqual(ResponseValid.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "ResponseValid";
    override def productArity: Int = 1;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => quotes
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[FailoverStockDatabase.this.ResponseValid]()
  };
  final <synthetic> object ResponseValid extends scala.runtime.AbstractFunction1[Iterable[stockdata.Quote],FailoverStockDatabase.this.ResponseValid] with ScalaObject with Serializable {
    def this(): object FailoverStockDatabase.this.ResponseValid = {
      ResponseValid.super.this();
      ()
    };
    final override def toString(): java.lang.String = "ResponseValid";
    case <synthetic> def unapply(x$0: FailoverStockDatabase.this.ResponseValid): Option[Iterable[stockdata.Quote]] = if (x$0.==(null))
      scala.this.None
    else
      new Some[Iterable[stockdata.Quote]](x$0.quotes);
    case <synthetic> def apply(quotes: Iterable[stockdata.Quote]): FailoverStockDatabase.this.ResponseValid = new FailoverStockDatabase.this.ResponseValid(quotes)
  };
  @volatile <synthetic> private[this] var ResponseValid$module: object FailoverStockDatabase.this.ResponseValid = _;
  final <synthetic> <stable> def ResponseValid: object FailoverStockDatabase.this.ResponseValid = {
    FailoverStockDatabase.this.ResponseValid$module = new object FailoverStockDatabase.this.ResponseValid();
    FailoverStockDatabase.this.ResponseValid$module
  };
  case class ResponseError extends java.lang.Object with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val error: Throwable = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def error: Throwable = ResponseError.this.error;
    def this(error: Throwable): FailoverStockDatabase.this.ResponseError = {
      ResponseError.super.this();
      ()
    };
    <synthetic> def copy(error: Throwable = error): FailoverStockDatabase.this.ResponseError = new FailoverStockDatabase.this.ResponseError(error);
    <synthetic> def copy$default$1: Throwable @scala.annotation.unchecked.uncheckedVariance = ResponseError.this.error;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(ResponseError.this);
    override def toString(): String = ScalaRunTime.this._toString(ResponseError.this);
    override def equals(x$1: Any): Boolean = ResponseError.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (error: Throwable)FailoverStockDatabase.this.ResponseError((error$1 @ _)) if error$1.==(error) => x$1.asInstanceOf[FailoverStockDatabase.this.ResponseError].canEqual(ResponseError.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "ResponseError";
    override def productArity: Int = 1;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => error
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[FailoverStockDatabase.this.ResponseError]()
  };
  final <synthetic> object ResponseError extends scala.runtime.AbstractFunction1[Throwable,FailoverStockDatabase.this.ResponseError] with ScalaObject with Serializable {
    def this(): object FailoverStockDatabase.this.ResponseError = {
      ResponseError.super.this();
      ()
    };
    final override def toString(): java.lang.String = "ResponseError";
    case <synthetic> def unapply(x$0: FailoverStockDatabase.this.ResponseError): Option[Throwable] = if (x$0.==(null))
      scala.this.None
    else
      new Some[Throwable](x$0.error);
    case <synthetic> def apply(error: Throwable): FailoverStockDatabase.this.ResponseError = new FailoverStockDatabase.this.ResponseError(error)
  };
  @volatile <synthetic> private[this] var ResponseError$module: object FailoverStockDatabase.this.ResponseError = _;
  final <synthetic> <stable> def ResponseError: object FailoverStockDatabase.this.ResponseError = {
    FailoverStockDatabase.this.ResponseError$module = new object FailoverStockDatabase.this.ResponseError();
    FailoverStockDatabase.this.ResponseError$module
  };
  def getQuotes(stocks: Iterable[stockdata.Stock]): Iterable[stockdata.Quote] = {
    var error: Throwable = new DatabaseException("No stock databases were specified", null);
    FailoverStockDatabase.this.databases.foreach[Unit](((database: stockdata.StockDatabase) => FailoverStockDatabase.this.tryQueryDatabase(database, stocks) match {
      case (quotes: Iterable[stockdata.Quote])FailoverStockDatabase.this.ResponseValid((quotes @ _)) => return quotes
      case (error: Throwable)FailoverStockDatabase.this.ResponseError((ex @ _)) => {
        FailoverStockDatabase.this.logger.error("Database Query failed with error.");
        error = ex
      }
    }));
    FailoverStockDatabase.this.logger.error("All database queries failed.");
    throw error
  };
  def tryQueryDatabase(database: stockdata.StockDatabase, stocks: Iterable[stockdata.Stock]): Product with Serializable = try {
    new FailoverStockDatabase.this.ResponseValid(database.getQuotes(stocks))
  } catch {
    case (ex @ (_: Throwable)) => new FailoverStockDatabase.this.ResponseError(ex)
  }
}
FailoverStockDatabase: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.750
         tryQuer getQuot
 Respons                
 Respons                
 Respons                
 databas             X  

case class StockShares extends StockAsset with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val ticker: String = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def ticker: String = StockShares.this.ticker;
  <caseaccessor> <paramaccessor> private[this] val shares: model.Shares = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def shares: model.Shares = StockShares.this.shares;
  def this(ticker: String, shares: model.Shares): texttrading.StockShares = {
    StockShares.super.this();
    ()
  };
  override def toString: java.lang.String = scala.this.Predef.any2stringadd(StockShares.this.shares).+(" of ").+(StockShares.this.ticker);
  <synthetic> def copy(ticker: String = ticker, shares: model.Shares = shares): texttrading.StockShares = new texttrading.this.StockShares(ticker, shares);
  <synthetic> def copy$default$2: model.Shares @scala.annotation.unchecked.uncheckedVariance = StockShares.this.shares;
  <synthetic> def copy$default$1: String @scala.annotation.unchecked.uncheckedVariance = StockShares.this.ticker;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(StockShares.this);
  override def equals(x$1: Any): Boolean = StockShares.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (ticker: String, shares: model.Shares)texttrading.StockShares((ticker$4 @ _), (shares$1 @ _)) if ticker$4.==(ticker).&&(shares$1.==(shares)) => x$1.asInstanceOf[texttrading.StockShares].canEqual(StockShares.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "StockShares";
  override def productArity: Int = 2;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => ticker
    case 1 => shares
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[texttrading.StockShares]()
}
StockShares: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
  shares
  ticker

abstract trait VotingSchema extends java.lang.Object with ScalaObject { self: model.VotingSchema with model.DBMagic with model.UserSchema with model.DerivativeSchema with model.NewsSchema => 
  def /*VotingSchema*/$init$(): Unit = {
    ()
  };
  private[this] val setAsideFraction: model.Scale = Scale.apply("0.03");
  <stable> <accessor> def setAsideFraction: model.Scale = VotingSchema.this.setAsideFraction;
  private[this] val derivativeBuyerSetAsides: model.Table[VotingSchema.this.DerivativeBuyerSetAside] = VotingSchema.this.table[VotingSchema.this.DerivativeBuyerSetAside];
  implicit <stable> <accessor> def derivativeBuyerSetAsides: model.Table[VotingSchema.this.DerivativeBuyerSetAside] = VotingSchema.this.derivativeBuyerSetAsides;
  private[this] val derivativeSellerSetAsides: model.Table[VotingSchema.this.DerivativeSellerSetAside] = VotingSchema.this.table[VotingSchema.this.DerivativeSellerSetAside];
  implicit <stable> <accessor> def derivativeSellerSetAsides: model.Table[VotingSchema.this.DerivativeSellerSetAside] = VotingSchema.this.derivativeSellerSetAsides;
  private[this] val derivativeBuyerVotes: model.Table[VotingSchema.this.DerivativeBuyerVote] = VotingSchema.this.table[VotingSchema.this.DerivativeBuyerVote];
  implicit <stable> <accessor> def derivativeBuyerVotes: model.Table[VotingSchema.this.DerivativeBuyerVote] = VotingSchema.this.derivativeBuyerVotes;
  private[this] val derivativeSellerVotes: model.Table[VotingSchema.this.DerivativeSellerVote] = VotingSchema.this.table[VotingSchema.this.DerivativeSellerVote];
  implicit <stable> <accessor> def derivativeSellerVotes: model.Table[VotingSchema.this.DerivativeSellerVote] = VotingSchema.this.derivativeSellerVotes;
  case class DerivativeBuyerSetAside extends java.lang.Object with model.KL with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val id: model.package.Key = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def id: model.package.Key = DerivativeBuyerSetAside.this.id;
    <caseaccessor> <paramaccessor> private[this] val buyer: model.Link[VotingSchema.this.Portfolio] = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def buyer: model.Link[VotingSchema.this.Portfolio] = DerivativeBuyerSetAside.this.buyer;
    <caseaccessor> <paramaccessor> private[this] val seller: model.Link[VotingSchema.this.Portfolio] = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def seller: model.Link[VotingSchema.this.Portfolio] = DerivativeBuyerSetAside.this.seller;
    <caseaccessor> <paramaccessor> private[this] val derivative: model.Derivative = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def derivative: model.Derivative = DerivativeBuyerSetAside.this.derivative;
    <caseaccessor> <paramaccessor> private[this] val price: model.Dollars = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def price: model.Dollars = DerivativeBuyerSetAside.this.price;
    <caseaccessor> <paramaccessor> private[this] val remaining: model.Scale = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def remaining: model.Scale = DerivativeBuyerSetAside.this.remaining;
    def this(id: model.package.Key = model.this.`package`.nextID, buyer: model.Link[VotingSchema.this.Portfolio], seller: model.Link[VotingSchema.this.Portfolio], derivative: model.Derivative, price: model.Dollars, remaining: model.Scale): VotingSchema.this.DerivativeBuyerSetAside = {
      DerivativeBuyerSetAside.super.this();
      ()
    };
    <synthetic> def copy(id: model.package.Key = id, buyer: model.Link[VotingSchema.this.Portfolio] = buyer, seller: model.Link[VotingSchema.this.Portfolio] = seller, derivative: model.Derivative = derivative, price: model.Dollars = price, remaining: model.Scale = remaining): VotingSchema.this.DerivativeBuyerSetAside = new VotingSchema.this.DerivativeBuyerSetAside(id, buyer, seller, derivative, price, remaining);
    <synthetic> def copy$default$6: model.Scale @scala.annotation.unchecked.uncheckedVariance = DerivativeBuyerSetAside.this.remaining;
    <synthetic> def copy$default$5: model.Dollars @scala.annotation.unchecked.uncheckedVariance = DerivativeBuyerSetAside.this.price;
    <synthetic> def copy$default$4: model.Derivative @scala.annotation.unchecked.uncheckedVariance = DerivativeBuyerSetAside.this.derivative;
    <synthetic> def copy$default$3: model.Link[VotingSchema.this.Portfolio] @scala.annotation.unchecked.uncheckedVariance = DerivativeBuyerSetAside.this.seller;
    <synthetic> def copy$default$2: model.Link[VotingSchema.this.Portfolio] @scala.annotation.unchecked.uncheckedVariance = DerivativeBuyerSetAside.this.buyer;
    <synthetic> def copy$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = DerivativeBuyerSetAside.this.id;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(DerivativeBuyerSetAside.this);
    override def toString(): String = ScalaRunTime.this._toString(DerivativeBuyerSetAside.this);
    override def equals(x$1: Any): Boolean = DerivativeBuyerSetAside.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (id: model.package.Key, buyer: model.Link[VotingSchema.this.Portfolio], seller: model.Link[VotingSchema.this.Portfolio], derivative: model.Derivative, price: model.Dollars, remaining: model.Scale)VotingSchema.this.DerivativeBuyerSetAside((id$1 @ _), (buyer$1 @ _), (seller$1 @ _), (derivative$1 @ _), (price$1 @ _), (remaining$1 @ _)) if id$1.==(id).&&(buyer$1.==(buyer)).&&(seller$1.==(seller)).&&(derivative$1.==(derivative)).&&(price$1.==(price)).&&(remaining$1.==(remaining)) => x$1.asInstanceOf[VotingSchema.this.DerivativeBuyerSetAside].canEqual(DerivativeBuyerSetAside.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "DerivativeBuyerSetAside";
    override def productArity: Int = 6;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => id
      case 1 => buyer
      case 2 => seller
      case 3 => derivative
      case 4 => price
      case 5 => remaining
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[VotingSchema.this.DerivativeBuyerSetAside]()
  };
  final <synthetic> object DerivativeBuyerSetAside extends scala.runtime.AbstractFunction6[model.package.Key,model.Link[VotingSchema.this.Portfolio],model.Link[VotingSchema.this.Portfolio],model.Derivative,model.Dollars,model.Scale,VotingSchema.this.DerivativeBuyerSetAside] with ScalaObject with Serializable {
    def this(): object VotingSchema.this.DerivativeBuyerSetAside = {
      DerivativeBuyerSetAside.super.this();
      ()
    };
    final override def toString(): java.lang.String = "DerivativeBuyerSetAside";
    <synthetic> def init$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
    <synthetic> def apply$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
    case <synthetic> def unapply(x$0: VotingSchema.this.DerivativeBuyerSetAside): Option[(model.package.Key, model.Link[VotingSchema.this.Portfolio], model.Link[VotingSchema.this.Portfolio], model.Derivative, model.Dollars, model.Scale)] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(model.package.Key, model.Link[VotingSchema.this.Portfolio], model.Link[VotingSchema.this.Portfolio], model.Derivative, model.Dollars, model.Scale)](new (model.package.Key, model.Link[VotingSchema.this.Portfolio], model.Link[VotingSchema.this.Portfolio], model.Derivative, model.Dollars, model.Scale)(x$0.id, x$0.buyer, x$0.seller, x$0.derivative, x$0.price, x$0.remaining));
    case <synthetic> def apply(id: model.package.Key = model.this.`package`.nextID, buyer: model.Link[VotingSchema.this.Portfolio], seller: model.Link[VotingSchema.this.Portfolio], derivative: model.Derivative, price: model.Dollars, remaining: model.Scale): VotingSchema.this.DerivativeBuyerSetAside = new VotingSchema.this.DerivativeBuyerSetAside(id, buyer, seller, derivative, price, remaining)
  };
  @volatile <synthetic> private[this] var DerivativeBuyerSetAside$module: object VotingSchema.this.DerivativeBuyerSetAside = _;
  final <synthetic> <stable> def DerivativeBuyerSetAside: object VotingSchema.this.DerivativeBuyerSetAside = new object VotingSchema.this.DerivativeBuyerSetAside();
  case class DerivativeSellerSetAside extends java.lang.Object with model.KL with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val id: model.package.Key = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def id: model.package.Key = DerivativeSellerSetAside.this.id;
    <caseaccessor> <paramaccessor> private[this] val buyer: model.Link[VotingSchema.this.Portfolio] = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def buyer: model.Link[VotingSchema.this.Portfolio] = DerivativeSellerSetAside.this.buyer;
    <caseaccessor> <paramaccessor> private[this] val seller: model.Link[VotingSchema.this.Portfolio] = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def seller: model.Link[VotingSchema.this.Portfolio] = DerivativeSellerSetAside.this.seller;
    <caseaccessor> <paramaccessor> private[this] val derivative: model.Derivative = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def derivative: model.Derivative = DerivativeSellerSetAside.this.derivative;
    <caseaccessor> <paramaccessor> private[this] val price: model.Dollars = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def price: model.Dollars = DerivativeSellerSetAside.this.price;
    <caseaccessor> <paramaccessor> private[this] val remaining: model.Scale = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def remaining: model.Scale = DerivativeSellerSetAside.this.remaining;
    def this(id: model.package.Key = model.this.`package`.nextID, buyer: model.Link[VotingSchema.this.Portfolio], seller: model.Link[VotingSchema.this.Portfolio], derivative: model.Derivative, price: model.Dollars, remaining: model.Scale): VotingSchema.this.DerivativeSellerSetAside = {
      DerivativeSellerSetAside.super.this();
      ()
    };
    <synthetic> def copy(id: model.package.Key = id, buyer: model.Link[VotingSchema.this.Portfolio] = buyer, seller: model.Link[VotingSchema.this.Portfolio] = seller, derivative: model.Derivative = derivative, price: model.Dollars = price, remaining: model.Scale = remaining): VotingSchema.this.DerivativeSellerSetAside = new VotingSchema.this.DerivativeSellerSetAside(id, buyer, seller, derivative, price, remaining);
    <synthetic> def copy$default$6: model.Scale @scala.annotation.unchecked.uncheckedVariance = DerivativeSellerSetAside.this.remaining;
    <synthetic> def copy$default$5: model.Dollars @scala.annotation.unchecked.uncheckedVariance = DerivativeSellerSetAside.this.price;
    <synthetic> def copy$default$4: model.Derivative @scala.annotation.unchecked.uncheckedVariance = DerivativeSellerSetAside.this.derivative;
    <synthetic> def copy$default$3: model.Link[VotingSchema.this.Portfolio] @scala.annotation.unchecked.uncheckedVariance = DerivativeSellerSetAside.this.seller;
    <synthetic> def copy$default$2: model.Link[VotingSchema.this.Portfolio] @scala.annotation.unchecked.uncheckedVariance = DerivativeSellerSetAside.this.buyer;
    <synthetic> def copy$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = DerivativeSellerSetAside.this.id;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(DerivativeSellerSetAside.this);
    override def toString(): String = ScalaRunTime.this._toString(DerivativeSellerSetAside.this);
    override def equals(x$1: Any): Boolean = DerivativeSellerSetAside.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (id: model.package.Key, buyer: model.Link[VotingSchema.this.Portfolio], seller: model.Link[VotingSchema.this.Portfolio], derivative: model.Derivative, price: model.Dollars, remaining: model.Scale)VotingSchema.this.DerivativeSellerSetAside((id$2 @ _), (buyer$2 @ _), (seller$2 @ _), (derivative$2 @ _), (price$2 @ _), (remaining$2 @ _)) if id$2.==(id).&&(buyer$2.==(buyer)).&&(seller$2.==(seller)).&&(derivative$2.==(derivative)).&&(price$2.==(price)).&&(remaining$2.==(remaining)) => x$1.asInstanceOf[VotingSchema.this.DerivativeSellerSetAside].canEqual(DerivativeSellerSetAside.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "DerivativeSellerSetAside";
    override def productArity: Int = 6;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => id
      case 1 => buyer
      case 2 => seller
      case 3 => derivative
      case 4 => price
      case 5 => remaining
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[VotingSchema.this.DerivativeSellerSetAside]()
  };
  final <synthetic> object DerivativeSellerSetAside extends scala.runtime.AbstractFunction6[model.package.Key,model.Link[VotingSchema.this.Portfolio],model.Link[VotingSchema.this.Portfolio],model.Derivative,model.Dollars,model.Scale,VotingSchema.this.DerivativeSellerSetAside] with ScalaObject with Serializable {
    def this(): object VotingSchema.this.DerivativeSellerSetAside = {
      DerivativeSellerSetAside.super.this();
      ()
    };
    final override def toString(): java.lang.String = "DerivativeSellerSetAside";
    <synthetic> def init$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
    <synthetic> def apply$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
    case <synthetic> def unapply(x$0: VotingSchema.this.DerivativeSellerSetAside): Option[(model.package.Key, model.Link[VotingSchema.this.Portfolio], model.Link[VotingSchema.this.Portfolio], model.Derivative, model.Dollars, model.Scale)] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(model.package.Key, model.Link[VotingSchema.this.Portfolio], model.Link[VotingSchema.this.Portfolio], model.Derivative, model.Dollars, model.Scale)](new (model.package.Key, model.Link[VotingSchema.this.Portfolio], model.Link[VotingSchema.this.Portfolio], model.Derivative, model.Dollars, model.Scale)(x$0.id, x$0.buyer, x$0.seller, x$0.derivative, x$0.price, x$0.remaining));
    case <synthetic> def apply(id: model.package.Key = model.this.`package`.nextID, buyer: model.Link[VotingSchema.this.Portfolio], seller: model.Link[VotingSchema.this.Portfolio], derivative: model.Derivative, price: model.Dollars, remaining: model.Scale): VotingSchema.this.DerivativeSellerSetAside = new VotingSchema.this.DerivativeSellerSetAside(id, buyer, seller, derivative, price, remaining)
  };
  @volatile <synthetic> private[this] var DerivativeSellerSetAside$module: object VotingSchema.this.DerivativeSellerSetAside = _;
  final <synthetic> <stable> def DerivativeSellerSetAside: object VotingSchema.this.DerivativeSellerSetAside = new object VotingSchema.this.DerivativeSellerSetAside();
  case class DerivativeBuyerVote extends java.lang.Object with model.KL with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val id: model.package.Key = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def id: model.package.Key = DerivativeBuyerVote.this.id;
    <caseaccessor> <paramaccessor> private[this] val caster: model.Link[VotingSchema.this.Portfolio] = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def caster: model.Link[VotingSchema.this.Portfolio] = DerivativeBuyerVote.this.caster;
    <caseaccessor> <paramaccessor> private[this] val event: model.Link[VotingSchema.this.NewsEvent] = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def event: model.Link[VotingSchema.this.NewsEvent] = DerivativeBuyerVote.this.event;
    def this(id: model.package.Key = model.this.`package`.nextID, caster: model.Link[VotingSchema.this.Portfolio], event: model.Link[VotingSchema.this.NewsEvent]): VotingSchema.this.DerivativeBuyerVote = {
      DerivativeBuyerVote.super.this();
      ()
    };
    <synthetic> def copy(id: model.package.Key = id, caster: model.Link[VotingSchema.this.Portfolio] = caster, event: model.Link[VotingSchema.this.NewsEvent] = event): VotingSchema.this.DerivativeBuyerVote = new VotingSchema.this.DerivativeBuyerVote(id, caster, event);
    <synthetic> def copy$default$3: model.Link[VotingSchema.this.NewsEvent] @scala.annotation.unchecked.uncheckedVariance = DerivativeBuyerVote.this.event;
    <synthetic> def copy$default$2: model.Link[VotingSchema.this.Portfolio] @scala.annotation.unchecked.uncheckedVariance = DerivativeBuyerVote.this.caster;
    <synthetic> def copy$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = DerivativeBuyerVote.this.id;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(DerivativeBuyerVote.this);
    override def toString(): String = ScalaRunTime.this._toString(DerivativeBuyerVote.this);
    override def equals(x$1: Any): Boolean = DerivativeBuyerVote.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (id: model.package.Key, caster: model.Link[VotingSchema.this.Portfolio], event: model.Link[VotingSchema.this.NewsEvent])VotingSchema.this.DerivativeBuyerVote((id$3 @ _), (caster$1 @ _), (event$1 @ _)) if id$3.==(id).&&(caster$1.==(caster)).&&(event$1.==(event)) => x$1.asInstanceOf[VotingSchema.this.DerivativeBuyerVote].canEqual(DerivativeBuyerVote.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "DerivativeBuyerVote";
    override def productArity: Int = 3;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => id
      case 1 => caster
      case 2 => event
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[VotingSchema.this.DerivativeBuyerVote]()
  };
  final <synthetic> object DerivativeBuyerVote extends scala.runtime.AbstractFunction3[model.package.Key,model.Link[VotingSchema.this.Portfolio],model.Link[VotingSchema.this.NewsEvent],VotingSchema.this.DerivativeBuyerVote] with ScalaObject with Serializable {
    def this(): object VotingSchema.this.DerivativeBuyerVote = {
      DerivativeBuyerVote.super.this();
      ()
    };
    final override def toString(): java.lang.String = "DerivativeBuyerVote";
    <synthetic> def apply$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
    <synthetic> def init$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
    case <synthetic> def unapply(x$0: VotingSchema.this.DerivativeBuyerVote): Option[(model.package.Key, model.Link[VotingSchema.this.Portfolio], model.Link[VotingSchema.this.NewsEvent])] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(model.package.Key, model.Link[VotingSchema.this.Portfolio], model.Link[VotingSchema.this.NewsEvent])](new (model.package.Key, model.Link[VotingSchema.this.Portfolio], model.Link[VotingSchema.this.NewsEvent])(x$0.id, x$0.caster, x$0.event));
    case <synthetic> def apply(id: model.package.Key = model.this.`package`.nextID, caster: model.Link[VotingSchema.this.Portfolio], event: model.Link[VotingSchema.this.NewsEvent]): VotingSchema.this.DerivativeBuyerVote = new VotingSchema.this.DerivativeBuyerVote(id, caster, event)
  };
  @volatile <synthetic> private[this] var DerivativeBuyerVote$module: object VotingSchema.this.DerivativeBuyerVote = _;
  final <synthetic> <stable> def DerivativeBuyerVote: object VotingSchema.this.DerivativeBuyerVote = new object VotingSchema.this.DerivativeBuyerVote();
  case class DerivativeSellerVote extends java.lang.Object with model.KL with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val id: model.package.Key = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def id: model.package.Key = DerivativeSellerVote.this.id;
    <caseaccessor> <paramaccessor> private[this] val caster: model.Link[VotingSchema.this.Portfolio] = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def caster: model.Link[VotingSchema.this.Portfolio] = DerivativeSellerVote.this.caster;
    <caseaccessor> <paramaccessor> private[this] val event: model.Link[VotingSchema.this.NewsEvent] = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def event: model.Link[VotingSchema.this.NewsEvent] = DerivativeSellerVote.this.event;
    def this(id: model.package.Key = model.this.`package`.nextID, caster: model.Link[VotingSchema.this.Portfolio], event: model.Link[VotingSchema.this.NewsEvent]): VotingSchema.this.DerivativeSellerVote = {
      DerivativeSellerVote.super.this();
      ()
    };
    <synthetic> def copy(id: model.package.Key = id, caster: model.Link[VotingSchema.this.Portfolio] = caster, event: model.Link[VotingSchema.this.NewsEvent] = event): VotingSchema.this.DerivativeSellerVote = new VotingSchema.this.DerivativeSellerVote(id, caster, event);
    <synthetic> def copy$default$3: model.Link[VotingSchema.this.NewsEvent] @scala.annotation.unchecked.uncheckedVariance = DerivativeSellerVote.this.event;
    <synthetic> def copy$default$2: model.Link[VotingSchema.this.Portfolio] @scala.annotation.unchecked.uncheckedVariance = DerivativeSellerVote.this.caster;
    <synthetic> def copy$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = DerivativeSellerVote.this.id;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(DerivativeSellerVote.this);
    override def toString(): String = ScalaRunTime.this._toString(DerivativeSellerVote.this);
    override def equals(x$1: Any): Boolean = DerivativeSellerVote.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (id: model.package.Key, caster: model.Link[VotingSchema.this.Portfolio], event: model.Link[VotingSchema.this.NewsEvent])VotingSchema.this.DerivativeSellerVote((id$4 @ _), (caster$2 @ _), (event$2 @ _)) if id$4.==(id).&&(caster$2.==(caster)).&&(event$2.==(event)) => x$1.asInstanceOf[VotingSchema.this.DerivativeSellerVote].canEqual(DerivativeSellerVote.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "DerivativeSellerVote";
    override def productArity: Int = 3;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => id
      case 1 => caster
      case 2 => event
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[VotingSchema.this.DerivativeSellerVote]()
  };
  final <synthetic> object DerivativeSellerVote extends scala.runtime.AbstractFunction3[model.package.Key,model.Link[VotingSchema.this.Portfolio],model.Link[VotingSchema.this.NewsEvent],VotingSchema.this.DerivativeSellerVote] with ScalaObject with Serializable {
    def this(): object VotingSchema.this.DerivativeSellerVote = {
      DerivativeSellerVote.super.this();
      ()
    };
    final override def toString(): java.lang.String = "DerivativeSellerVote";
    <synthetic> def apply$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
    <synthetic> def init$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
    case <synthetic> def unapply(x$0: VotingSchema.this.DerivativeSellerVote): Option[(model.package.Key, model.Link[VotingSchema.this.Portfolio], model.Link[VotingSchema.this.NewsEvent])] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(model.package.Key, model.Link[VotingSchema.this.Portfolio], model.Link[VotingSchema.this.NewsEvent])](new (model.package.Key, model.Link[VotingSchema.this.Portfolio], model.Link[VotingSchema.this.NewsEvent])(x$0.id, x$0.caster, x$0.event));
    case <synthetic> def apply(id: model.package.Key = model.this.`package`.nextID, caster: model.Link[VotingSchema.this.Portfolio], event: model.Link[VotingSchema.this.NewsEvent]): VotingSchema.this.DerivativeSellerVote = new VotingSchema.this.DerivativeSellerVote(id, caster, event)
  };
  @volatile <synthetic> private[this] var DerivativeSellerVote$module: object VotingSchema.this.DerivativeSellerVote = _;
  final <synthetic> <stable> def DerivativeSellerVote: object VotingSchema.this.DerivativeSellerVote = new object VotingSchema.this.DerivativeSellerVote();
  abstract trait PortfolioWithVotes extends java.lang.Object with ScalaObject { self: VotingSchema.this.Portfolio => 
    def /*PortfolioWithVotes*/$init$(): Unit = {
      ()
    };
    def userVoteUp(ev: VotingSchema.this.NewsEvent, aside: VotingSchema.this.DerivativeBuyerSetAside): Unit = VotingSchema.this.editDB[Unit](VotingSchema.this.toOps[VotingSchema.this.Portfolio](this).refetch(VotingSchema.this.portfolios).voteUp(ev, VotingSchema.this.toOps[VotingSchema.this.DerivativeBuyerSetAside](aside).refetch(VotingSchema.this.derivativeBuyerSetAsides)));
    def userVoteDown(ev: VotingSchema.this.NewsEvent, aside: VotingSchema.this.DerivativeSellerSetAside): Unit = VotingSchema.this.editDB[Unit](VotingSchema.this.toOps[VotingSchema.this.Portfolio](this).refetch(VotingSchema.this.portfolios).voteDown(ev, VotingSchema.this.toOps[VotingSchema.this.DerivativeSellerSetAside](aside).refetch(VotingSchema.this.derivativeSellerSetAsides)));
    private[model] def voteUp(ev: VotingSchema.this.NewsEvent, aside: VotingSchema.this.DerivativeBuyerSetAside): VotingSchema.this.Transaction[Unit] = {
      val take: model.Scale = aside.remaining.*(Scale.apply("0.5"));
      val price: model.Dollars = aside.price.*(take);
      VotingSchema.this.toOps[VotingSchema.this.DerivativeBuyerVote]({
  val x$15: model.Link[VotingSchema.this.Portfolio] = model.this.KL.toLink[VotingSchema.this.Portfolio](this);
  val x$16: model.Link[VotingSchema.this.NewsEvent] = model.this.KL.toLink[VotingSchema.this.NewsEvent](ev);
  val x$17: model.package.Key = VotingSchema.this.DerivativeBuyerVote.apply$default$1;
  new VotingSchema.this.DerivativeBuyerVote(x$17, x$15, x$16)
}).insert(VotingSchema.this.derivativeBuyerVotes).flatMap[Unit](((_: VotingSchema.this.DerivativeBuyerVote) => PortfolioWithVotes.this.enterContract(model.this.Link.extract[VotingSchema.this.Portfolio](aside.seller)(VotingSchema.this.portfolios), aside.derivative.*(take), price, true).flatMap[Unit](((_: Unit) => VotingSchema.this.toOps[VotingSchema.this.DerivativeBuyerSetAside](aside).update(((a: VotingSchema.this.DerivativeBuyerSetAside) => {
  val x$18: model.Scale = a.remaining.-(take);
  val x$19: model.package.Key = a.copy$default$1;
  val x$20: model.Link[VotingSchema.this.Portfolio] = a.copy$default$2;
  val x$21: model.Link[VotingSchema.this.Portfolio] = a.copy$default$3;
  val x$22: model.Derivative = a.copy$default$4;
  val x$23: model.Dollars = a.copy$default$5;
  a.copy(x$19, x$20, x$21, x$22, x$23, x$18)
}))(VotingSchema.this.derivativeBuyerSetAsides).map[Unit](((_: Unit) => ()))))))
    };
    private[model] def voteDown(ev: VotingSchema.this.NewsEvent, aside: VotingSchema.this.DerivativeSellerSetAside): VotingSchema.this.Transaction[Unit] = {
      val take: model.Scale = aside.remaining.*(Scale.apply("0.5"));
      val price: model.Dollars = aside.price.*(take);
      VotingSchema.this.toOps[VotingSchema.this.DerivativeSellerVote]({
  val x$24: model.Link[VotingSchema.this.Portfolio] = model.this.KL.toLink[VotingSchema.this.Portfolio](this);
  val x$25: model.Link[VotingSchema.this.NewsEvent] = model.this.KL.toLink[VotingSchema.this.NewsEvent](ev);
  val x$26: model.package.Key = VotingSchema.this.DerivativeSellerVote.apply$default$1;
  new VotingSchema.this.DerivativeSellerVote(x$26, x$24, x$25)
}).insert(VotingSchema.this.derivativeSellerVotes).flatMap[Unit](((_: VotingSchema.this.DerivativeSellerVote) => model.this.Link.extract[VotingSchema.this.Portfolio](aside.buyer)(VotingSchema.this.portfolios).enterContract(this, aside.derivative.*(take), price, true).flatMap[Unit](((_: Unit) => VotingSchema.this.toOps[VotingSchema.this.DerivativeSellerSetAside](aside).update(((a: VotingSchema.this.DerivativeSellerSetAside) => {
  val x$27: model.Scale = a.remaining.-(take);
  val x$28: model.package.Key = a.copy$default$1;
  val x$29: model.Link[VotingSchema.this.Portfolio] = a.copy$default$2;
  val x$30: model.Link[VotingSchema.this.Portfolio] = a.copy$default$3;
  val x$31: model.Derivative = a.copy$default$4;
  val x$32: model.Dollars = a.copy$default$5;
  a.copy(x$28, x$29, x$30, x$31, x$32, x$27)
}))(VotingSchema.this.derivativeSellerSetAsides).map[Unit](((_: Unit) => ()))))))
    };
    private[model] def setupSetAside(buyer: VotingSchema.this.Portfolio, seller: VotingSchema.this.Portfolio, deriv: model.Derivative, price: model.Dollars): VotingSchema.this.Transaction[(VotingSchema.this.DerivativeBuyerSetAside, VotingSchema.this.DerivativeSellerSetAside)] = VotingSchema.this.toOps[VotingSchema.this.DerivativeBuyerSetAside]({
  val x$3: model.Link[VotingSchema.this.Portfolio] = model.this.KL.toLink[VotingSchema.this.Portfolio](buyer);
  val x$4: model.Link[VotingSchema.this.Portfolio] = model.this.KL.toLink[VotingSchema.this.Portfolio](seller);
  val x$5: model.Derivative = deriv;
  val x$6: model.Dollars = price;
  val x$7: model.Scale = VotingSchema.this.setAsideFraction;
  val x$8: model.package.Key = VotingSchema.this.DerivativeBuyerSetAside.apply$default$1;
  new VotingSchema.this.DerivativeBuyerSetAside(x$8, x$3, x$4, x$5, x$6, x$7)
}).insert(VotingSchema.this.derivativeBuyerSetAsides).flatMap[(VotingSchema.this.DerivativeBuyerSetAside, VotingSchema.this.DerivativeSellerSetAside)](((buyerSetAside: VotingSchema.this.DerivativeBuyerSetAside) => VotingSchema.this.toOps[VotingSchema.this.DerivativeSellerSetAside]({
  val x$9: model.Link[VotingSchema.this.Portfolio] = model.this.KL.toLink[VotingSchema.this.Portfolio](buyer);
  val x$10: model.Link[VotingSchema.this.Portfolio] = model.this.KL.toLink[VotingSchema.this.Portfolio](seller);
  val x$11: model.Derivative = deriv;
  val x$12: model.Dollars = price;
  val x$13: model.Scale = VotingSchema.this.setAsideFraction;
  val x$14: model.package.Key = VotingSchema.this.DerivativeSellerSetAside.apply$default$1;
  new VotingSchema.this.DerivativeSellerSetAside(x$14, x$9, x$10, x$11, x$12, x$13)
}).insert(VotingSchema.this.derivativeSellerSetAsides).map[(VotingSchema.this.DerivativeBuyerSetAside, VotingSchema.this.DerivativeSellerSetAside)](((sellerSetAside: VotingSchema.this.DerivativeSellerSetAside) => new (VotingSchema.this.DerivativeBuyerSetAside, VotingSchema.this.DerivativeSellerSetAside)(buyerSetAside, sellerSetAside)))))
  };
  abstract trait NewsEventWithVotes extends java.lang.Object with ScalaObject { self: VotingSchema.this.NewsEvent => 
    def /*NewsEventWithVotes*/$init$(): Unit = {
      ()
    };
    def isVotable: Boolean = NewsEventWithVotes.this.action match {
      case (from: VotingSchema.this.P, to: VotingSchema.this.P, derivative: model.Derivative, price: model.Dollars, buyerAside: model.Link[VotingSchema.this.DerivativeBuyerSetAside], sellerAside: model.Link[VotingSchema.this.DerivativeSellerSetAside])VotingSchema.this.Accepted(_, _, _, _, (b @ _), (s @ _)) => true
      case (buyer: VotingSchema.this.P, seller: VotingSchema.this.P, derivative: model.Derivative, buyerAside: model.Link[VotingSchema.this.BSA], sellerAside: model.Link[VotingSchema.this.SSA])VotingSchema.this.Won(_, _, _, (b @ _), (s @ _)) => true
      case _ => false
    };
    def asVotable: Option[(VotingSchema.this.DerivativeBuyerSetAside, VotingSchema.this.DerivativeSellerSetAside)] = NewsEventWithVotes.this.action match {
      case (from: VotingSchema.this.P, to: VotingSchema.this.P, derivative: model.Derivative, price: model.Dollars, buyerAside: model.Link[VotingSchema.this.DerivativeBuyerSetAside], sellerAside: model.Link[VotingSchema.this.DerivativeSellerSetAside])VotingSchema.this.Accepted(_, _, _, _, (b @ _), (s @ _)) => new Some[(VotingSchema.this.DerivativeBuyerSetAside, VotingSchema.this.DerivativeSellerSetAside)](new (VotingSchema.this.DerivativeBuyerSetAside, VotingSchema.this.DerivativeSellerSetAside)(model.this.Link.extract[VotingSchema.this.DerivativeBuyerSetAside](b)(VotingSchema.this.derivativeBuyerSetAsides), model.this.Link.extract[VotingSchema.this.DerivativeSellerSetAside](s)(VotingSchema.this.derivativeSellerSetAsides)))
      case (buyer: VotingSchema.this.P, seller: VotingSchema.this.P, derivative: model.Derivative, buyerAside: model.Link[VotingSchema.this.BSA], sellerAside: model.Link[VotingSchema.this.SSA])VotingSchema.this.Won(_, _, _, (b @ _), (s @ _)) => new Some[(VotingSchema.this.BSA, VotingSchema.this.SSA)](new (VotingSchema.this.BSA, VotingSchema.this.SSA)(model.this.Link.extract[VotingSchema.this.BSA](b)(VotingSchema.this.derivativeBuyerSetAsides), model.this.Link.extract[VotingSchema.this.SSA](s)(VotingSchema.this.derivativeSellerSetAsides)))
      case _ => scala.None
    };
    def buyerVotes: scala.collection.mutable.ArrayBuffer[VotingSchema.this.DerivativeBuyerVote] = VotingSchema.this.derivativeBuyerVotes.filter(((x$1: VotingSchema.this.DerivativeBuyerVote) => x$1.event.~~(this)));
    def sellerVotes: scala.collection.mutable.ArrayBuffer[VotingSchema.this.DerivativeSellerVote] = VotingSchema.this.derivativeSellerVotes.filter(((x$2: VotingSchema.this.DerivativeSellerVote) => x$2.event.~~(this)));
    def buyerTally: Int = NewsEventWithVotes.this.buyerVotes.length;
    def sellerTally: Int = NewsEventWithVotes.this.sellerVotes.length
  }
}
VotingSchema: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
 Derivat
 Derivat
 Derivat
 Derivat

final class $anon extends scala.AnyRef {
  def this(): anonymous class $anon = {
    $anon.super.this();
    ()
  };
  def orCreate(trans: => Transactions.this.Transaction[R]): Transactions.this.Transaction[R] = try {
    new Transactions.this.Transaction[R](already, immutable.this.Nil)
  } catch {
    case (_: errors.package.BadUser) => trans
  }
}
$anon: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
         orCreat

case class SecStock extends Security with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val ticker: String = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def ticker: String = SecStock.this.ticker;
  <caseaccessor> <paramaccessor> private[this] val shares: model.Shares = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def shares: model.Shares = SecStock.this.shares;
  def this(ticker: String, shares: model.Shares): model.SecStock = {
    SecStock.super.this();
    ()
  };
  def *(scale: model.Scale): model.SecStock = new model.SecStock(SecStock.this.ticker, SecStock.this.shares.*(scale));
  def spotValue: model.Dollars = try {
    Stocks.stockPrice(SecStock.this.ticker).*(SecStock.this.shares)
  } catch {
    case (_: stockdata.DatabaseException) => new model.Dollars(math.this.BigDecimal.int2bigDecimal(0))
    case (_: stockdata.NoSuchStockException) => new model.Dollars(math.this.BigDecimal.int2bigDecimal(0))
  };
  <synthetic> def copy(ticker: String = ticker, shares: model.Shares = shares): model.SecStock = new model.this.SecStock(ticker, shares);
  <synthetic> def copy$default$2: model.Shares @scala.annotation.unchecked.uncheckedVariance = SecStock.this.shares;
  <synthetic> def copy$default$1: String @scala.annotation.unchecked.uncheckedVariance = SecStock.this.ticker;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(SecStock.this);
  override def toString(): String = ScalaRunTime.this._toString(SecStock.this);
  override def equals(x$1: Any): Boolean = SecStock.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (ticker: String, shares: model.Shares)model.SecStock((ticker$1 @ _), (shares$1 @ _)) if ticker$1.==(ticker).&&(shares$1.==(shares)) => x$1.asInstanceOf[model.SecStock].canEqual(SecStock.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "SecStock";
  override def productArity: Int = 2;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => ticker
    case 1 => shares
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[model.SecStock]()
}
SecStock: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=0.500
          $times spotVal
  shares     X       X  
  ticker     X       X  

final object package extends java.lang.Object with ScalaObject {
  def this(): object errors.package = {
    package.super.this();
    ()
  };
  class BoxOps[A >: Nothing <: Any] extends java.lang.Object with ScalaObject {
    <paramaccessor> private[this] val b: net.liftweb.common.Box[A] = _;
    def this(b: net.liftweb.common.Box[A]): errors.package.BoxOps[A] = {
      BoxOps.super.this();
      ()
    };
    def withMessage(m: String => A): A = BoxOps.this.b match {
      case net.liftweb.common.Empty => m.apply("Unknown error")
      case (msg: String, exception: net.liftweb.common.Box[Throwable], chain: net.liftweb.common.Box[net.liftweb.common.Failure])net.liftweb.common.Failure((msg @ _), _, _) => m.apply(msg)
      case (value: A)net.liftweb.common.Full[A]((a @ _)) => a
    }
  };
  implicit def boxOps[A >: Nothing <: Any](b: net.liftweb.common.Box[A]): errors.package.BoxOps[A] = new errors.package.BoxOps[A](b);
  abstract trait BadUser extends scala.`package`.RuntimeException
}
package: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
          boxOps

abstract trait PortfolioWithAutoTrades extends java.lang.Object with ScalaObject { self: AutoTradeSchema.this.Portfolio => 
  def /*PortfolioWithAutoTrades*/$init$(): Unit = {
    ()
  };
  def userMakeNewAutoTrade(): AutoTradeSchema.this.AutoTrade = AutoTradeSchema.this.editDB[AutoTradeSchema.this.AutoTrade](PortfolioWithAutoTrades.this.makeNewAutoTrade);
  def myAutoTrades: List[AutoTradeSchema.this.AutoTrade] = AutoTradeSchema.this.autoTrades.filter(((x$1: AutoTradeSchema.this.AutoTrade) => x$1.owner.~~(this))).toList;
  private[model] def makeNewAutoTrade: AutoTradeSchema.this.Transaction[AutoTradeSchema.this.AutoTrade] = AutoTradeSchema.this.toOps[AutoTradeSchema.this.AutoTrade]({
  val x$2: AutoTradeSchema.this.Portfolio = this;
  val x$3: java.lang.String("") = "";
  val x$4: java.lang.String("") = "";
  val x$5: model.package.Key = AutoTradeSchema.this.AutoTrade.apply$default$1;
  new AutoTradeSchema.this.AutoTrade(x$5, x$2, "", "")
}).insert(AutoTradeSchema.this.autoTrades)
}
PortfolioWithAutoTrades: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=1.000
         makeNew myAutoT userMak

abstract trait TextRender extends java.lang.Object with intform.FieldRender with ScalaObject {
  def /*TextRender*/$init$(): Unit = {
    ()
  };
  <accessor> def text: String;
  <accessor> def text_=(x$1: String): Unit;
  def main: scala.xml.NodeSeq = scalaz.Scalaz.mkIdentity[scala.xml.Elem]({
  {
    var $md: scala.xml.MetaData = scala.xml.Null;
    $md = new scala.xml.UnprefixedAttribute("value", TextRender.this.text, $md);
    $md = new scala.xml.UnprefixedAttribute("type", new scala.xml.Text("text"), $md);
    new scala.xml.Elem(null, "input", $md, scala.this.Predef.$scope)
  }
}).|>[scala.xml.NodeSeq](net.liftweb.http.SHtml.onSubmit(((x$1: String) => TextRender.this.text_=(x$1))))
}
TextRender: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
            main
    text     X  
 text_$e     X  

class FormSubmit extends java.lang.Object with intform.SubmitRender with intform.BasicErrors with intform.ErrorRender with intform.FormOuter with net.liftweb.common.Loggable with ScalaObject {
  <paramaccessor> private[this] val refresher: intform.Refreshable = _;
  <paramaccessor> private[this] val value: String = _;
  <stable> <accessor> <paramaccessor> def value: String = FormSubmit.this.value;
  <paramaccessor> private[this] val callback: () => net.liftweb.http.js.JsCmd = _;
  def this(refresher: intform.Refreshable, value: String, callback: () => net.liftweb.http.js.JsCmd): intform.FormSubmit = {
    FormSubmit.super.this();
    ()
  };
  def submitAjax(): net.liftweb.http.js.JsCmd = FormSubmit.this.runWithErrors(FormSubmit.this.callback.apply()).&(FormSubmit.this.refresher.refresh())
}
FormSubmit: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
         submitA
 refresh     X  
 callbac     X  
   value        

abstract trait PortfolioOps extends java.lang.Object with ScalaObject { self: UserSchema.this.Portfolio with UserSchema.this.PortfolioWithStocks with UserSchema.this.PortfolioWithDerivatives => 
  def /*PortfolioOps*/$init$(): Unit = {
    ()
  };
  def spotValue: model.Dollars = PortfolioOps.this.cash.+(PortfolioOps.this.myStockAssets.map[model.Dollars, List[model.Dollars]](((x$14: UserSchema.this.StockAsset) => x$14.dollars))(immutable.this.List.canBuildFrom[model.Dollars]).foldLeft[model.Dollars](new model.Dollars(math.this.BigDecimal.int2bigDecimal(0)))(((x$15: model.Dollars, x$16: model.Dollars) => x$15.+(x$16)))).+(PortfolioOps.this.myDerivativeAssets.map[model.Dollars, List[model.Dollars]](((x$17: UserSchema.this.DerivativeAsset) => x$17.spotValue))(immutable.this.List.canBuildFrom[model.Dollars]).foldLeft[model.Dollars](new model.Dollars(math.this.BigDecimal.int2bigDecimal(0)))(((x$18: model.Dollars, x$19: model.Dollars) => x$18.+(x$19))));
  def userInviteUser(user: UserSchema.this.User): UserSchema.this.PortfolioInvite = UserSchema.this.editDB[UserSchema.this.PortfolioInvite](PortfolioOps.this.inviteUser(user));
  def owners: List[UserSchema.this.User] = UserSchema.this.readDB[List[UserSchema.this.User]](UserSchema.this.ownerships.filter(((x$20: UserSchema.this.Ownership) => x$20.portfolio.~~(this))).map[UserSchema.this.User, scala.collection.mutable.ArrayBuffer[UserSchema.this.User]](((x$21: UserSchema.this.Ownership) => x$21.user))(mutable.this.ArrayBuffer.canBuildFrom[UserSchema.this.User]).toList);
  def isOwnedBy(user: UserSchema.this.User): Boolean = PortfolioOps.this.owners.exists(((x$22: UserSchema.this.User) => x$22.~~(user)));
  private[model] def inviteUser(user: UserSchema.this.User): UserSchema.this.Transaction[UserSchema.this.PortfolioInvite] = UserSchema.this.toOps[UserSchema.this.PortfolioInvite]({
  val x$51: UserSchema.this.Portfolio with UserSchema.this.PortfolioWithStocks with UserSchema.this.PortfolioWithDerivatives = this;
  val x$52: UserSchema.this.User = user;
  val x$53: model.package.Key = UserSchema.this.PortfolioInvite.apply$default$1;
  new UserSchema.this.PortfolioInvite(x$53, x$51, x$52)
}).insert(UserSchema.this.portfolioInvites)
}
PortfolioOps: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.600
         spotVal isOwned  owners userInv inviteU

class NewPortfolio extends java.lang.Object with intform.Page with net.liftweb.common.Loggable with ScalaObject {
  def this(): code.snippet.NewPortfolio = {
    NewPortfolio.super.this();
    ()
  };
  def render: scala.xml.NodeSeq = NewPortfolio.this.refreshable.render;
  private[this] val refreshable: intform.Refreshable.NeedRenderable with intform.Refreshable = intform.Refreshable.apply(NewPortfolio.this.doRender);
  <stable> <accessor> def refreshable: intform.Refreshable.NeedRenderable with intform.Refreshable = NewPortfolio.this.refreshable;
  def doRender: scala.xml.NodeSeq = {
    val nameField: intform.StringField = intform.StringField.apply("");
    val inviteesField: intform.Field[Seq[model.schema.User]] with intform.FieldRender = intform.ListField.apply[model.schema.User]({
      final class $anon extends UserField with intform.FieldErrorRender {
        def this(): anonymous class $anon = {
          $anon.super.this("");
          ()
        }
      };
      new $anon()
    }, ((items: Seq[intform.ItemRender], add: scala.xml.NodeSeq) => {
      val list: Seq[scala.xml.Elem] = items.map[scala.xml.Elem, Seq[scala.xml.Elem]](((item: intform.ItemRender) => {
        {
          new scala.xml.Elem(null, "li", scala.xml.Null, scala.this.Predef.$scope, ({
            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
            $buf.&+(item.field);
            $buf.&+(new scala.xml.Text(" "));
            $buf.&+(item.delete);
            $buf
          }: _*))
        }
      }))(collection.this.Seq.canBuildFrom[scala.xml.Elem]);
      {
        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
        $buf.&+({
          {
            new scala.xml.Elem(null, "ul", scala.xml.Null, scala.this.Predef.$scope, ({
              val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
              $buf.&+(list);
              $buf
            }: _*))
          }
        });
        $buf.&+({
          {
            new scala.xml.Elem(null, "p", scala.xml.Null, scala.this.Predef.$scope, ({
              val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
              $buf.&+(add);
              $buf
            }: _*))
          }
        });
        xml.this.NodeSeq.seqToNodeSeq($buf)
      }
    }));
    lazy var form$lzy: intform.Form[NewPortfolio.this.Stuff] = _;
    <stable> <accessor> lazy def form: intform.Form[NewPortfolio.this.Stuff] = {
      form$lzy = intform.Form.apply[NewPortfolio.this.Stuff, up.HList.:+:[String,up.HList.:+:[Seq[model.schema.User],up.HNil]]](intform.`package`.hlistify2[String, Seq[model.schema.User], NewPortfolio.this.Stuff](NewPortfolio.this.Stuff), intform.`package`.klist2[intform.Field, String, Seq[model.schema.User]](new (intform.StringField, intform.Field[Seq[model.schema.User]] with intform.FieldRender)(nameField, inviteesField)), {
        {
          new scala.xml.Elem(null, "div", scala.xml.Null, scala.this.Predef.$scope, ({
            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
            $buf.&+(new scala.xml.Text("\012                "));
            $buf.&+({
              {
                new scala.xml.Elem(null, "p", scala.xml.Null, scala.this.Predef.$scope, ({
                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                  $buf.&+(new scala.xml.Text("Name: "));
                  $buf.&+(nameField.main);
                  $buf.&+(new scala.xml.Text(" "));
                  $buf.&+(nameField.errors);
                  $buf
                }: _*))
              }
            });
            $buf.&+(new scala.xml.Text("\012                "));
            $buf.&+({
              {
                new scala.xml.Elem(null, "p", scala.xml.Null, scala.this.Predef.$scope, ({
                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                  $buf.&+(new scala.xml.Text("Invite users:"));
                  $buf
                }: _*))
              }
            });
            $buf.&+(new scala.xml.Text("\012                "));
            $buf.&+(inviteesField.main);
            $buf.&+(new scala.xml.Text("\012                "));
            $buf.&+({
              {
                new scala.xml.Elem(null, "p", scala.xml.Null, scala.this.Predef.$scope, ({
                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                  $buf.&+(createButton.main);
                  $buf
                }: _*))
              }
            });
            $buf.&+(new scala.xml.Text("\012                "));
            $buf.&+({
              {
                new scala.xml.Elem(null, "p", scala.xml.Null, scala.this.Predef.$scope, ({
                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                  $buf.&+(createButton.errors);
                  $buf
                }: _*))
              }
            });
            $buf.&+(new scala.xml.Text("\012            "));
            $buf
          }: _*))
        }
      });
      form$lzy
    };
    lazy var createButton$lzy: intform.Submit[NewPortfolio.this.Stuff] = _;
    <stable> <accessor> lazy def createButton: intform.Submit[NewPortfolio.this.Stuff] = {
      createButton$lzy = intform.Submit.apply[NewPortfolio.this.Stuff](form, "Create Portfolio", intform.Submit.apply$default$3[Nothing])(((stuff: NewPortfolio.this.Stuff) => {
        <synthetic> private[this] val x$1: (String, Seq[model.schema.User]) = (stuff: NewPortfolio.this.Stuff @unchecked) match {
          case (name: String, invitees: Seq[model.schema.User])NewPortfolio.this.Stuff((name @ _), (invitees @ _)) => new (String, Seq[model.schema.User])(name, invitees)
        };
        val name: String = x$1._1;
        val invitees: Seq[model.schema.User] = x$1._2;
        try {
          val port: model.schema.Portfolio = control.LoginManager.currentUser.userCreatePortfolio(name);
          invitees.map[model.schema.PortfolioInvite, Seq[model.schema.PortfolioInvite]](((x$2: model.schema.User) => port.userInviteUser(x$2)))(collection.this.Seq.canBuildFrom[model.schema.PortfolioInvite]);
          NewPortfolio.this.redirectTo("/")
        } catch {
          case control.LoginManager.NotLoggedIn => throw new intform.BadInput("You need to be logged in to create a portfolio")
          case model.schema.NameInUse => throw new intform.BadInput("Apparently someone took that name before you youtube.com/watch?v=o605DTjj7HU")
        }
      }));
      createButton$lzy
    };
    {
      {
        var $md: scala.xml.MetaData = scala.xml.Null;
        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("block"), $md);
        new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
          $buf.&+(new scala.xml.Text("\012            "));
          $buf.&+(form.render);
          $buf.&+(new scala.xml.Text("\012        "));
          $buf
        }: _*))
      }
    }
  };
  case class Stuff extends java.lang.Object with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val name: String = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def name: String = Stuff.this.name;
    <caseaccessor> <paramaccessor> private[this] val invitees: Seq[model.schema.User] = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def invitees: Seq[model.schema.User] = Stuff.this.invitees;
    def this(name: String, invitees: Seq[model.schema.User]): NewPortfolio.this.Stuff = {
      Stuff.super.this();
      ()
    };
    <synthetic> def copy(name: String = name, invitees: Seq[model.schema.User] = invitees): NewPortfolio.this.Stuff = new NewPortfolio.this.Stuff(name, invitees);
    <synthetic> def copy$default$2: Seq[model.schema.User] @scala.annotation.unchecked.uncheckedVariance = Stuff.this.invitees;
    <synthetic> def copy$default$1: String @scala.annotation.unchecked.uncheckedVariance = Stuff.this.name;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(Stuff.this);
    override def toString(): String = ScalaRunTime.this._toString(Stuff.this);
    override def equals(x$1: Any): Boolean = Stuff.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (name: String, invitees: Seq[model.schema.User])NewPortfolio.this.Stuff((name$1 @ _), (invitees$1 @ _)) if name$1.==(name).&&(invitees$1.==(invitees)) => x$1.asInstanceOf[NewPortfolio.this.Stuff].canEqual(Stuff.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "Stuff";
    override def productArity: Int = 2;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => name
      case 1 => invitees
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[NewPortfolio.this.Stuff]()
  };
  final <synthetic> object Stuff extends scala.runtime.AbstractFunction2[String,Seq[model.schema.User],NewPortfolio.this.Stuff] with ScalaObject with Serializable {
    def this(): object NewPortfolio.this.Stuff = {
      Stuff.super.this();
      ()
    };
    final override def toString(): java.lang.String = "Stuff";
    case <synthetic> def unapply(x$0: NewPortfolio.this.Stuff): Option[(String, Seq[model.schema.User])] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(String, Seq[model.schema.User])](new (String, Seq[model.schema.User])(x$0.name, x$0.invitees));
    case <synthetic> def apply(name: String, invitees: Seq[model.schema.User]): NewPortfolio.this.Stuff = new NewPortfolio.this.Stuff(name, invitees)
  };
  @volatile <synthetic> private[this] var Stuff$module: object NewPortfolio.this.Stuff = _;
  final <synthetic> <stable> def Stuff: object NewPortfolio.this.Stuff = {
    NewPortfolio.this.Stuff$module = new object NewPortfolio.this.Stuff();
    NewPortfolio.this.Stuff$module
  }
}
NewPortfolio: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=1.000
          render doRende
 Stuff$m             X  

class email extends _root_.java.lang.Object {
  import email._;
  def this() = _
}
email: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

final case object NameInUse extends java.lang.RuntimeException with errors.package.BadUser with ScalaObject with Product with Serializable {
  def this(): object SchemaErrors.this.NameInUse = {
    NameInUse.super.this();
    ()
  };
  final override def hashCode(): Int = -1077639625;
  override def productPrefix: java.lang.String = "NameInUse";
  override def productArity: Int = 0;
  override def productElement(x$1: Int): Any = x$1 match {
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[object SchemaErrors.this.NameInUse]()
}
NameInUse: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

class CacheMap[K >: Nothing <: Any, V >: Nothing <: Any] extends java.lang.Object with ScalaObject {
  <paramaccessor> private[this] val timeout: org.joda.time.Duration = _;
  def this(timeout: org.joda.time.Duration): stockdata.CacheMap[K,V] = {
    CacheMap.super.this();
    ()
  };
  def put(key: K, value: V): V = {
    CacheMap.this.map.update(key, new CacheMap.this.Entry(value, new org.joda.time.DateTime()));
    value
  };
  def get(key: K)(fetch: => V): V = CacheMap.this.map.get(key) match {
    case (x: CacheMap.this.Entry)Some[CacheMap.this.Entry]((value: V, time: org.joda.time.DateTime)CacheMap.this.Entry((value @ _), (time @ _))) if CacheMap.this.expired(time).unary_! => value
    case _ => CacheMap.this.put(key, fetch)
  };
  private[this] val map: scala.collection.mutable.Map[K,CacheMap.this.Entry] = scala.collection.mutable.MMap.apply[K, CacheMap.this.Entry]();
  case private[this] class Entry extends java.lang.Object with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val value: V = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def value: V = Entry.this.value;
    <caseaccessor> <paramaccessor> private[this] val time: org.joda.time.DateTime = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def time: org.joda.time.DateTime = Entry.this.time;
    def this(value: V, time: org.joda.time.DateTime): CacheMap.this.Entry = {
      Entry.super.this();
      ()
    };
    <synthetic> def copy$default$2: org.joda.time.DateTime @scala.annotation.unchecked.uncheckedVariance = Entry.this.time;
    <synthetic> def copy$default$1: V @scala.annotation.unchecked.uncheckedVariance = Entry.this.value;
    <synthetic> def copy(value: V = value, time: org.joda.time.DateTime = time): CacheMap.this.Entry = new CacheMap.this.Entry(value, time);
    override def hashCode(): Int = ScalaRunTime.this._hashCode(Entry.this);
    override def toString(): String = ScalaRunTime.this._toString(Entry.this);
    override def equals(x$1: Any): Boolean = Entry.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (value: V, time: org.joda.time.DateTime)CacheMap.this.Entry((value$1 @ _), (time$1 @ _)) if value$1.==(value).&&(time$1.==(time)) => x$1.asInstanceOf[CacheMap.this.Entry].canEqual(Entry.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "Entry";
    override def productArity: Int = 2;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => value
      case 1 => time
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[CacheMap.this.Entry]()
  };
  final <synthetic> private[this] object Entry extends scala.runtime.AbstractFunction2[V,org.joda.time.DateTime,CacheMap.this.Entry] with ScalaObject with Serializable {
    def this(): object CacheMap.this.Entry = {
      Entry.super.this();
      ()
    };
    final override def toString(): java.lang.String = "Entry";
    case <synthetic> def unapply(x$0: CacheMap.this.Entry): Option[(V, org.joda.time.DateTime)] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(V, org.joda.time.DateTime)](new (V, org.joda.time.DateTime)(x$0.value, x$0.time));
    case <synthetic> def apply(value: V, time: org.joda.time.DateTime): CacheMap.this.Entry = new CacheMap.this.Entry(value, time)
  };
  @volatile <synthetic> private[this] var Entry$module: object CacheMap.this.Entry = _;
  final <synthetic> <stable> private[this] def Entry: object CacheMap.this.Entry = {
    CacheMap.this.Entry$module = new object CacheMap.this.Entry();
    CacheMap.this.Entry$module
  };
  def expired(time: org.joda.time.DateTime): Boolean = CacheMap.this.timeout.compareTo(new org.joda.time.Duration(time, new org.joda.time.DateTime())).<(0)
}
CacheMap: SCOM=0.167 CC=0.333 LSCC=0.167 CAMC=0.417
             put     get expired
 timeout             X       X  
 Entry$m                        

abstract trait ErrorRender extends java.lang.Object with ScalaObject {
  def /*ErrorRender*/$init$(): Unit = {
    ()
  };
  def errorText: String;
  def errors: scala.xml.NodeSeq = {
    {
      var $md: scala.xml.MetaData = scala.xml.Null;
      $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("inputError"), $md);
      new scala.xml.Elem(null, "span", $md, scala.this.Predef.$scope, ({
        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
        $buf.&+(ErrorRender.this.errorText);
        $buf
      }: _*))
    }
  }
}
ErrorRender: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
          errors
 errorTe     X  

case class CondGreater extends Condition with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val a: model.ComparableSecurity = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def a: model.ComparableSecurity = CondGreater.this.a;
  <caseaccessor> <paramaccessor> private[this] val b: model.ComparableSecurity = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def b: model.ComparableSecurity = CondGreater.this.b;
  def this(a: model.ComparableSecurity, b: model.ComparableSecurity): model.CondGreater = {
    CondGreater.super.this();
    ()
  };
  def isTrue: Boolean = CondGreater.this.a.toPrice.>(CondGreater.this.b.toPrice);
  <synthetic> def copy(a: model.ComparableSecurity = a, b: model.ComparableSecurity = b): model.CondGreater = new model.this.CondGreater(a, b);
  <synthetic> def copy$default$2: model.ComparableSecurity @scala.annotation.unchecked.uncheckedVariance = CondGreater.this.b;
  <synthetic> def copy$default$1: model.ComparableSecurity @scala.annotation.unchecked.uncheckedVariance = CondGreater.this.a;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(CondGreater.this);
  override def toString(): String = ScalaRunTime.this._toString(CondGreater.this);
  override def equals(x$1: Any): Boolean = CondGreater.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (a: model.ComparableSecurity, b: model.ComparableSecurity)model.CondGreater((a$1 @ _), (b$1 @ _)) if a$1.==(a).&&(b$1.==(b)) => x$1.asInstanceOf[model.CondGreater].canEqual(CondGreater.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "CondGreater";
  override def productArity: Int = 2;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => a
    case 1 => b
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[model.CondGreater]()
}
CondGreater: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
          isTrue
       b     X  
       a     X  

abstract trait AuctionSchema extends java.lang.Object with ScalaObject { schema: model.AuctionSchema with model.UserSchema with model.DerivativeSchema with model.SchemaErrors with model.DBMagic with model.NewsSchema => 
  def /*AuctionSchema*/$init$(): Unit = {
    ()
  };
  private[this] val auctionOffers: model.Table[AuctionSchema.this.AuctionOffer] = AuctionSchema.this.table[AuctionSchema.this.AuctionOffer];
  implicit <stable> <accessor> def auctionOffers: model.Table[AuctionSchema.this.AuctionOffer] = AuctionSchema.this.auctionOffers;
  private[this] val auctionBids: model.Table[AuctionSchema.this.AuctionBid] = AuctionSchema.this.table[AuctionSchema.this.AuctionBid];
  implicit <stable> <accessor> def auctionBids: model.Table[AuctionSchema.this.AuctionBid] = AuctionSchema.this.auctionBids;
  case class AuctionOffer extends java.lang.Object with model.KL with AuctionSchema.this.AuctionOfferOps with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val id: model.package.Key = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def id: model.package.Key = AuctionOffer.this.id;
    <caseaccessor> <paramaccessor> private[this] val derivative: model.Derivative = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def derivative: model.Derivative = AuctionOffer.this.derivative;
    <caseaccessor> <paramaccessor> private[this] val offerer: model.Link[AuctionSchema.this.Portfolio] = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def offerer: model.Link[AuctionSchema.this.Portfolio] = AuctionOffer.this.offerer;
    <caseaccessor> <paramaccessor> private[this] val price: model.Dollars = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def price: model.Dollars = AuctionOffer.this.price;
    <caseaccessor> <paramaccessor> private[this] val when: org.joda.time.DateTime = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def when: org.joda.time.DateTime = AuctionOffer.this.when;
    <caseaccessor> <paramaccessor> private[this] val expires: org.joda.time.DateTime = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def expires: org.joda.time.DateTime = AuctionOffer.this.expires;
    def this(id: model.package.Key = model.this.`package`.nextID, derivative: model.Derivative, offerer: model.Link[AuctionSchema.this.Portfolio], price: model.Dollars, when: org.joda.time.DateTime, expires: org.joda.time.DateTime): AuctionSchema.this.AuctionOffer = {
      AuctionOffer.super.this();
      ()
    };
    <synthetic> def copy(id: model.package.Key = id, derivative: model.Derivative = derivative, offerer: model.Link[AuctionSchema.this.Portfolio] = offerer, price: model.Dollars = price, when: org.joda.time.DateTime = when, expires: org.joda.time.DateTime = expires): AuctionSchema.this.AuctionOffer = new AuctionSchema.this.AuctionOffer(id, derivative, offerer, price, when, expires);
    <synthetic> def copy$default$6: org.joda.time.DateTime @scala.annotation.unchecked.uncheckedVariance = AuctionOffer.this.expires;
    <synthetic> def copy$default$5: org.joda.time.DateTime @scala.annotation.unchecked.uncheckedVariance = AuctionOffer.this.when;
    <synthetic> def copy$default$4: model.Dollars @scala.annotation.unchecked.uncheckedVariance = AuctionOffer.this.price;
    <synthetic> def copy$default$3: model.Link[AuctionSchema.this.Portfolio] @scala.annotation.unchecked.uncheckedVariance = AuctionOffer.this.offerer;
    <synthetic> def copy$default$2: model.Derivative @scala.annotation.unchecked.uncheckedVariance = AuctionOffer.this.derivative;
    <synthetic> def copy$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = AuctionOffer.this.id;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(AuctionOffer.this);
    override def toString(): String = ScalaRunTime.this._toString(AuctionOffer.this);
    override def equals(x$1: Any): Boolean = AuctionOffer.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (id: model.package.Key, derivative: model.Derivative, offerer: model.Link[AuctionSchema.this.Portfolio], price: model.Dollars, when: org.joda.time.DateTime, expires: org.joda.time.DateTime)AuctionSchema.this.AuctionOffer((id$1 @ _), (derivative$1 @ _), (offerer$1 @ _), (price$1 @ _), (when$1 @ _), (expires$1 @ _)) if id$1.==(id).&&(derivative$1.==(derivative)).&&(offerer$1.==(offerer)).&&(price$1.==(price)).&&(when$1.==(when)).&&(expires$1.==(expires)) => x$1.asInstanceOf[AuctionSchema.this.AuctionOffer].canEqual(AuctionOffer.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "AuctionOffer";
    override def productArity: Int = 6;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => id
      case 1 => derivative
      case 2 => offerer
      case 3 => price
      case 4 => when
      case 5 => expires
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[AuctionSchema.this.AuctionOffer]()
  };
  case class AuctionBid extends java.lang.Object with model.KL with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val id: model.package.Key = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def id: model.package.Key = AuctionBid.this.id;
    <caseaccessor> <paramaccessor> private[this] val offer: model.Link[AuctionSchema.this.AuctionOffer] = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def offer: model.Link[AuctionSchema.this.AuctionOffer] = AuctionBid.this.offer;
    <caseaccessor> <paramaccessor> private[this] val by: model.Link[AuctionSchema.this.Portfolio] = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def by: model.Link[AuctionSchema.this.Portfolio] = AuctionBid.this.by;
    <caseaccessor> <paramaccessor> private[this] val price: model.Dollars = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def price: model.Dollars = AuctionBid.this.price;
    def this(id: model.package.Key = model.this.`package`.nextID, offer: model.Link[AuctionSchema.this.AuctionOffer], by: model.Link[AuctionSchema.this.Portfolio], price: model.Dollars): AuctionSchema.this.AuctionBid = {
      AuctionBid.super.this();
      ()
    };
    <synthetic> def copy(id: model.package.Key = id, offer: model.Link[AuctionSchema.this.AuctionOffer] = offer, by: model.Link[AuctionSchema.this.Portfolio] = by, price: model.Dollars = price): AuctionSchema.this.AuctionBid = new AuctionSchema.this.AuctionBid(id, offer, by, price);
    <synthetic> def copy$default$4: model.Dollars @scala.annotation.unchecked.uncheckedVariance = AuctionBid.this.price;
    <synthetic> def copy$default$3: model.Link[AuctionSchema.this.Portfolio] @scala.annotation.unchecked.uncheckedVariance = AuctionBid.this.by;
    <synthetic> def copy$default$2: model.Link[AuctionSchema.this.AuctionOffer] @scala.annotation.unchecked.uncheckedVariance = AuctionBid.this.offer;
    <synthetic> def copy$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = AuctionBid.this.id;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(AuctionBid.this);
    override def toString(): String = ScalaRunTime.this._toString(AuctionBid.this);
    override def equals(x$1: Any): Boolean = AuctionBid.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (id: model.package.Key, offer: model.Link[AuctionSchema.this.AuctionOffer], by: model.Link[AuctionSchema.this.Portfolio], price: model.Dollars)AuctionSchema.this.AuctionBid((id$2 @ _), (offer$1 @ _), (by$1 @ _), (price$2 @ _)) if id$2.==(id).&&(offer$1.==(offer)).&&(by$1.==(by)).&&(price$2.==(price)) => x$1.asInstanceOf[AuctionSchema.this.AuctionBid].canEqual(AuctionBid.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "AuctionBid";
    override def productArity: Int = 4;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => id
      case 1 => offer
      case 2 => by
      case 3 => price
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[AuctionSchema.this.AuctionBid]()
  };
  final <synthetic> object AuctionBid extends scala.runtime.AbstractFunction4[model.package.Key,model.Link[AuctionSchema.this.AuctionOffer],model.Link[AuctionSchema.this.Portfolio],model.Dollars,AuctionSchema.this.AuctionBid] with ScalaObject with Serializable {
    def this(): object AuctionSchema.this.AuctionBid = {
      AuctionBid.super.this();
      ()
    };
    final override def toString(): java.lang.String = "AuctionBid";
    <synthetic> def apply$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
    <synthetic> def init$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
    case <synthetic> def unapply(x$0: AuctionSchema.this.AuctionBid): Option[(model.package.Key, model.Link[AuctionSchema.this.AuctionOffer], model.Link[AuctionSchema.this.Portfolio], model.Dollars)] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(model.package.Key, model.Link[AuctionSchema.this.AuctionOffer], model.Link[AuctionSchema.this.Portfolio], model.Dollars)](new (model.package.Key, model.Link[AuctionSchema.this.AuctionOffer], model.Link[AuctionSchema.this.Portfolio], model.Dollars)(x$0.id, x$0.offer, x$0.by, x$0.price));
    case <synthetic> def apply(id: model.package.Key = model.this.`package`.nextID, offer: model.Link[AuctionSchema.this.AuctionOffer], by: model.Link[AuctionSchema.this.Portfolio], price: model.Dollars): AuctionSchema.this.AuctionBid = new AuctionSchema.this.AuctionBid(id, offer, by, price)
  };
  @volatile <synthetic> private[this] var AuctionBid$module: object AuctionSchema.this.AuctionBid = _;
  final <synthetic> <stable> def AuctionBid: object AuctionSchema.this.AuctionBid = new object AuctionSchema.this.AuctionBid();
  def systemCheckForAuctionClosings(): Unit = AuctionSchema.this.logger.info("TODO: This");
  abstract trait AuctionOfferOps extends java.lang.Object with ScalaObject { self: AuctionSchema.this.AuctionOffer => 
    def /*AuctionOfferOps*/$init$(): Unit = {
      ()
    };
    def bids: Seq[AuctionSchema.this.AuctionBid] = AuctionSchema.this.auctionBids.filter(((x$1: AuctionSchema.this.AuctionBid) => x$1.offer.~~(this))).toList;
    def goingPrice: model.Dollars = if (AuctionOfferOps.this.bids.isEmpty)
      AuctionOfferOps.this.price
    else
      AuctionOfferOps.this.bids.map[model.Dollars, Seq[model.Dollars]](((x$2: AuctionSchema.this.AuctionBid) => x$2.price))(collection.this.Seq.canBuildFrom[model.Dollars]).max[model.Dollars](math.this.Ordering.ordered[model.Dollars](scala.this.Predef.conforms[model.Dollars]));
    def highBid: Option[AuctionSchema.this.AuctionBid] = if (AuctionOfferOps.this.bids.isEmpty)
      scala.None
    else
      new Some[AuctionSchema.this.AuctionBid](AuctionOfferOps.this.bids.maxBy[model.Dollars](((x$3: AuctionSchema.this.AuctionBid) => x$3.price))(math.this.Ordering.ordered[model.Dollars](scala.this.Predef.conforms[model.Dollars])));
    def userClose(): Unit = AuctionSchema.this.editDB[Unit]({
      val deletion: AuctionSchema.this.Transaction[Unit] = AuctionSchema.this.toOps[AuctionSchema.this.AuctionOffer](this).delete(AuctionSchema.this.auctionOffers).flatMap[Unit](((_: AuctionSchema.this.AuctionOffer) => scalaz.Scalaz.SeqMA[Seq, AuctionSchema.this.Transaction[AuctionSchema.this.AuctionBid]](AuctionOfferOps.this.bids.map[AuctionSchema.this.Transaction[AuctionSchema.this.AuctionBid], Seq[AuctionSchema.this.Transaction[AuctionSchema.this.AuctionBid]]](((x$4: AuctionSchema.this.AuctionBid) => AuctionSchema.this.toOps[AuctionSchema.this.AuctionBid](x$4).delete(AuctionSchema.this.auctionBids)))(collection.this.Seq.canBuildFrom[AuctionSchema.this.Transaction[AuctionSchema.this.AuctionBid]])).sequence[AuctionSchema.this.Transaction, AuctionSchema.this.AuctionBid](scala.this.Predef.conforms[AuctionSchema.this.Transaction[AuctionSchema.this.AuctionBid]], scalaz.this.Traverse.TraversableTraverse[Seq](scalaz.this.CanBuildAnySelf.GenericCanBuildSelf[Seq](collection.this.Seq.canBuildFrom[Nothing])), scalaz.this.Applicative.applicative[AuctionSchema.this.Transaction](AuctionSchema.this.TransactionPure, scalaz.this.Apply.FunctorBindApply[AuctionSchema.this.Transaction](AuctionSchema.this.TransactionFunctor, AuctionSchema.this.TransactionBind))).flatMap[Unit](((_: Seq[AuctionSchema.this.AuctionBid]) => new AuctionSchema.this.Closed(model.this.Link.extract[AuctionSchema.this.Portfolio](AuctionOfferOps.this.offerer)(AuctionSchema.this.portfolios), this).report().map[Unit](((_: AuctionSchema.this.NewsEvent) => ()))))));
      AuctionOfferOps.this.highBid match {
        case scala.None => deletion
        case (x: AuctionSchema.this.AuctionBid)Some[AuctionSchema.this.AuctionBid]((bid @ _)) => deletion.flatMap[Unit](((_: Unit) => model.this.Link.extract[AuctionSchema.this.Portfolio](bid.by)(AuctionSchema.this.portfolios).enterContractWithVotes(model.this.Link.extract[AuctionSchema.this.Portfolio](AuctionOfferOps.this.offerer)(AuctionSchema.this.portfolios), AuctionOfferOps.this.derivative, bid.price).filter(((check$ifrefutable$1: (AuctionSchema.this.DerivativeBuyerSetAside, AuctionSchema.this.DerivativeSellerSetAside)) => (check$ifrefutable$1: (AuctionSchema.this.DerivativeBuyerSetAside, AuctionSchema.this.DerivativeSellerSetAside) @unchecked) match {
  case (_1: AuctionSchema.this.DerivativeBuyerSetAside, _2: AuctionSchema.this.DerivativeSellerSetAside)(AuctionSchema.this.DerivativeBuyerSetAside, AuctionSchema.this.DerivativeSellerSetAside)((buyerAside @ _), (sellerAside @ _)) => true
  case _ => false
})).flatMap[Unit](((x$5: (AuctionSchema.this.DerivativeBuyerSetAside, AuctionSchema.this.DerivativeSellerSetAside)) => (x$5: (AuctionSchema.this.DerivativeBuyerSetAside, AuctionSchema.this.DerivativeSellerSetAside) @unchecked) match {
          case (_1: AuctionSchema.this.DerivativeBuyerSetAside, _2: AuctionSchema.this.DerivativeSellerSetAside)(AuctionSchema.this.DerivativeBuyerSetAside, AuctionSchema.this.DerivativeSellerSetAside)((buyerAside @ _), (sellerAside @ _)) => new AuctionSchema.this.Won(model.this.Link.extract[AuctionSchema.this.Portfolio](bid.by)(AuctionSchema.this.portfolios), model.this.Link.extract[AuctionSchema.this.Portfolio](AuctionOfferOps.this.offerer)(AuctionSchema.this.portfolios), AuctionOfferOps.this.derivative, model.this.KL.toLink[AuctionSchema.this.DerivativeBuyerSetAside](buyerAside), model.this.KL.toLink[AuctionSchema.this.DerivativeSellerSetAside](sellerAside)).report().map[Unit](((_: AuctionSchema.this.NewsEvent) => ()))
        }))))
      }
    })
  };
  final object AuctionOffer extends java.lang.Object with ScalaObject with Serializable {
    def this(): object AuctionSchema.this.AuctionOffer = {
      AuctionOffer.super.this();
      ()
    };
    def byID(id: model.package.Key): AuctionSchema.this.AuctionOffer = AuctionSchema.this.auctionOffers.lookup(id).getOrElse[AuctionSchema.this.AuctionOffer](throw AuctionSchema.this.NoSuchAuction);
    <synthetic> def init$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
    case <synthetic> def unapply(x$0: AuctionSchema.this.AuctionOffer): Option[(model.package.Key, model.Derivative, model.Link[AuctionSchema.this.Portfolio], model.Dollars, org.joda.time.DateTime, org.joda.time.DateTime)] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(model.package.Key, model.Derivative, model.Link[AuctionSchema.this.Portfolio], model.Dollars, org.joda.time.DateTime, org.joda.time.DateTime)](new (model.package.Key, model.Derivative, model.Link[AuctionSchema.this.Portfolio], model.Dollars, org.joda.time.DateTime, org.joda.time.DateTime)(x$0.id, x$0.derivative, x$0.offerer, x$0.price, x$0.when, x$0.expires));
    case <synthetic> def apply(id: model.package.Key = model.this.`package`.nextID, derivative: model.Derivative, offerer: model.Link[AuctionSchema.this.Portfolio], price: model.Dollars, when: org.joda.time.DateTime, expires: org.joda.time.DateTime): AuctionSchema.this.AuctionOffer = new AuctionSchema.this.AuctionOffer(id, derivative, offerer, price, when, expires);
    <synthetic> def apply$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID
  };
  @volatile <synthetic> private[this] var AuctionOffer$module: object AuctionSchema.this.AuctionOffer = _;
  final <stable> def AuctionOffer: object AuctionSchema.this.AuctionOffer = new object AuctionSchema.this.AuctionOffer();
  abstract trait PortfolioWithAuctions extends java.lang.Object with ScalaObject { self: AuctionSchema.this.Portfolio => 
    def /*PortfolioWithAuctions*/$init$(): Unit = {
      ()
    };
    def auctionOffers: Seq[AuctionSchema.this.AuctionOffer] = AuctionSchema.this.auctionOffers.filter(((x$6: AuctionSchema.this.AuctionOffer) => x$6.offerer.~~(this))).toList;
    def userCastBid(auction: AuctionSchema.this.AuctionOffer, price: model.Dollars): (AuctionSchema.this.AuctionBid, AuctionSchema.this.NewsEvent) = AuctionSchema.this.editDB[(AuctionSchema.this.AuctionBid, AuctionSchema.this.NewsEvent)]({
      if (price.<=(auction.goingPrice))
        throw new AuctionSchema.this.BidTooSmall(auction.goingPrice)
      else
        ();
      AuctionSchema.this.toOps[AuctionSchema.this.AuctionBid]({
  val x$8: model.Link[AuctionSchema.this.AuctionOffer] = model.this.KL.toLink[AuctionSchema.this.AuctionOffer](auction);
  val x$9: model.Link[AuctionSchema.this.Portfolio] = model.this.KL.toLink[AuctionSchema.this.Portfolio](this);
  val x$10: model.Dollars = price;
  val x$11: model.package.Key = AuctionSchema.this.AuctionBid.apply$default$1;
  new AuctionSchema.this.AuctionBid(x$11, x$8, x$9, x$10)
}).insert(AuctionSchema.this.auctionBids).&[AuctionSchema.this.NewsEvent](new AuctionSchema.this.Bid(this, auction, price).report())
    })
  };
  def recentAuctions(n: Int): Seq[AuctionSchema.this.AuctionOffer] = AuctionSchema.this.auctionOffers.sortBy[Long](((x$7: AuctionSchema.this.AuctionOffer) => x$7.when.getMillis().unary_-))(math.this.Ordering.Long).take(n).toList
}
AuctionSchema: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.333
         systemC Auction recentA
 Auction                        
 Auction                        

final object PrintSchema extends java.lang.Object with ScalaObject {
  def this(): object code.snippet.PrintSchema = {
    PrintSchema.super.this();
    ()
  };
  def render: scala.xml.Elem = model.schema.readDB[scala.xml.Elem]({
    {
      new scala.xml.Elem(null, "pre", scala.xml.Null, scala.this.Predef.$scope, ({
        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
        $buf.&+(model.schema.schemaDDL);
        $buf
      }: _*))
    }
  })
}
PrintSchema: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
          render

final object ConstField extends java.lang.Object with ScalaObject {
  def this(): object intform.ConstField = {
    ConstField.super.this();
    ()
  };
  def apply[A >: Nothing <: Any](r: A): intform.ConstField[A] = new intform.ConstField[A](r)
}
ConstField: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
           apply

final object EventComment extends java.lang.Object with ScalaObject with Serializable {
  def this(): object CommentSchema.this.EventComment = {
    EventComment.super.this();
    ()
  };
  def byID(id: model.package.Key): CommentSchema.this.EventComment = CommentSchema.this.eventComments.lookup(id).getOrElse[CommentSchema.this.EventComment](throw CommentSchema.this.NoSuchComment);
  <synthetic> def init$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
  case <synthetic> def unapply(x$0: CommentSchema.this.EventComment): Option[(model.package.Key, CommentSchema.this.NewsEvent, CommentSchema.this.User, String, org.joda.time.DateTime)] = if (x$0.==(null))
    scala.this.None
  else
    new Some[(model.package.Key, CommentSchema.this.NewsEvent, CommentSchema.this.User, String, org.joda.time.DateTime)](new (model.package.Key, CommentSchema.this.NewsEvent, CommentSchema.this.User, String, org.joda.time.DateTime)(x$0.id, x$0.event, x$0.by, x$0.text, x$0.when));
  case <synthetic> def apply(id: model.package.Key = model.this.`package`.nextID, event: CommentSchema.this.NewsEvent, by: CommentSchema.this.User, text: String, when: org.joda.time.DateTime): CommentSchema.this.EventComment = new CommentSchema.this.EventComment(id, event, by, text, when);
  <synthetic> def apply$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID
}
EventComment: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
            byID

final case object NotLoggedIn extends scala.`package`.RuntimeException with ScalaObject with Product with Serializable {
  def this(): object code.control.LoginManager.NotLoggedIn = {
    NotLoggedIn.super.this();
    ()
  };
  final override def hashCode(): Int = -187442662;
  override def productPrefix: java.lang.String = "NotLoggedIn";
  override def productArity: Int = 0;
  override def productElement(x$1: Int): Any = x$1 match {
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[object code.control.LoginManager.NotLoggedIn]();
  protected def readResolve(): java.lang.Object = LoginManager.this.NotLoggedIn
}
NotLoggedIn: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
         readRes

class TestServlet extends HttpServlet {
  import TestServlet._;
  def this() = _;
  private[servlets] var i: Int = _;
  def doPost(request: HttpServletRequest = _, response: HttpServletResponse = _): Unit = _;
  def init(): Unit = _;
  def destroy(): Unit = _;
  def doGet(request: HttpServletRequest = _, response: HttpServletResponse = _): Unit = _
}
TestServlet: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.500
            init destroy   doGet  doPost
       i                                

final object DateTimeField extends java.lang.Object with ScalaObject {
  def this(): object intform.DateTimeField = {
    DateTimeField.super.this();
    ()
  };
  def apply(initial: org.joda.time.DateTime, formatter: org.joda.time.format.DateTimeFormatter): intform.DateTimeField = new DateTimeField(initial, formatter)
}
DateTimeField: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
           apply

final class $anon extends scala.AnyRef {
  def this(): anonymous class $anon = {
    $anon.super.this();
    ()
  };
  def toDate: org.joda.time.DateTime = DerivativeBuilder.this.formatter.parseDateTime(str)
}
$anon: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
          toDate

final case object NoSuchDerivativeLiability extends java.lang.RuntimeException with errors.package.BadUser with ScalaObject with Product with Serializable {
  def this(): object SchemaErrors.this.NoSuchDerivativeLiability = {
    NoSuchDerivativeLiability.super.this();
    ()
  };
  final override def hashCode(): Int = 1118876254;
  override def productPrefix: java.lang.String = "NoSuchDerivativeLiability";
  override def productArity: Int = 0;
  override def productElement(x$1: Int): Any = x$1 match {
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[object SchemaErrors.this.NoSuchDerivativeLiability]()
}
NoSuchDerivativeLiability: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

final case object NoSuchDerivativeAsset extends java.lang.RuntimeException with errors.package.BadUser with ScalaObject with Product with Serializable {
  def this(): object SchemaErrors.this.NoSuchDerivativeAsset = {
    NoSuchDerivativeAsset.super.this();
    ()
  };
  final override def hashCode(): Int = 109116609;
  override def productPrefix: java.lang.String = "NoSuchDerivativeAsset";
  override def productArity: Int = 0;
  override def productElement(x$1: Int): Any = x$1 match {
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[object SchemaErrors.this.NoSuchDerivativeAsset]()
}
NoSuchDerivativeAsset: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

final object UserLink extends java.lang.Object with ScalaObject {
  def this(): object code.snippet.UserLink = {
    UserLink.super.this();
    ()
  };
  def apply(user: model.schema.User): scala.xml.NodeSeq = model.schema.readDB[scala.xml.Elem]({
    val username: String = user.username;
    {
      {
        var $md: scala.xml.MetaData = scala.xml.Null;
        $md = new scala.xml.UnprefixedAttribute("href", scala.this.Predef.augmentString("/user?name=%s").format(username), $md);
        new scala.xml.Elem(null, "a", $md, scala.this.Predef.$scope, ({
          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
          $buf.&+(username);
          $buf
        }: _*))
      }
    }
  })
}
UserLink: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
           apply

final class $anon extends scala.AnyRef {
  def this(): anonymous class $anon = {
    $anon.super.this();
    ()
  };
  def insert(implicit table: model.Table[R]): Transactions.this.Transaction[R] = new Transactions.this.Transaction[R](rec, {
    <synthetic> val x$7: Transactions.this.Insert[R] = new Transactions.this.Insert[R](rec, table);
    immutable.this.Nil.::[Transactions.this.Insert[R]](x$7)
  });
  def update(by: R => R)(implicit table: model.Table[R]): Transactions.this.Transaction[Unit] = new Transactions.this.Transaction[Unit]((), {
    <synthetic> val x$8: Transactions.this.Update[R] = new Transactions.this.Update[R](rec, by, table);
    immutable.this.Nil.::[Transactions.this.Update[R]](x$8)
  });
  def delete(implicit table: model.Table[R]): Transactions.this.Transaction[R] = new Transactions.this.Transaction[R](rec, {
    <synthetic> val x$9: Transactions.this.Delete[R] = new Transactions.this.Delete[R](rec, table);
    immutable.this.Nil.::[Transactions.this.Delete[R]](x$9)
  });
  def refetch(implicit table: model.Table[R]): R = table.lookup(rec.id).getOrElse[R](throw Transactions.this.NotFound)
}
$anon: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.625
          update  delete refetch  insert

case class NodeSeqPlus extends java.lang.Object with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val n: scala.xml.NodeSeq = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def n: scala.xml.NodeSeq = NodeSeqPlus.this.n;
  def this(n: scala.xml.NodeSeq): intform.package.NodeSeqPlus = {
    NodeSeqPlus.super.this();
    ()
  };
  def leafMap(f: scala.xml.Elem => scala.xml.Elem): scala.xml.NodeSeq = NodeSeqPlus.this.n.map[scala.xml.Node, scala.xml.NodeSeq](((x$37: scala.xml.Node) => package.this.nodePlus(x$37).leafMap(f)))(xml.this.NodeSeq.canBuildFrom);
  <synthetic> def copy(n: scala.xml.NodeSeq = n): intform.package.NodeSeqPlus = new package.this.NodeSeqPlus(n);
  <synthetic> def copy$default$1: scala.xml.NodeSeq @scala.annotation.unchecked.uncheckedVariance = NodeSeqPlus.this.n;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(NodeSeqPlus.this);
  override def toString(): String = ScalaRunTime.this._toString(NodeSeqPlus.this);
  override def equals(x$1: Any): Boolean = NodeSeqPlus.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (n: scala.xml.NodeSeq)intform.package.NodeSeqPlus((n$1 @ _)) if n$1.==(n) => x$1.asInstanceOf[intform.package.NodeSeqPlus].canEqual(NodeSeqPlus.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "NodeSeqPlus";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => n
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[intform.package.NodeSeqPlus]()
}
NodeSeqPlus: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
         leafMap
       n     X  

final case object NotFound extends scala.`package`.RuntimeException with ScalaObject with Product with Serializable {
  def this(): object Links.this.NotFound = {
    NotFound.super.this();
    ()
  };
  final override def hashCode(): Int = 1617964175;
  override def productPrefix: java.lang.String = "NotFound";
  override def productArity: Int = 0;
  override def productElement(x$1: Int): Any = x$1 match {
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[object Links.this.NotFound]()
}
NotFound: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

class DateTimeField extends intform.TextField[org.joda.time.DateTime] with ScalaObject {
  <paramaccessor> private[this] val initial: org.joda.time.DateTime = _;
  <paramaccessor> private[this] val formatter: org.joda.time.format.DateTimeFormatter = _;
  def this(initial: org.joda.time.DateTime, formatter: org.joda.time.format.DateTimeFormatter): intform.DateTimeField = {
    DateTimeField.super.this(formatter.print(initial));
    ()
  };
  def produce(): intform.SubmitResult[org.joda.time.DateTime] = try {
    new intform.OK[org.joda.time.DateTime](DateTimeField.this.formatter.parseDateTime(DateTimeField.this.text))
  } catch {
    case _ => new intform.Error("Date is in the incorrect format.")
  }
}
DateTimeField: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
         produce
 initial        
 formatt     X  

class AuctionThumbnail extends java.lang.Object with code.comet.Refreshable with net.liftweb.common.Loggable with ScalaObject {
  def this(): code.comet.AuctionThumbnail = {
    AuctionThumbnail.super.this();
    ()
  };
  def registerWith: model.Table[model.schema.AuctionOffer] = model.schema.auctionOffers;
  def render: net.liftweb.http.RenderOut = AuctionThumbnail.this.nsToNsFuncToRenderOut(((in: scala.xml.NodeSeq) => model.schema.readDB[scala.xml.Elem]({
    val auctions: Seq[model.schema.AuctionOffer] = model.schema.recentAuctions(5);
    val items: Seq[scala.xml.Elem] = auctions.map[scala.xml.Elem, Seq[scala.xml.Elem]](((auc: model.schema.AuctionOffer) => {
      val from: model.Link[model.schema.Portfolio] = auc.offerer;
      val price: String = auc.goingPrice.$;
      val url: String = scala.this.Predef.augmentString("/auction?id=%s").format(auc.id);
      {
        {
          new scala.xml.Elem(null, "li", scala.xml.Null, scala.this.Predef.$scope, ({
            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
            $buf.&+({
              {
                var $md: scala.xml.MetaData = scala.xml.Null;
                $md = new scala.xml.UnprefixedAttribute("href", url, $md);
                new scala.xml.Elem(null, "a", $md, scala.this.Predef.$scope, ({
                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                  $buf.&+(new scala.xml.Text("from "));
                  $buf.&+(snippet.PortfolioLink.apply(model.this.Link.extract[model.schema.Portfolio](from)(model.schema.portfolios)));
                  $buf.&+(new scala.xml.Text(" for "));
                  $buf.&+(price);
                  $buf
                }: _*))
              }
            });
            $buf
          }: _*))
        }
      }
    }))(collection.this.Seq.canBuildFrom[scala.xml.Elem]);
    if (items.nonEmpty)
      {
        {
          new scala.xml.Elem(null, "ul", scala.xml.Null, scala.this.Predef.$scope, ({
            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
            $buf.&+(items);
            $buf
          }: _*))
        }
      }
    else
      {
        {
          var $md: scala.xml.MetaData = scala.xml.Null;
          $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("no_items"), $md);
          new scala.xml.Elem(null, "ul", $md, scala.this.Predef.$scope, ({
            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
            $buf.&+(new scala.xml.Text("[none]"));
            $buf
          }: _*))
        }
      }
  })))
}
AuctionThumbnail: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=1.000
         registe  render

final class $anon extends java.lang.Object with scalaz.Functor[Transactions.this.Transaction] {
  def this(): anonymous class $anon = {
    $anon.super.this();
    ()
  };
  def fmap[A >: Nothing <: Any, B >: Nothing <: Any](t: Transactions.this.Transaction[A], f: A => B): Transactions.this.Transaction[B] = t.map[B](f)
}
$anon: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
            fmap

final object theirPortfolio extends java.lang.Object with ScalaObject {
  def this(): object code.snippet.theirPortfolio = {
    theirPortfolio.super.this();
    ()
  };
  def apply(port: model.schema.Portfolio): scala.xml.NodeSeq = portfolio.apply(port, scala.None, false)
}
theirPortfolio: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
           apply

class Email_bg extends _root_.java.lang.Object {
  import Email_bg._;
  def this() = _
}
Email_bg: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

abstract trait BasicErrors extends java.lang.Object with ScalaObject {
  def /*BasicErrors*/$init$(): Unit = {
    ()
  };
  private[this] var error: Option[String] = scala.None;
  <accessor> def error: Option[String] = BasicErrors.this.error;
  <accessor> def error_=(x$1: Option[String]): Unit = BasicErrors.this.error = x$1;
  def isError: Boolean = BasicErrors.this.error.isDefined;
  def errorText: String = BasicErrors.this.error.getOrElse[String]("");
  def runWithErrors(cmd: => net.liftweb.http.js.JsCmd): net.liftweb.http.js.JsCmd = try {
    cmd
  } catch {
    case (msg: String)intform.BadInput((msg @ _)) => {
      BasicErrors.this.error_=(new Some[String](msg));
      net.liftweb.http.js.JsCmds.Noop
    }
    case (cause: intform.BasicErrors, msg: String)intform.BadFieldInput((cause @ _), (msg @ _)) => {
      cause.error_=(new Some[String](msg));
      net.liftweb.http.js.JsCmds.Noop
    }
    case (e @ (_: net.liftweb.util.LiftFlowOfControlException)) => throw e
    case (e @ (_: Throwable)) => {
      BasicErrors.this.error_=(new Some[java.lang.String]("An unknown error occurred (see log messages)"));
      {
        final class $anon extends java.lang.Object with net.liftweb.common.Logger {
          def this(): anonymous class $anon = {
            $anon.super.this();
            ()
          };
          $anon.this.error("Error in form submission", e)
        };
        new $anon()
      };
      throw e
    }
  }
}
BasicErrors: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=0.333
         errorTe runWith isError
   error     X       X       X  

case class DerivativeLiability extends java.lang.Object with model.KL with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val id: model.package.Key = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def id: model.package.Key = DerivativeLiability.this.id;
  <caseaccessor> <paramaccessor> private[this] val name: String = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def name: String = DerivativeLiability.this.name;
  <caseaccessor> <paramaccessor> private[this] val derivative: model.Derivative = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def derivative: model.Derivative = DerivativeLiability.this.derivative;
  <caseaccessor> <paramaccessor> private[this] val remaining: model.Scale = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def remaining: model.Scale = DerivativeLiability.this.remaining;
  <caseaccessor> <paramaccessor> private[this] val exec: org.joda.time.DateTime = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def exec: org.joda.time.DateTime = DerivativeLiability.this.exec;
  <caseaccessor> <paramaccessor> private[this] val owner: model.Link[DerivativeSchema.this.Portfolio] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def owner: model.Link[DerivativeSchema.this.Portfolio] = DerivativeLiability.this.owner;
  <caseaccessor> <paramaccessor> private[this] val hidden: Boolean = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def hidden: Boolean = DerivativeLiability.this.hidden;
  def this(id: model.package.Key = model.this.`package`.nextID, name: String, derivative: model.Derivative, remaining: model.Scale, exec: org.joda.time.DateTime, owner: model.Link[DerivativeSchema.this.Portfolio], hidden: Boolean): DerivativeSchema.this.DerivativeLiability = {
    DerivativeLiability.super.this();
    ()
  };
  <synthetic> def copy(id: model.package.Key = id, name: String = name, derivative: model.Derivative = derivative, remaining: model.Scale = remaining, exec: org.joda.time.DateTime = exec, owner: model.Link[DerivativeSchema.this.Portfolio] = owner, hidden: Boolean = hidden): DerivativeSchema.this.DerivativeLiability = new DerivativeSchema.this.DerivativeLiability(id, name, derivative, remaining, exec, owner, hidden);
  <synthetic> def copy$default$7: Boolean @scala.annotation.unchecked.uncheckedVariance = DerivativeLiability.this.hidden;
  <synthetic> def copy$default$6: model.Link[DerivativeSchema.this.Portfolio] @scala.annotation.unchecked.uncheckedVariance = DerivativeLiability.this.owner;
  <synthetic> def copy$default$5: org.joda.time.DateTime @scala.annotation.unchecked.uncheckedVariance = DerivativeLiability.this.exec;
  <synthetic> def copy$default$4: model.Scale @scala.annotation.unchecked.uncheckedVariance = DerivativeLiability.this.remaining;
  <synthetic> def copy$default$3: model.Derivative @scala.annotation.unchecked.uncheckedVariance = DerivativeLiability.this.derivative;
  <synthetic> def copy$default$2: String @scala.annotation.unchecked.uncheckedVariance = DerivativeLiability.this.name;
  <synthetic> def copy$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = DerivativeLiability.this.id;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(DerivativeLiability.this);
  override def toString(): String = ScalaRunTime.this._toString(DerivativeLiability.this);
  override def equals(x$1: Any): Boolean = DerivativeLiability.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (id: model.package.Key, name: String, derivative: model.Derivative, remaining: model.Scale, exec: org.joda.time.DateTime, owner: model.Link[DerivativeSchema.this.Portfolio], hidden: Boolean)DerivativeSchema.this.DerivativeLiability((id$2 @ _), (name$1 @ _), (derivative$1 @ _), (remaining$1 @ _), (exec$1 @ _), (owner$2 @ _), (hidden$2 @ _)) if id$2.==(id).&&(name$1.==(name)).&&(derivative$1.==(derivative)).&&(remaining$1.==(remaining)).&&(exec$1.==(exec)).&&(owner$2.==(owner)).&&(hidden$2.==(hidden)) => x$1.asInstanceOf[DerivativeSchema.this.DerivativeLiability].canEqual(DerivativeLiability.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "DerivativeLiability";
  override def productArity: Int = 7;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => id
    case 1 => name
    case 2 => derivative
    case 3 => remaining
    case 4 => exec
    case 5 => owner
    case 6 => hidden
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[DerivativeSchema.this.DerivativeLiability]()
}
DerivativeLiability: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
  hidden
    name
   owner
    exec
 derivat
 remaini
      id

final class $anon extends intform.DateTimeField with intform.FieldErrorRender {
  def this(): anonymous class $anon = {
    $anon.super.this(DerivativeBuilder.this.tomorrow, DerivativeBuilder.this.formatter);
    ()
  }
}
$anon: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

final object Submit extends java.lang.Object with ScalaObject {
  def this(): object intform.Submit = {
    Submit.super.this();
    ()
  };
  def apply[A >: Nothing <: Any](form: => intform.Form[A], value: String, refresh: Boolean = true)(callback: A => net.liftweb.http.js.JsCmd): intform.Submit[A] = new intform.Submit[A]((() => form), callback, value, refresh);
  <synthetic> def apply$default$3[A >: Nothing <: Any]: Boolean @scala.annotation.unchecked.uncheckedVariance = true;
  def cancel(r: intform.Refreshable, text: String)(callback: => net.liftweb.http.js.JsCmd): java.lang.Object with intform.SubmitRender with intform.BasicErrors with intform.ErrorRender = {
    final class $anon extends java.lang.Object with intform.SubmitRender with intform.BasicErrors with intform.ErrorRender {
      def this(): anonymous class $anon = {
        $anon.super.this();
        ()
      };
      private[this] val value: String = text;
      <stable> <accessor> def value: String = $anon.this.value;
      def submitAjax(): net.liftweb.http.js.JsCmd = $anon.this.runWithErrors(callback).&(r.refresh())
    };
    new $anon()
  }
}
Submit: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.583
           apply  cancel

case class HaveQuote extends java.lang.Object with SearchBar.this.Status with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val quote: stockdata.Quote = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def quote: stockdata.Quote = HaveQuote.this.quote;
  def this(quote: stockdata.Quote): SearchBar.this.HaveQuote = {
    HaveQuote.super.this();
    ()
  };
  <synthetic> def copy(quote: stockdata.Quote = quote): SearchBar.this.HaveQuote = new SearchBar.this.HaveQuote(quote);
  <synthetic> def copy$default$1: stockdata.Quote @scala.annotation.unchecked.uncheckedVariance = HaveQuote.this.quote;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(HaveQuote.this);
  override def toString(): String = ScalaRunTime.this._toString(HaveQuote.this);
  override def equals(x$1: Any): Boolean = HaveQuote.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (quote: stockdata.Quote)SearchBar.this.HaveQuote((quote$1 @ _)) if quote$1.==(quote) => x$1.asInstanceOf[SearchBar.this.HaveQuote].canEqual(HaveQuote.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "HaveQuote";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => quote
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[SearchBar.this.HaveQuote]()
}
HaveQuote: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
   quote

abstract trait PortfolioWithAuctions extends java.lang.Object with ScalaObject { self: AuctionSchema.this.Portfolio => 
  def /*PortfolioWithAuctions*/$init$(): Unit = {
    ()
  };
  def auctionOffers: Seq[AuctionSchema.this.AuctionOffer] = AuctionSchema.this.auctionOffers.filter(((x$6: AuctionSchema.this.AuctionOffer) => x$6.offerer.~~(this))).toList;
  def userCastBid(auction: AuctionSchema.this.AuctionOffer, price: model.Dollars): (AuctionSchema.this.AuctionBid, AuctionSchema.this.NewsEvent) = AuctionSchema.this.editDB[(AuctionSchema.this.AuctionBid, AuctionSchema.this.NewsEvent)]({
    if (price.<=(auction.goingPrice))
      throw new AuctionSchema.this.BidTooSmall(auction.goingPrice)
    else
      ();
    AuctionSchema.this.toOps[AuctionSchema.this.AuctionBid]({
  val x$8: model.Link[AuctionSchema.this.AuctionOffer] = model.this.KL.toLink[AuctionSchema.this.AuctionOffer](auction);
  val x$9: model.Link[AuctionSchema.this.Portfolio] = model.this.KL.toLink[AuctionSchema.this.Portfolio](this);
  val x$10: model.Dollars = price;
  val x$11: model.package.Key = AuctionSchema.this.AuctionBid.apply$default$1;
  new AuctionSchema.this.AuctionBid(x$11, x$8, x$9, x$10)
}).insert(AuctionSchema.this.auctionBids).&[AuctionSchema.this.NewsEvent](new AuctionSchema.this.Bid(this, auction, price).report())
  })
}
PortfolioWithAuctions: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.500
         auction userCas

final object StockPriceSource extends stockdata.CachedStockDatabase with ScalaObject {
  def this(): object model.StockPriceSource = {
    StockPriceSource.super.this(new stockdata.FailoverStockDatabase(immutable.this.List.apply[ScalaObject with stockdata.StockDatabase](new stockdata.YahooCSVStockDatabase(new stockdata.HttpQueryService("GET")), new stockdata.YahooStockDatabase(new stockdata.HttpQueryService("GET")))), new org.joda.time.Duration(300000L));
    ()
  }
}
StockPriceSource: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

class News extends java.lang.Object with code.comet.Refreshable with net.liftweb.common.Loggable with ScalaObject {
  def this(): code.comet.News = {
    News.super.this();
    ()
  };
  def registerWith: model.Table[model.schema.NewsEvent] = model.schema.newsEvents;
  def render: net.liftweb.http.RenderOut = News.this.nsToNsFuncToRenderOut(((in: scala.xml.NodeSeq) => model.schema.readDB[scala.xml.Elem]({
    {
      var $md: scala.xml.MetaData = scala.xml.Null;
      $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("news"), $md);
      new scala.xml.Elem(null, "ul", $md, scala.this.Predef.$scope, ({
        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
        $buf.&+(new scala.xml.Text(" "));
        $buf.&+(News.this.newsContents);
        $buf.&+(new scala.xml.Text(" "));
        $buf
      }: _*))
    }
  })));
  def newsContents: scala.collection.immutable.Seq[scala.xml.Node] = {
    val items: List[scala.xml.Elem] = model.schema.recentEvents(10).map[scala.xml.Elem, List[scala.xml.Elem]](((ev: model.schema.NewsEvent) => {
      {
        var $md: scala.xml.MetaData = scala.xml.Null;
        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("event"), $md);
        new scala.xml.Elem(null, "li", $md, scala.this.Predef.$scope, ({
          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
          $buf.&+(new scala.xml.Text("\012                "));
          $buf.&+(News.eventBriefTally(ev));
          $buf.&+(new scala.xml.Text("\012                "));
          $buf.&+(News.eventDescription(ev, true));
          $buf.&+(new scala.xml.Text("\012                ("));
          $buf.&+(News.link(ev, ev.numComments.+(" comments")));
          $buf.&+(new scala.xml.Text(")\012            "));
          $buf
        }: _*))
      }
    }))(immutable.this.List.canBuildFrom[scala.xml.Elem]);
    if (items.nonEmpty)
      items
    else
      {
        {
          var $md: scala.xml.MetaData = scala.xml.Null;
          $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("event no_items"), $md);
          new scala.xml.Elem(null, "li", $md, scala.this.Predef.$scope, ({
            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
            $buf.&+(new scala.xml.Text("[none]"));
            $buf
          }: _*))
        }
      }
  }
}
News: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=1.000
          render newsCon registe

case class Message extends java.lang.Object with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val username: String = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def username: String = Message.this.username;
  <caseaccessor> <paramaccessor> private[this] val command: String = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def command: String = Message.this.command;
  <caseaccessor> <paramaccessor> private[this] val reply: texttrading.Reply = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def reply: texttrading.Reply = Message.this.reply;
  def this(username: String, command: String, reply: texttrading.Reply): texttrading.Message = {
    Message.super.this();
    ()
  };
  <synthetic> def copy(username: String = username, command: String = command, reply: texttrading.Reply = reply): texttrading.Message = new texttrading.this.Message(username, command, reply);
  <synthetic> def copy$default$3: texttrading.Reply @scala.annotation.unchecked.uncheckedVariance = Message.this.reply;
  <synthetic> def copy$default$2: String @scala.annotation.unchecked.uncheckedVariance = Message.this.command;
  <synthetic> def copy$default$1: String @scala.annotation.unchecked.uncheckedVariance = Message.this.username;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(Message.this);
  override def toString(): String = ScalaRunTime.this._toString(Message.this);
  override def equals(x$1: Any): Boolean = Message.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (username: String, command: String, reply: texttrading.Reply)texttrading.Message((username$1 @ _), (command$1 @ _), (reply$1 @ _)) if username$1.==(username).&&(command$1.==(command)).&&(reply$1.==(reply)) => x$1.asInstanceOf[texttrading.Message].canEqual(Message.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "Message";
  override def productArity: Int = 3;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => username
    case 1 => command
    case 2 => reply
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[texttrading.Message]()
}
Message: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
   reply
 command
 usernam

abstract trait DerivativeSchema extends java.lang.Object with ScalaObject { schema: model.DerivativeSchema with model.UserSchema with model.DBMagic with model.NewsSchema with model.AuctionSchema with model.SchemaErrors with model.VotingSchema => 
  def /*DerivativeSchema*/$init$(): Unit = {
    ()
  };
  private[this] val derivativeAssets: model.Table[DerivativeSchema.this.DerivativeAsset] = DerivativeSchema.this.table[DerivativeSchema.this.DerivativeAsset];
  implicit <stable> <accessor> def derivativeAssets: model.Table[DerivativeSchema.this.DerivativeAsset] = DerivativeSchema.this.derivativeAssets;
  private[this] val derivativeLiabilities: model.Table[DerivativeSchema.this.DerivativeLiability] = DerivativeSchema.this.table[DerivativeSchema.this.DerivativeLiability];
  implicit <stable> <accessor> def derivativeLiabilities: model.Table[DerivativeSchema.this.DerivativeLiability] = DerivativeSchema.this.derivativeLiabilities;
  private[this] val derivativeOffers: model.Table[DerivativeSchema.this.DerivativeOffer] = DerivativeSchema.this.table[DerivativeSchema.this.DerivativeOffer];
  implicit <stable> <accessor> def derivativeOffers: model.Table[DerivativeSchema.this.DerivativeOffer] = DerivativeSchema.this.derivativeOffers;
  case class DerivativeAsset extends java.lang.Object with model.KL with DerivativeSchema.this.DerivativeAssetOps with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val id: model.package.Key = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def id: model.package.Key = DerivativeAsset.this.id;
    <caseaccessor> <paramaccessor> private[this] val peer: model.Link[DerivativeSchema.this.DerivativeLiability] = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def peer: model.Link[DerivativeSchema.this.DerivativeLiability] = DerivativeAsset.this.peer;
    <caseaccessor> <paramaccessor> private[this] val scale: model.Scale = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def scale: model.Scale = DerivativeAsset.this.scale;
    <caseaccessor> <paramaccessor> private[this] val owner: model.Link[DerivativeSchema.this.Portfolio] = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def owner: model.Link[DerivativeSchema.this.Portfolio] = DerivativeAsset.this.owner;
    <caseaccessor> <paramaccessor> private[this] val hidden: Boolean = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def hidden: Boolean = DerivativeAsset.this.hidden;
    def this(id: model.package.Key = model.this.`package`.nextID, peer: model.Link[DerivativeSchema.this.DerivativeLiability], scale: model.Scale, owner: model.Link[DerivativeSchema.this.Portfolio], hidden: Boolean): DerivativeSchema.this.DerivativeAsset = {
      DerivativeAsset.super.this();
      ()
    };
    <synthetic> def copy(id: model.package.Key = id, peer: model.Link[DerivativeSchema.this.DerivativeLiability] = peer, scale: model.Scale = scale, owner: model.Link[DerivativeSchema.this.Portfolio] = owner, hidden: Boolean = hidden): DerivativeSchema.this.DerivativeAsset = new DerivativeSchema.this.DerivativeAsset(id, peer, scale, owner, hidden);
    <synthetic> def copy$default$5: Boolean @scala.annotation.unchecked.uncheckedVariance = DerivativeAsset.this.hidden;
    <synthetic> def copy$default$4: model.Link[DerivativeSchema.this.Portfolio] @scala.annotation.unchecked.uncheckedVariance = DerivativeAsset.this.owner;
    <synthetic> def copy$default$3: model.Scale @scala.annotation.unchecked.uncheckedVariance = DerivativeAsset.this.scale;
    <synthetic> def copy$default$2: model.Link[DerivativeSchema.this.DerivativeLiability] @scala.annotation.unchecked.uncheckedVariance = DerivativeAsset.this.peer;
    <synthetic> def copy$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = DerivativeAsset.this.id;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(DerivativeAsset.this);
    override def toString(): String = ScalaRunTime.this._toString(DerivativeAsset.this);
    override def equals(x$1: Any): Boolean = DerivativeAsset.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (id: model.package.Key, peer: model.Link[DerivativeSchema.this.DerivativeLiability], scale: model.Scale, owner: model.Link[DerivativeSchema.this.Portfolio], hidden: Boolean)DerivativeSchema.this.DerivativeAsset((id$1 @ _), (peer$1 @ _), (scale$1 @ _), (owner$1 @ _), (hidden$1 @ _)) if id$1.==(id).&&(peer$1.==(peer)).&&(scale$1.==(scale)).&&(owner$1.==(owner)).&&(hidden$1.==(hidden)) => x$1.asInstanceOf[DerivativeSchema.this.DerivativeAsset].canEqual(DerivativeAsset.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "DerivativeAsset";
    override def productArity: Int = 5;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => id
      case 1 => peer
      case 2 => scale
      case 3 => owner
      case 4 => hidden
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[DerivativeSchema.this.DerivativeAsset]()
  };
  final <synthetic> object DerivativeAsset extends scala.runtime.AbstractFunction5[model.package.Key,model.Link[DerivativeSchema.this.DerivativeLiability],model.Scale,model.Link[DerivativeSchema.this.Portfolio],Boolean,DerivativeSchema.this.DerivativeAsset] with ScalaObject with Serializable {
    def this(): object DerivativeSchema.this.DerivativeAsset = {
      DerivativeAsset.super.this();
      ()
    };
    final override def toString(): java.lang.String = "DerivativeAsset";
    <synthetic> def init$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
    <synthetic> def apply$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
    case <synthetic> def unapply(x$0: DerivativeSchema.this.DerivativeAsset): Option[(model.package.Key, model.Link[DerivativeSchema.this.DerivativeLiability], model.Scale, model.Link[DerivativeSchema.this.Portfolio], Boolean)] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(model.package.Key, model.Link[DerivativeSchema.this.DerivativeLiability], model.Scale, model.Link[DerivativeSchema.this.Portfolio], Boolean)](new (model.package.Key, model.Link[DerivativeSchema.this.DerivativeLiability], model.Scale, model.Link[DerivativeSchema.this.Portfolio], Boolean)(x$0.id, x$0.peer, x$0.scale, x$0.owner, x$0.hidden));
    case <synthetic> def apply(id: model.package.Key = model.this.`package`.nextID, peer: model.Link[DerivativeSchema.this.DerivativeLiability], scale: model.Scale, owner: model.Link[DerivativeSchema.this.Portfolio], hidden: Boolean): DerivativeSchema.this.DerivativeAsset = new DerivativeSchema.this.DerivativeAsset(id, peer, scale, owner, hidden)
  };
  @volatile <synthetic> private[this] var DerivativeAsset$module: object DerivativeSchema.this.DerivativeAsset = _;
  final <synthetic> <stable> def DerivativeAsset: object DerivativeSchema.this.DerivativeAsset = new object DerivativeSchema.this.DerivativeAsset();
  case class DerivativeLiability extends java.lang.Object with model.KL with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val id: model.package.Key = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def id: model.package.Key = DerivativeLiability.this.id;
    <caseaccessor> <paramaccessor> private[this] val name: String = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def name: String = DerivativeLiability.this.name;
    <caseaccessor> <paramaccessor> private[this] val derivative: model.Derivative = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def derivative: model.Derivative = DerivativeLiability.this.derivative;
    <caseaccessor> <paramaccessor> private[this] val remaining: model.Scale = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def remaining: model.Scale = DerivativeLiability.this.remaining;
    <caseaccessor> <paramaccessor> private[this] val exec: org.joda.time.DateTime = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def exec: org.joda.time.DateTime = DerivativeLiability.this.exec;
    <caseaccessor> <paramaccessor> private[this] val owner: model.Link[DerivativeSchema.this.Portfolio] = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def owner: model.Link[DerivativeSchema.this.Portfolio] = DerivativeLiability.this.owner;
    <caseaccessor> <paramaccessor> private[this] val hidden: Boolean = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def hidden: Boolean = DerivativeLiability.this.hidden;
    def this(id: model.package.Key = model.this.`package`.nextID, name: String, derivative: model.Derivative, remaining: model.Scale, exec: org.joda.time.DateTime, owner: model.Link[DerivativeSchema.this.Portfolio], hidden: Boolean): DerivativeSchema.this.DerivativeLiability = {
      DerivativeLiability.super.this();
      ()
    };
    <synthetic> def copy(id: model.package.Key = id, name: String = name, derivative: model.Derivative = derivative, remaining: model.Scale = remaining, exec: org.joda.time.DateTime = exec, owner: model.Link[DerivativeSchema.this.Portfolio] = owner, hidden: Boolean = hidden): DerivativeSchema.this.DerivativeLiability = new DerivativeSchema.this.DerivativeLiability(id, name, derivative, remaining, exec, owner, hidden);
    <synthetic> def copy$default$7: Boolean @scala.annotation.unchecked.uncheckedVariance = DerivativeLiability.this.hidden;
    <synthetic> def copy$default$6: model.Link[DerivativeSchema.this.Portfolio] @scala.annotation.unchecked.uncheckedVariance = DerivativeLiability.this.owner;
    <synthetic> def copy$default$5: org.joda.time.DateTime @scala.annotation.unchecked.uncheckedVariance = DerivativeLiability.this.exec;
    <synthetic> def copy$default$4: model.Scale @scala.annotation.unchecked.uncheckedVariance = DerivativeLiability.this.remaining;
    <synthetic> def copy$default$3: model.Derivative @scala.annotation.unchecked.uncheckedVariance = DerivativeLiability.this.derivative;
    <synthetic> def copy$default$2: String @scala.annotation.unchecked.uncheckedVariance = DerivativeLiability.this.name;
    <synthetic> def copy$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = DerivativeLiability.this.id;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(DerivativeLiability.this);
    override def toString(): String = ScalaRunTime.this._toString(DerivativeLiability.this);
    override def equals(x$1: Any): Boolean = DerivativeLiability.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (id: model.package.Key, name: String, derivative: model.Derivative, remaining: model.Scale, exec: org.joda.time.DateTime, owner: model.Link[DerivativeSchema.this.Portfolio], hidden: Boolean)DerivativeSchema.this.DerivativeLiability((id$2 @ _), (name$1 @ _), (derivative$1 @ _), (remaining$1 @ _), (exec$1 @ _), (owner$2 @ _), (hidden$2 @ _)) if id$2.==(id).&&(name$1.==(name)).&&(derivative$1.==(derivative)).&&(remaining$1.==(remaining)).&&(exec$1.==(exec)).&&(owner$2.==(owner)).&&(hidden$2.==(hidden)) => x$1.asInstanceOf[DerivativeSchema.this.DerivativeLiability].canEqual(DerivativeLiability.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "DerivativeLiability";
    override def productArity: Int = 7;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => id
      case 1 => name
      case 2 => derivative
      case 3 => remaining
      case 4 => exec
      case 5 => owner
      case 6 => hidden
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[DerivativeSchema.this.DerivativeLiability]()
  };
  case class DerivativeOffer extends java.lang.Object with model.KL with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val id: model.package.Key = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def id: model.package.Key = DerivativeOffer.this.id;
    <caseaccessor> <paramaccessor> private[this] val derivative: model.Derivative = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def derivative: model.Derivative = DerivativeOffer.this.derivative;
    <caseaccessor> <paramaccessor> private[this] val from: model.Link[DerivativeSchema.this.Portfolio] = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def from: model.Link[DerivativeSchema.this.Portfolio] = DerivativeOffer.this.from;
    <caseaccessor> <paramaccessor> private[this] val to: model.Link[DerivativeSchema.this.Portfolio] = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def to: model.Link[DerivativeSchema.this.Portfolio] = DerivativeOffer.this.to;
    <caseaccessor> <paramaccessor> private[this] val price: model.Dollars = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def price: model.Dollars = DerivativeOffer.this.price;
    <caseaccessor> <paramaccessor> private[this] val expires: org.joda.time.DateTime = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def expires: org.joda.time.DateTime = DerivativeOffer.this.expires;
    def this(id: model.package.Key = model.this.`package`.nextID, derivative: model.Derivative, from: model.Link[DerivativeSchema.this.Portfolio], to: model.Link[DerivativeSchema.this.Portfolio], price: model.Dollars, expires: org.joda.time.DateTime): DerivativeSchema.this.DerivativeOffer = {
      DerivativeOffer.super.this();
      ()
    };
    <synthetic> def copy(id: model.package.Key = id, derivative: model.Derivative = derivative, from: model.Link[DerivativeSchema.this.Portfolio] = from, to: model.Link[DerivativeSchema.this.Portfolio] = to, price: model.Dollars = price, expires: org.joda.time.DateTime = expires): DerivativeSchema.this.DerivativeOffer = new DerivativeSchema.this.DerivativeOffer(id, derivative, from, to, price, expires);
    <synthetic> def copy$default$6: org.joda.time.DateTime @scala.annotation.unchecked.uncheckedVariance = DerivativeOffer.this.expires;
    <synthetic> def copy$default$5: model.Dollars @scala.annotation.unchecked.uncheckedVariance = DerivativeOffer.this.price;
    <synthetic> def copy$default$4: model.Link[DerivativeSchema.this.Portfolio] @scala.annotation.unchecked.uncheckedVariance = DerivativeOffer.this.to;
    <synthetic> def copy$default$3: model.Link[DerivativeSchema.this.Portfolio] @scala.annotation.unchecked.uncheckedVariance = DerivativeOffer.this.from;
    <synthetic> def copy$default$2: model.Derivative @scala.annotation.unchecked.uncheckedVariance = DerivativeOffer.this.derivative;
    <synthetic> def copy$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = DerivativeOffer.this.id;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(DerivativeOffer.this);
    override def toString(): String = ScalaRunTime.this._toString(DerivativeOffer.this);
    override def equals(x$1: Any): Boolean = DerivativeOffer.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (id: model.package.Key, derivative: model.Derivative, from: model.Link[DerivativeSchema.this.Portfolio], to: model.Link[DerivativeSchema.this.Portfolio], price: model.Dollars, expires: org.joda.time.DateTime)DerivativeSchema.this.DerivativeOffer((id$3 @ _), (derivative$2 @ _), (from$1 @ _), (to$1 @ _), (price$1 @ _), (expires$1 @ _)) if id$3.==(id).&&(derivative$2.==(derivative)).&&(from$1.==(from)).&&(to$1.==(to)).&&(price$1.==(price)).&&(expires$1.==(expires)) => x$1.asInstanceOf[DerivativeSchema.this.DerivativeOffer].canEqual(DerivativeOffer.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "DerivativeOffer";
    override def productArity: Int = 6;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => id
      case 1 => derivative
      case 2 => from
      case 3 => to
      case 4 => price
      case 5 => expires
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[DerivativeSchema.this.DerivativeOffer]()
  };
  final <synthetic> object DerivativeOffer extends scala.runtime.AbstractFunction6[model.package.Key,model.Derivative,model.Link[DerivativeSchema.this.Portfolio],model.Link[DerivativeSchema.this.Portfolio],model.Dollars,org.joda.time.DateTime,DerivativeSchema.this.DerivativeOffer] with ScalaObject with Serializable {
    def this(): object DerivativeSchema.this.DerivativeOffer = {
      DerivativeOffer.super.this();
      ()
    };
    final override def toString(): java.lang.String = "DerivativeOffer";
    <synthetic> def apply$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
    <synthetic> def init$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
    case <synthetic> def unapply(x$0: DerivativeSchema.this.DerivativeOffer): Option[(model.package.Key, model.Derivative, model.Link[DerivativeSchema.this.Portfolio], model.Link[DerivativeSchema.this.Portfolio], model.Dollars, org.joda.time.DateTime)] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(model.package.Key, model.Derivative, model.Link[DerivativeSchema.this.Portfolio], model.Link[DerivativeSchema.this.Portfolio], model.Dollars, org.joda.time.DateTime)](new (model.package.Key, model.Derivative, model.Link[DerivativeSchema.this.Portfolio], model.Link[DerivativeSchema.this.Portfolio], model.Dollars, org.joda.time.DateTime)(x$0.id, x$0.derivative, x$0.from, x$0.to, x$0.price, x$0.expires));
    case <synthetic> def apply(id: model.package.Key = model.this.`package`.nextID, derivative: model.Derivative, from: model.Link[DerivativeSchema.this.Portfolio], to: model.Link[DerivativeSchema.this.Portfolio], price: model.Dollars, expires: org.joda.time.DateTime): DerivativeSchema.this.DerivativeOffer = new DerivativeSchema.this.DerivativeOffer(id, derivative, from, to, price, expires)
  };
  @volatile <synthetic> private[this] var DerivativeOffer$module: object DerivativeSchema.this.DerivativeOffer = _;
  final <synthetic> <stable> def DerivativeOffer: object DerivativeSchema.this.DerivativeOffer = new object DerivativeSchema.this.DerivativeOffer();
  def systemCheckForExercise(): Unit = DerivativeSchema.this.logger.info("TODO: This");
  abstract trait DerivativeAssetOps extends java.lang.Object with ScalaObject { self: DerivativeSchema.this.DerivativeAsset => 
    def /*DerivativeAssetOps*/$init$(): Unit = {
      ()
    };
    def derivative: model.Derivative = model.this.Link.extract[DerivativeSchema.this.DerivativeLiability](DerivativeAssetOps.this.peer)(DerivativeSchema.this.derivativeLiabilities).derivative;
    def userExecuteManually(): Unit = scala.sys.`package`.error("Not implemented");
    def spotValue: model.Dollars = DerivativeAssetOps.this.derivative.spotValue.*(DerivativeAssetOps.this.scale)
  };
  final object DerivativeLiability extends java.lang.Object with ScalaObject with Serializable {
    def this(): object DerivativeSchema.this.DerivativeLiability = {
      DerivativeLiability.super.this();
      ()
    };
    def byName(name: String): DerivativeSchema.this.DerivativeLiability = DerivativeSchema.this.derivativeLiabilities.filter(((x$1: DerivativeSchema.this.DerivativeLiability) => x$1.name.==(name))).headOption.getOrElse[DerivativeSchema.this.DerivativeLiability](throw DerivativeSchema.this.NoSuchDerivativeLiability);
    <synthetic> def init$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
    <synthetic> def apply$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
    case <synthetic> def unapply(x$0: DerivativeSchema.this.DerivativeLiability): Option[(model.package.Key, String, model.Derivative, model.Scale, org.joda.time.DateTime, model.Link[DerivativeSchema.this.Portfolio], Boolean)] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(model.package.Key, String, model.Derivative, model.Scale, org.joda.time.DateTime, model.Link[DerivativeSchema.this.Portfolio], Boolean)](new (model.package.Key, String, model.Derivative, model.Scale, org.joda.time.DateTime, model.Link[DerivativeSchema.this.Portfolio], Boolean)(x$0.id, x$0.name, x$0.derivative, x$0.remaining, x$0.exec, x$0.owner, x$0.hidden));
    case <synthetic> def apply(id: model.package.Key = model.this.`package`.nextID, name: String, derivative: model.Derivative, remaining: model.Scale, exec: org.joda.time.DateTime, owner: model.Link[DerivativeSchema.this.Portfolio], hidden: Boolean): DerivativeSchema.this.DerivativeLiability = new DerivativeSchema.this.DerivativeLiability(id, name, derivative, remaining, exec, owner, hidden)
  };
  @volatile <synthetic> private[this] var DerivativeLiability$module: object DerivativeSchema.this.DerivativeLiability = _;
  final <stable> def DerivativeLiability: object DerivativeSchema.this.DerivativeLiability = new object DerivativeSchema.this.DerivativeLiability();
  abstract trait PortfolioWithDerivatives extends java.lang.Object with ScalaObject { self: DerivativeSchema.this.Portfolio => 
    def /*PortfolioWithDerivatives*/$init$(): Unit = {
      ()
    };
    def myDerivativeAssets: List[DerivativeSchema.this.DerivativeAsset] = DerivativeSchema.this.derivativeAssets.filter(((x$2: DerivativeSchema.this.DerivativeAsset) => x$2.owner.~~(this))).toList;
    def myDerivativeLiabilities: List[DerivativeSchema.this.DerivativeLiability] = DerivativeSchema.this.derivativeLiabilities.filter(((x$3: DerivativeSchema.this.DerivativeLiability) => x$3.owner.~~(this))).toList;
    def myDerivativeOffers: List[DerivativeSchema.this.DerivativeOffer] = DerivativeSchema.this.derivativeOffers.filter(((x$4: DerivativeSchema.this.DerivativeOffer) => x$4.to.~~(this))).toList;
    def userOfferDerivativeTo(recip: DerivativeSchema.this.Portfolio, deriv: model.Derivative, price: model.Dollars): DerivativeSchema.this.DerivativeOffer = DerivativeSchema.this.editDB[DerivativeSchema.this.DerivativeOffer](DerivativeSchema.this.toOps[DerivativeSchema.this.DerivativeOffer]({
  val x$35: model.Derivative = deriv;
  val x$36: model.Link[DerivativeSchema.this.Portfolio] = model.this.KL.toLink[DerivativeSchema.this.Portfolio](this);
  val x$37: model.Link[DerivativeSchema.this.Portfolio] = model.this.KL.toLink[DerivativeSchema.this.Portfolio](recip);
  val x$38: model.Dollars = price;
  val x$39: org.joda.time.DateTime = new org.joda.time.DateTime();
  val x$40: model.package.Key = DerivativeSchema.this.DerivativeOffer.apply$default$1;
  new DerivativeSchema.this.DerivativeOffer(x$40, x$35, x$36, x$37, x$38, x$39)
}).insert(DerivativeSchema.this.derivativeOffers).flatMap[DerivativeSchema.this.DerivativeOffer](((offer: DerivativeSchema.this.DerivativeOffer) => new DerivativeSchema.this.Offered(this, recip, deriv, price).report().map[DerivativeSchema.this.DerivativeOffer](((_: DerivativeSchema.this.NewsEvent) => offer)))));
    def userOfferDerivativeAtAuction(deriv: model.Derivative, price: model.Dollars, expires: org.joda.time.DateTime): Unit = DerivativeSchema.this.editDB[Unit](DerivativeSchema.this.toOps[DerivativeSchema.this.AuctionOffer]({
  val x$41: model.Derivative = deriv;
  val x$42: model.Link[DerivativeSchema.this.Portfolio] = model.this.KL.toLink[DerivativeSchema.this.Portfolio](this);
  val x$43: model.Dollars = price;
  val x$44: org.joda.time.DateTime = new org.joda.time.DateTime();
  val x$45: org.joda.time.DateTime = expires;
  val x$46: model.package.Key = DerivativeSchema.this.AuctionOffer.apply$default$1;
  new DerivativeSchema.this.AuctionOffer(x$46, x$41, x$42, x$43, x$44, x$45)
}).insert(DerivativeSchema.this.auctionOffers).flatMap[Unit](((_: DerivativeSchema.this.AuctionOffer) => new DerivativeSchema.this.Auctioned(this, deriv, price).report().map[Unit](((_: DerivativeSchema.this.NewsEvent) => ())))));
    def userAcceptOffer(id: String): DerivativeSchema.this.NewsEvent = DerivativeSchema.this.editDB[DerivativeSchema.this.NewsEvent]({
      val offer: DerivativeSchema.this.DerivativeOffer = DerivativeSchema.this.derivativeOffers.lookup(id).getOrElse[DerivativeSchema.this.DerivativeOffer](throw DerivativeSchema.this.NoSuchOffer);
      PortfolioWithDerivatives.this.enterContractWithVotes(model.this.Link.extract[DerivativeSchema.this.Portfolio](offer.from)(DerivativeSchema.this.portfolios), offer.derivative, offer.price).filter(((check$ifrefutable$1: (DerivativeSchema.this.DerivativeBuyerSetAside, DerivativeSchema.this.DerivativeSellerSetAside)) => (check$ifrefutable$1: (DerivativeSchema.this.DerivativeBuyerSetAside, DerivativeSchema.this.DerivativeSellerSetAside) @unchecked) match {
  case (_1: DerivativeSchema.this.DerivativeBuyerSetAside, _2: DerivativeSchema.this.DerivativeSellerSetAside)(DerivativeSchema.this.DerivativeBuyerSetAside, DerivativeSchema.this.DerivativeSellerSetAside)((buyerAside @ _), (sellerAside @ _)) => true
  case _ => false
})).flatMap[DerivativeSchema.this.NewsEvent](((x$5: (DerivativeSchema.this.DerivativeBuyerSetAside, DerivativeSchema.this.DerivativeSellerSetAside)) => (x$5: (DerivativeSchema.this.DerivativeBuyerSetAside, DerivativeSchema.this.DerivativeSellerSetAside) @unchecked) match {
        case (_1: DerivativeSchema.this.DerivativeBuyerSetAside, _2: DerivativeSchema.this.DerivativeSellerSetAside)(DerivativeSchema.this.DerivativeBuyerSetAside, DerivativeSchema.this.DerivativeSellerSetAside)((buyerAside @ _), (sellerAside @ _)) => DerivativeSchema.this.toOps[DerivativeSchema.this.DerivativeOffer](offer).delete(DerivativeSchema.this.derivativeOffers).flatMap[DerivativeSchema.this.NewsEvent](((_: DerivativeSchema.this.DerivativeOffer) => new DerivativeSchema.this.Accepted(model.this.Link.extract[DerivativeSchema.this.Portfolio](offer.from)(DerivativeSchema.this.portfolios), model.this.Link.extract[DerivativeSchema.this.Portfolio](offer.to)(DerivativeSchema.this.portfolios), offer.derivative, offer.price, model.this.KL.toLink[DerivativeSchema.this.DerivativeBuyerSetAside](buyerAside), model.this.KL.toLink[DerivativeSchema.this.DerivativeSellerSetAside](sellerAside)).report().map[DerivativeSchema.this.NewsEvent](((event: DerivativeSchema.this.NewsEvent) => event))))
      }))
    });
    def userDeclineOffer(id: String): Unit = DerivativeSchema.this.editDB[Unit]({
      val offer: DerivativeSchema.this.DerivativeOffer = DerivativeSchema.this.derivativeOffers.lookup(id).getOrElse[DerivativeSchema.this.DerivativeOffer](throw DerivativeSchema.this.NoSuchOffer);
      DerivativeSchema.this.toOps[DerivativeSchema.this.DerivativeOffer](offer).delete(DerivativeSchema.this.derivativeOffers).flatMap[Unit](((_: DerivativeSchema.this.DerivativeOffer) => new DerivativeSchema.this.Declined(model.this.Link.extract[DerivativeSchema.this.Portfolio](offer.from)(DerivativeSchema.this.portfolios), model.this.Link.extract[DerivativeSchema.this.Portfolio](offer.to)(DerivativeSchema.this.portfolios), offer.derivative, offer.price).report().map[Unit](((_: DerivativeSchema.this.NewsEvent) => ()))))
    });
    private[model] def enterContract(seller: DerivativeSchema.this.Portfolio, deriv: model.Derivative, price: model.Dollars, hidden: Boolean = false): DerivativeSchema.this.Transaction[Unit] = DerivativeSchema.this.toOps[DerivativeSchema.this.DerivativeLiability]({
  val x$11: model.package.Key = model.this.`package`.nextID;
  val x$12: model.Derivative = deriv;
  val x$13: model.Scale = Scale.apply("1.0");
  val x$14: org.joda.time.DateTime = deriv.exec;
  val x$15: model.Link[DerivativeSchema.this.Portfolio] = model.this.KL.toLink[DerivativeSchema.this.Portfolio](seller);
  val x$16: Boolean = hidden;
  val x$17: model.package.Key = DerivativeSchema.this.DerivativeLiability.apply$default$1;
  new DerivativeSchema.this.DerivativeLiability(x$17, x$11, x$12, x$13, x$14, x$15, x$16)
}).insert(DerivativeSchema.this.derivativeLiabilities).flatMap[Unit](((liab: DerivativeSchema.this.DerivativeLiability) => DerivativeSchema.this.toOps[DerivativeSchema.this.DerivativeAsset]({
  val x$18: model.Link[DerivativeSchema.this.DerivativeLiability] = model.this.KL.toLink[DerivativeSchema.this.DerivativeLiability](liab);
  val x$19: model.Scale = Scale.apply("1.0");
  val x$20: model.Link[DerivativeSchema.this.Portfolio] = model.this.KL.toLink[DerivativeSchema.this.Portfolio](this);
  val x$21: Boolean = hidden;
  val x$22: model.package.Key = DerivativeSchema.this.DerivativeAsset.apply$default$1;
  new DerivativeSchema.this.DerivativeAsset(x$22, x$18, x$19, x$20, x$21)
}).insert(DerivativeSchema.this.derivativeAssets).flatMap[Unit](((asset: DerivativeSchema.this.DerivativeAsset) => DerivativeSchema.this.toOps[DerivativeSchema.this.Portfolio](this).update(((t: DerivativeSchema.this.Portfolio) => {
  val x$23: model.Dollars = t.cash.-(price);
  val x$24: model.package.Key = t.copy$default$1;
  val x$25: model.Link[DerivativeSchema.this.League] = t.copy$default$2;
  val x$26: String = t.copy$default$3;
  val x$27: model.Dollars = t.copy$default$5;
  val x$28: Int = t.copy$default$6;
  t.copy(x$24, x$25, x$26, x$23, x$27, x$28)
}))(DerivativeSchema.this.portfolios).flatMap[Unit](((_: Unit) => DerivativeSchema.this.toOps[DerivativeSchema.this.Portfolio](seller).update(((t: DerivativeSchema.this.Portfolio) => {
  val x$29: model.Dollars = t.cash.+(price);
  val x$30: model.package.Key = t.copy$default$1;
  val x$31: model.Link[DerivativeSchema.this.League] = t.copy$default$2;
  val x$32: String = t.copy$default$3;
  val x$33: model.Dollars = t.copy$default$5;
  val x$34: Int = t.copy$default$6;
  t.copy(x$30, x$31, x$32, x$29, x$33, x$34)
}))(DerivativeSchema.this.portfolios).map[Unit](((_: Unit) => if (PortfolioWithDerivatives.this.cash.<(price))
      throw new DerivativeSchema.this.NotEnoughCash(PortfolioWithDerivatives.this.cash, price)
    else
      ()))))))));
    <synthetic> def enterContract$default$4: Boolean @scala.annotation.unchecked.uncheckedVariance = false;
    private[model] def enterContractWithVotes(seller: DerivativeSchema.this.Portfolio, deriv: model.Derivative, price: model.Dollars): DerivativeSchema.this.Transaction[(DerivativeSchema.this.DerivativeBuyerSetAside, DerivativeSchema.this.DerivativeSellerSetAside)] = PortfolioWithDerivatives.this.enterContract(seller, deriv, price, PortfolioWithDerivatives.this.enterContract$default$4).flatMap[(DerivativeSchema.this.DerivativeBuyerSetAside, DerivativeSchema.this.DerivativeSellerSetAside)](((_: Unit) => PortfolioWithDerivatives.this.setupSetAside(this, seller, deriv, price).filter(((check$ifrefutable$2: (DerivativeSchema.this.DerivativeBuyerSetAside, DerivativeSchema.this.DerivativeSellerSetAside)) => (check$ifrefutable$2: (DerivativeSchema.this.DerivativeBuyerSetAside, DerivativeSchema.this.DerivativeSellerSetAside) @unchecked) match {
  case (_1: DerivativeSchema.this.DerivativeBuyerSetAside, _2: DerivativeSchema.this.DerivativeSellerSetAside)(DerivativeSchema.this.DerivativeBuyerSetAside, DerivativeSchema.this.DerivativeSellerSetAside)((buyerAside @ _), (sellerAside @ _)) => true
  case _ => false
})).map[(DerivativeSchema.this.DerivativeBuyerSetAside, DerivativeSchema.this.DerivativeSellerSetAside)](((x$6: (DerivativeSchema.this.DerivativeBuyerSetAside, DerivativeSchema.this.DerivativeSellerSetAside)) => (x$6: (DerivativeSchema.this.DerivativeBuyerSetAside, DerivativeSchema.this.DerivativeSellerSetAside) @unchecked) match {
      case (_1: DerivativeSchema.this.DerivativeBuyerSetAside, _2: DerivativeSchema.this.DerivativeSellerSetAside)(DerivativeSchema.this.DerivativeBuyerSetAside, DerivativeSchema.this.DerivativeSellerSetAside)((buyerAside @ _), (sellerAside @ _)) => new (DerivativeSchema.this.DerivativeBuyerSetAside, DerivativeSchema.this.DerivativeSellerSetAside)(buyerAside, sellerAside)
    }))))
  }
}
DerivativeSchema: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=1.000
         Derivat systemC
 Derivat                
 Derivat                
 Derivat                

class PortfolioPage extends java.lang.Object with intform.Page with net.liftweb.common.Loggable with ScalaObject {
  def this(): code.snippet.PortfolioPage = {
    PortfolioPage.super.this();
    ()
  };
  private[this] val nameParam: net.liftweb.common.Box[String] = net.liftweb.http.S.param("name");
  <stable> <accessor> def nameParam: net.liftweb.common.Box[String] = PortfolioPage.this.nameParam;
  def render: scala.xml.NodeSeq = try {
    model.schema.readDB[scala.xml.NodeSeq]({
      val name: String = PortfolioPage.this.nameParam.openOr[String](throw model.schema.NoSuchUser);
      val port: model.schema.Portfolio = model.schema.Portfolio.byName(name);
      val curUser: Option[model.schema.User] = try {
        new Some[model.schema.User](control.LoginManager.currentUser)
      } catch {
        case control.LoginManager.NotLoggedIn => scala.None
      };
      curUser match {
        case (x: model.schema.User)Some[model.schema.User]((user @ _)) if port.isOwnedBy(user) => xml.this.NodeSeq.seqToNodeSeq(myPage.apply())
        case _ => theirPortfolio.apply(port)
      }
    })
  } catch {
    case (e @ (_: errors.package.BadUser)) => {
      {
        new scala.xml.Elem(null, "p", scala.xml.Null, scala.this.Predef.$scope, ({
          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
          $buf.&+(new scala.xml.Text("Sorry, "));
          $buf.&+(formats.`package`.standardMessage(e));
          $buf
        }: _*))
      }
    }
  }
}
PortfolioPage: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
          render

final case object NotExecutable extends java.lang.RuntimeException with errors.package.BadUser with ScalaObject with Product with Serializable {
  def this(): object SchemaErrors.this.NotExecutable = {
    NotExecutable.super.this();
    ()
  };
  final override def hashCode(): Int = 277483357;
  override def productPrefix: java.lang.String = "NotExecutable";
  override def productArity: Int = 0;
  override def productElement(x$1: Int): Any = x$1 match {
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[object SchemaErrors.this.NotExecutable]()
}
NotExecutable: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

final object operations extends java.lang.Object with ScalaObject {
  def this(): object model.operations = {
    operations.super.this();
    ()
  };
  def userBuyStock(username: String, ticker: String, dollars: model.Dollars): Unit = schema.editDB[Unit](schema.User.ensure(username).flatMap[Unit](((user: model.schema.User) => model.this.Link.extract[model.schema.Portfolio](user.lastPortfolio)(model.this.schema.portfolios).buyStock(ticker, dollars).map[Unit](((_: model.schema.StockPurchase) => ())))));
  def userSellStock(username: String, ticker: String): Unit = schema.editDB[Unit](schema.User.ensure(username).flatMap[Unit](((user: model.schema.User) => model.this.Link.extract[model.schema.Portfolio](user.lastPortfolio)(model.this.schema.portfolios).sellAll(ticker).map[Unit](((_: Unit) => ())))));
  def getUserPortfolio(username: String): model.schema.Portfolio = schema.editDB[model.schema.Portfolio](schema.User.ensureP(username))
}
operations: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.667
         getUser userBuy userSel

final object TwitterLogin extends java.lang.Object with net.liftweb.common.Loggable with ScalaObject {
  def this(): object code.control.TwitterLogin = {
    TwitterLogin.super.this();
    ()
  };
  def dispatchPF: net.liftweb.http.LiftRules.DispatchPF = net.liftweb.util.NamedPF.apply[net.liftweb.http.Req, () => net.liftweb.common.Box[net.liftweb.http.LiftResponse]]("Twitter login callback")(((x0$1: net.liftweb.http.Req) => x0$1 match {
    case (req @ net.liftweb.http.Req.unapply(<unapply-selector>) <unapply> ((hd: String, tl: List[String])collection.immutable.::[String]("twitter", (hd: String, tl: List[String])collection.immutable.::[String]("login", immutable.this.Nil)), "", _)) => {
      (() => TwitterLogin.this.twitterLogin(req)())
    }
    case (req @ net.liftweb.http.Req.unapply(<unapply-selector>) <unapply> ((hd: String, tl: List[String])collection.immutable.::[String]("twitter", (hd: String, tl: List[String])collection.immutable.::[String]("callback", immutable.this.Nil)), "", _)) => {
      (() => TwitterLogin.this.twitterCallback(req)())
    }
  }));
  def authenticated_?: Boolean = (util.this.AnyVar.whatVarIs[Option[org.scribe.model.Token]](TwitterLogin.this.accessToken): Option[org.scribe.model.Token]) match {
    case (x: org.scribe.model.Token)Some[org.scribe.model.Token](_) => true
    case _ => false
  };
  def asAuth: Option[code.control.TwitterLogin.Auth] = util.this.AnyVar.whatVarIs[Option[org.scribe.model.Token]](TwitterLogin.this.accessToken).map[code.control.TwitterLogin.Auth](((accessToken: org.scribe.model.Token) => new code.control.TwitterLogin.Auth(accessToken)));
  case class Auth extends java.lang.Object with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val accessToken: org.scribe.model.Token = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def accessToken: org.scribe.model.Token = Auth.this.accessToken;
    def this(accessToken: org.scribe.model.Token): code.control.TwitterLogin.Auth = {
      Auth.super.this();
      ()
    };
    def sign: (String, String) = new (java.lang.String, java.lang.String)(Auth.this.accessToken.getToken(), Auth.this.accessToken.getSecret());
    <synthetic> def copy(accessToken: org.scribe.model.Token = accessToken): code.control.TwitterLogin.Auth = new TwitterLogin.this.Auth(accessToken);
    <synthetic> def copy$default$1: org.scribe.model.Token @scala.annotation.unchecked.uncheckedVariance = Auth.this.accessToken;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(Auth.this);
    override def toString(): String = ScalaRunTime.this._toString(Auth.this);
    override def equals(x$1: Any): Boolean = Auth.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (accessToken: org.scribe.model.Token)code.control.TwitterLogin.Auth((accessToken$1 @ _)) if accessToken$1.==(accessToken) => x$1.asInstanceOf[code.control.TwitterLogin.Auth].canEqual(Auth.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "Auth";
    override def productArity: Int = 1;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => accessToken
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[code.control.TwitterLogin.Auth]()
  };
  final <synthetic> object Auth extends scala.runtime.AbstractFunction1[org.scribe.model.Token,code.control.TwitterLogin.Auth] with ScalaObject with Serializable {
    def this(): object code.control.TwitterLogin.Auth = {
      Auth.super.this();
      ()
    };
    final override def toString(): java.lang.String = "Auth";
    case <synthetic> def unapply(x$0: code.control.TwitterLogin.Auth): Option[org.scribe.model.Token] = if (x$0.==(null))
      scala.this.None
    else
      new Some[org.scribe.model.Token](x$0.accessToken);
    case <synthetic> def apply(accessToken: org.scribe.model.Token): code.control.TwitterLogin.Auth = new TwitterLogin.this.Auth(accessToken);
    protected def readResolve(): java.lang.Object = TwitterLogin.this.Auth
  };
  protected def twitterLogin(req: net.liftweb.http.Req)(): net.liftweb.common.Box[net.liftweb.http.LiftResponse] = {
    val oauth: org.scribe.oauth.OAuthService = TwitterLogin.this.makeOauthService(req.request.url);
    sessions.`package`.toColon[Option[org.scribe.oauth.OAuthService]](TwitterLogin.this.serviceInProgress).:=(new Some[org.scribe.oauth.OAuthService](oauth));
    val token: org.scribe.model.Token = oauth.getRequestToken();
    sessions.`package`.toColon[Option[org.scribe.model.Token]](TwitterLogin.this.requestToken).:=(new Some[org.scribe.model.Token](token));
    sessions.`package`.toColon[String](TwitterLogin.this.returnTo).:=(net.liftweb.http.S.referer.openOr[String]("/"));
    val callbackURL: java.lang.String = "http://".+(net.liftweb.http.S.hostName).+("/twitter/callback");
    val redirectURL: String = oauth.getAuthorizationUrl(token);
    TwitterLogin.this.logger.info(scala.this.Predef.augmentString("Redirecting to ").++[Char, AnyRef](scala.this.Predef.augmentString(redirectURL))(scala.this.Predef.stringCanBuildFrom));
    new net.liftweb.common.Full[net.liftweb.http.RedirectResponse](net.liftweb.http.RedirectResponse.apply(redirectURL))
  };
  protected def twitterCallback(req: net.liftweb.http.Req)(): net.liftweb.common.Box[net.liftweb.http.LiftResponse] = req.params.get("oauth_verifier") match {
    case (x: List[String])Some[List[String]]((hd: String, tl: List[String])collection.immutable.::[String]((v @ _), immutable.this.Nil)) => TwitterLogin.this.doVerifier(v)
    case _ => new net.liftweb.common.Full[net.liftweb.http.RedirectResponse](net.liftweb.http.RedirectResponse.apply(util.this.AnyVar.whatVarIs[String](TwitterLogin.this.returnTo)))
  };
  protected def doVerifier(verifierText: String): net.liftweb.common.Box[net.liftweb.http.LiftResponse] = {
    val verifier: org.scribe.model.Verifier = new org.scribe.model.Verifier(verifierText);
    TwitterLogin.this.logger.info(scala.this.Predef.augmentString("Got verifier ").++[Char, AnyRef](scala.this.Predef.augmentString(verifier.toString()))(scala.this.Predef.stringCanBuildFrom));
    val oauth: org.scribe.oauth.OAuthService = TwitterLogin.this.serviceInProgress.is.getOrElse[org.scribe.oauth.OAuthService](throw new java.this.lang.IllegalStateException("Lost the service ;("));
    val accessToken_: org.scribe.model.Token = (util.this.AnyVar.whatVarIs[Option[org.scribe.model.Token]](TwitterLogin.this.requestToken): Option[org.scribe.model.Token]) match {
      case (x: org.scribe.model.Token)Some[org.scribe.model.Token]((token @ _)) => oauth.getAccessToken(token, verifier)
      case _ => throw new java.this.lang.IllegalStateException("Lost the request token ;(")
    };
    sessions.`package`.toColon[Option[org.scribe.model.Token]](TwitterLogin.this.accessToken).:=(new Some[org.scribe.model.Token](accessToken_));
    TwitterLogin.this.logger.info(scala.this.Predef.augmentString("Got access token ").++[Char, AnyRef](scala.this.Predef.augmentString(TwitterLogin.this.accessToken.toString()))(scala.this.Predef.stringCanBuildFrom));
    val req: org.scribe.model.OAuthRequest = new org.scribe.model.OAuthRequest(value GET, "http://api.twitter.com/1/account/verify_credentials.json");
    oauth.signRequest(accessToken_, req);
    val res: org.scribe.model.Response = req.send();
    val username: String = net.liftweb.json.`package`.parse(res.getBody()).filter(((check$ifrefutable$1: net.liftweb.json.JsonAST.JValue) => (check$ifrefutable$1: net.liftweb.json.JsonAST.JValue @unchecked) match {
  case (obj: List[net.liftweb.json.JsonAST.JField])net.liftweb.json.JsonAST.JObject((node @ _)) => true
  case _ => false
})).flatMap[String, List[String]](((x$2: net.liftweb.json.JsonAST.JValue) => (x$2: net.liftweb.json.JsonAST.JValue @unchecked) match {
      case (obj: List[net.liftweb.json.JsonAST.JField])net.liftweb.json.JsonAST.JObject((node @ _)) => node.filter(((check$ifrefutable$2: net.liftweb.json.JsonAST.JField) => (check$ifrefutable$2: net.liftweb.json.JsonAST.JField @unchecked) match {
  case (name: String, value: net.liftweb.json.JsonAST.JValue)net.liftweb.json.JsonAST.JField("screen_name", (s: String)net.liftweb.json.JsonAST.JString((username @ _))) => true
  case _ => false
})).map[String, List[String]](((x$1: net.liftweb.json.JsonAST.JField) => (x$1: net.liftweb.json.JsonAST.JField @unchecked) match {
        case (name: String, value: net.liftweb.json.JsonAST.JValue)net.liftweb.json.JsonAST.JField("screen_name", (s: String)net.liftweb.json.JsonAST.JString((username @ _))) => username
      }))(immutable.this.List.canBuildFrom[String])
    }))(immutable.this.List.canBuildFrom[String]) match {
      case (hd: String, tl: List[String])collection.immutable.::[String]((name @ _), _) => name
      case immutable.this.Nil => throw new java.this.lang.IllegalStateException("Couldn\'t find screen_name from Twitter")
    };
    TwitterLogin.this.logger.info(scala.this.Predef.augmentString("Verified user as ").++[Char, AnyRef](scala.this.Predef.augmentString(username))(scala.this.Predef.stringCanBuildFrom));
    LoginManager.loginAsTwitter(username);
    new net.liftweb.common.Full[net.liftweb.http.RedirectResponse](net.liftweb.http.RedirectResponse.apply(util.this.AnyVar.whatVarIs[String](TwitterLogin.this.returnTo)))
  };
  final protected object returnTo extends net.liftweb.http.SessionVar[String] with ScalaObject {
    def this(): object code.control.TwitterLogin.returnTo = {
      returnTo.super.this("/");
      ()
    }
  };
  final protected object requestToken extends net.liftweb.http.SessionVar[Option[org.scribe.model.Token]] with ScalaObject {
    def this(): object code.control.TwitterLogin.requestToken = {
      requestToken.super.this(scala.None);
      ()
    }
  };
  final protected object accessToken extends net.liftweb.http.SessionVar[Option[org.scribe.model.Token]] with ScalaObject {
    def this(): object code.control.TwitterLogin.accessToken = {
      accessToken.super.this(scala.None);
      ()
    }
  };
  final protected object serviceInProgress extends net.liftweb.http.SessionVar[Option[org.scribe.oauth.OAuthService]] with ScalaObject {
    def this(): object code.control.TwitterLogin.serviceInProgress = {
      serviceInProgress.super.this(scala.None);
      ()
    }
  };
  protected def makeOauthService(urlText: String): org.scribe.oauth.OAuthService = {
    val url: java.net.URL = new java.net.URL(urlText);
    val host: java.lang.String = url.getHost();
    val port: Int = url.getPort();
    new org.scribe.builder.ServiceBuilder().provider(classOf[org.scribe.builder.api.TwitterApi]).apiKey(keys.TwitterKeys.consumerKey).apiSecret(keys.TwitterKeys.consumerSecret).callback("http://".+(host).+(":").+(port).+("/twitter/callback")).build()
  }
}
TwitterLogin: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.286
         authent doVerif twitter dispatc makeOau twitter  asAuth

final object Portfolio extends java.lang.Object with ScalaObject with Serializable {
  def this(): object UserSchema.this.Portfolio = {
    Portfolio.super.this();
    ()
  };
  def byID(id: model.package.Key): UserSchema.this.Portfolio = UserSchema.this.portfolios.lookup(id).getOrElse[UserSchema.this.Portfolio](throw UserSchema.this.NoSuchPortfolio);
  def byName(name: String): UserSchema.this.Portfolio = UserSchema.this.portfolios.filter(((x$12: UserSchema.this.Portfolio) => x$12.name.==(name))).headOption.getOrElse[UserSchema.this.Portfolio](throw UserSchema.this.NoSuchPortfolio);
  def byLeague(league: UserSchema.this.League): scala.collection.mutable.ArrayBuffer[UserSchema.this.Portfolio] = UserSchema.this.portfolios.filter(((x$13: UserSchema.this.Portfolio) => x$13.league.id.==(league.id)));
  <synthetic> def apply$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
  <synthetic> def init$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
  case <synthetic> def unapply(x$0: UserSchema.this.Portfolio): Option[(model.package.Key, model.Link[UserSchema.this.League], String, model.Dollars, model.Dollars, Int)] = if (x$0.==(null))
    scala.this.None
  else
    new Some[(model.package.Key, model.Link[UserSchema.this.League], String, model.Dollars, model.Dollars, Int)](new (model.package.Key, model.Link[UserSchema.this.League], String, model.Dollars, model.Dollars, Int)(x$0.id, x$0.league, x$0.name, x$0.cash, x$0.loan, x$0.rank));
  case <synthetic> def apply(id: model.package.Key = model.this.`package`.nextID, league: model.Link[UserSchema.this.League], name: String, cash: model.Dollars, loan: model.Dollars, rank: Int): UserSchema.this.Portfolio = new UserSchema.this.Portfolio(id, league, name, cash, loan, rank)
}
Portfolio: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.333
            byID byLeagu  byName

case class StockInDerivative extends java.lang.Object with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val quote: stockdata.Quote = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def quote: stockdata.Quote = StockInDerivative.this.quote;
  <caseaccessor> <paramaccessor> private[this] val shares: Int = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def shares: Int = StockInDerivative.this.shares;
  <caseaccessor> <paramaccessor> private[this] val direction: code.snippet.Direction = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def direction: code.snippet.Direction = StockInDerivative.this.direction;
  def this(quote: stockdata.Quote, shares: Int, direction: code.snippet.Direction): code.snippet.StockInDerivative = {
    StockInDerivative.super.this();
    ()
  };
  <synthetic> def copy(quote: stockdata.Quote = quote, shares: Int = shares, direction: code.snippet.Direction = direction): code.snippet.StockInDerivative = new snippet.this.StockInDerivative(quote, shares, direction);
  <synthetic> def copy$default$3: code.snippet.Direction @scala.annotation.unchecked.uncheckedVariance = StockInDerivative.this.direction;
  <synthetic> def copy$default$2: Int @scala.annotation.unchecked.uncheckedVariance = StockInDerivative.this.shares;
  <synthetic> def copy$default$1: stockdata.Quote @scala.annotation.unchecked.uncheckedVariance = StockInDerivative.this.quote;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(StockInDerivative.this);
  override def toString(): String = ScalaRunTime.this._toString(StockInDerivative.this);
  override def equals(x$1: Any): Boolean = StockInDerivative.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (quote: stockdata.Quote, shares: Int, direction: code.snippet.Direction)code.snippet.StockInDerivative((quote$1 @ _), (shares$1 @ _), (direction$1 @ _)) if quote$1.==(quote).&&(shares$1.==(shares)).&&(direction$1.==(direction)) => x$1.asInstanceOf[code.snippet.StockInDerivative].canEqual(StockInDerivative.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "StockInDerivative";
  override def productArity: Int = 3;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => quote
    case 1 => shares
    case 2 => direction
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[code.snippet.StockInDerivative]()
}
StockInDerivative: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
   quote
 directi
  shares

case class DontOwnStock extends java.lang.RuntimeException with errors.package.BadUser with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val ticker: String = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def ticker: String = DontOwnStock.this.ticker;
  def this(ticker: String): SchemaErrors.this.DontOwnStock = {
    DontOwnStock.super.this();
    ()
  };
  <synthetic> def copy(ticker: String = ticker): SchemaErrors.this.DontOwnStock = new SchemaErrors.this.DontOwnStock(ticker);
  <synthetic> def copy$default$1: String @scala.annotation.unchecked.uncheckedVariance = DontOwnStock.this.ticker;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(DontOwnStock.this);
  override def equals(x$1: Any): Boolean = DontOwnStock.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (ticker: String)SchemaErrors.this.DontOwnStock((ticker$1 @ _)) if ticker$1.==(ticker) => x$1.asInstanceOf[SchemaErrors.this.DontOwnStock].canEqual(DontOwnStock.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "DontOwnStock";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => ticker
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[SchemaErrors.this.DontOwnStock]()
}
DontOwnStock: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
  ticker

case class NoSuchStockException extends scala.`package`.Exception with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val stock: stockdata.Stock = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def stock: stockdata.Stock = NoSuchStockException.this.stock;
  def this(stock: stockdata.Stock): stockdata.NoSuchStockException = {
    NoSuchStockException.super.this(scala.this.Predef.augmentString("There is no stock with ticker symbol \'%s\'.").format(stock.symbol));
    ()
  };
  <synthetic> def copy(stock: stockdata.Stock = stock): stockdata.NoSuchStockException = new stockdata.this.NoSuchStockException(stock);
  <synthetic> def copy$default$1: stockdata.Stock @scala.annotation.unchecked.uncheckedVariance = NoSuchStockException.this.stock;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(NoSuchStockException.this);
  override def equals(x$1: Any): Boolean = NoSuchStockException.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (stock: stockdata.Stock)stockdata.NoSuchStockException((stock$1 @ _)) if stock$1.==(stock) => x$1.asInstanceOf[stockdata.NoSuchStockException].canEqual(NoSuchStockException.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "NoSuchStockException";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => stock
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[stockdata.NoSuchStockException]()
}
NoSuchStockException: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
   stock

final object twit extends java.lang.Object with ScalaObject {
  def this(): object texttrading.twit = {
    twit.super.this();
    ()
  };
  private[this] val twit: texttrading.TwitterFrontend = new TwitterFrontend(code.keys.RWTwitter, new PitFailBackend());
  <stable> <accessor> def twit: texttrading.TwitterFrontend = twit.this.twit;
  def run(): Unit = twit.this.twit.run()
}
twit: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
             run

final object schema extends java.lang.Object with model.DummySchema with model.DBMagic with model.SchemaErrors with model.UserSchema with model.StockSchema with model.DerivativeSchema with model.AuctionSchema with model.NewsSchema with model.CommentSchema with model.VotingSchema with model.RankingSchema with model.AutoTradeSchema with model.DividendSchema with ScalaObject {
  def this(): object model.schema = {
    schema.super.this();
    ()
  }
}
schema: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

sealed abstract class Status extends java.lang.Object with ScalaObject {
  def this(): texttrading.Status = {
    Status.super.this();
    ()
  }
}
Status: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

case class StockAsset extends java.lang.Object with model.KL with StockSchema.this.StockAssetOps with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val id: model.package.Key = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def id: model.package.Key = StockAsset.this.id;
  <caseaccessor> <paramaccessor> private[this] val ticker: String = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def ticker: String = StockAsset.this.ticker;
  <caseaccessor> <paramaccessor> private[this] val shares: model.Shares = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def shares: model.Shares = StockAsset.this.shares;
  <caseaccessor> <paramaccessor> private[this] val owner: model.Link[StockSchema.this.Portfolio] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def owner: model.Link[StockSchema.this.Portfolio] = StockAsset.this.owner;
  <caseaccessor> <paramaccessor> private[this] val purchasePrice: model.Price = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def purchasePrice: model.Price = StockAsset.this.purchasePrice;
  <caseaccessor> <paramaccessor> private[this] val notifiedPrice: model.Price = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def notifiedPrice: model.Price = StockAsset.this.notifiedPrice;
  <caseaccessor> <paramaccessor> private[this] val purchaseDate: org.joda.time.DateTime = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def purchaseDate: org.joda.time.DateTime = StockAsset.this.purchaseDate;
  <caseaccessor> <paramaccessor> private[this] val lastDividendDate: org.joda.time.DateTime = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def lastDividendDate: org.joda.time.DateTime = StockAsset.this.lastDividendDate;
  <caseaccessor> <paramaccessor> private[this] val totalDividends: model.Dollars = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def totalDividends: model.Dollars = StockAsset.this.totalDividends;
  def this(id: model.package.Key = model.this.`package`.nextID, ticker: String, shares: model.Shares, owner: model.Link[StockSchema.this.Portfolio], purchasePrice: model.Price, notifiedPrice: model.Price, purchaseDate: org.joda.time.DateTime, lastDividendDate: org.joda.time.DateTime, totalDividends: model.Dollars): StockSchema.this.StockAsset = {
    StockAsset.super.this();
    ()
  };
  <synthetic> def copy$default$9: model.Dollars @scala.annotation.unchecked.uncheckedVariance = StockAsset.this.totalDividends;
  <synthetic> def copy$default$8: org.joda.time.DateTime @scala.annotation.unchecked.uncheckedVariance = StockAsset.this.lastDividendDate;
  <synthetic> def copy$default$7: org.joda.time.DateTime @scala.annotation.unchecked.uncheckedVariance = StockAsset.this.purchaseDate;
  <synthetic> def copy$default$6: model.Price @scala.annotation.unchecked.uncheckedVariance = StockAsset.this.notifiedPrice;
  <synthetic> def copy$default$5: model.Price @scala.annotation.unchecked.uncheckedVariance = StockAsset.this.purchasePrice;
  <synthetic> def copy$default$4: model.Link[StockSchema.this.Portfolio] @scala.annotation.unchecked.uncheckedVariance = StockAsset.this.owner;
  <synthetic> def copy$default$3: model.Shares @scala.annotation.unchecked.uncheckedVariance = StockAsset.this.shares;
  <synthetic> def copy$default$2: String @scala.annotation.unchecked.uncheckedVariance = StockAsset.this.ticker;
  <synthetic> def copy$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = StockAsset.this.id;
  <synthetic> def copy(id: model.package.Key = id, ticker: String = ticker, shares: model.Shares = shares, owner: model.Link[StockSchema.this.Portfolio] = owner, purchasePrice: model.Price = purchasePrice, notifiedPrice: model.Price = notifiedPrice, purchaseDate: org.joda.time.DateTime = purchaseDate, lastDividendDate: org.joda.time.DateTime = lastDividendDate, totalDividends: model.Dollars = totalDividends): StockSchema.this.StockAsset = new StockSchema.this.StockAsset(id, ticker, shares, owner, purchasePrice, notifiedPrice, purchaseDate, lastDividendDate, totalDividends);
  override def hashCode(): Int = ScalaRunTime.this._hashCode(StockAsset.this);
  override def toString(): String = ScalaRunTime.this._toString(StockAsset.this);
  override def equals(x$1: Any): Boolean = StockAsset.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (id: model.package.Key, ticker: String, shares: model.Shares, owner: model.Link[StockSchema.this.Portfolio], purchasePrice: model.Price, notifiedPrice: model.Price, purchaseDate: org.joda.time.DateTime, lastDividendDate: org.joda.time.DateTime, totalDividends: model.Dollars)StockSchema.this.StockAsset((id$1 @ _), (ticker$1 @ _), (shares$1 @ _), (owner$1 @ _), (purchasePrice$1 @ _), (notifiedPrice$1 @ _), (purchaseDate$1 @ _), (lastDividendDate$1 @ _), (totalDividends$1 @ _)) if id$1.==(id).&&(ticker$1.==(ticker)).&&(shares$1.==(shares)).&&(owner$1.==(owner)).&&(purchasePrice$1.==(purchasePrice)).&&(notifiedPrice$1.==(notifiedPrice)).&&(purchaseDate$1.==(purchaseDate)).&&(lastDividendDate$1.==(lastDividendDate)).&&(totalDividends$1.==(totalDividends)) => x$1.asInstanceOf[StockSchema.this.StockAsset].canEqual(StockAsset.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "StockAsset";
  override def productArity: Int = 9;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => id
    case 1 => ticker
    case 2 => shares
    case 3 => owner
    case 4 => purchasePrice
    case 5 => notifiedPrice
    case 6 => purchaseDate
    case 7 => lastDividendDate
    case 8 => totalDividends
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[StockSchema.this.StockAsset]()
}
StockAsset: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
 totalDi
      id
 lastDiv
 purchas
   owner
  ticker
 purchas
  shares
 notifie

class PortfolioField extends intform.TextField[model.schema.Portfolio] with ScalaObject {
  <paramaccessor> private[this] val initText: String = _;
  def this(initText: String): code.snippet.PortfolioField = {
    PortfolioField.super.this(initText);
    ()
  };
  def produce(): intform.SubmitResult[model.schema.Portfolio] = try {
    model.schema.readDB[intform.OK[model.schema.Portfolio]](new intform.OK[model.schema.Portfolio](model.schema.Portfolio.byName(PortfolioField.this.text)))
  } catch {
    case model.schema.NoSuchPortfolio => new intform.Error("No portfolio named ".+(PortfolioField.this.text))
  }
}
PortfolioField: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
         produce
 initTex        

final object stockChart extends java.lang.Object with net.liftweb.common.Loggable with ScalaObject {
  def this(): object code.snippet.stockChart = {
    stockChart.super.this();
    ()
  };
  def apply(port: model.schema.Portfolio, modifiable: Boolean): scala.xml.NodeSeq = {
    lazy var main$lzy: scala.xml.Elem = _;
    <stable> <accessor> lazy def main: scala.xml.Elem = {
      main$lzy = {
        {
          var $md: scala.xml.MetaData = scala.xml.Null;
          $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("block"), $md);
          new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
            $buf.&+(new scala.xml.Text("\012        "));
            $buf.&+({
              {
                new scala.xml.Elem(null, "h2", scala.xml.Null, scala.this.Predef.$scope, ({
                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                  $buf.&+(new scala.xml.Text("Stocks"));
                  $buf
                }: _*))
              }
            });
            $buf.&+(new scala.xml.Text("\012        "));
            $buf.&+(stockTable);
            $buf.&+(new scala.xml.Text("\012    "));
            $buf
          }: _*))
        }
      };
      main$lzy
    };
    lazy var stockTable$lzy: scala.xml.Elem = _;
    <stable> <accessor> lazy def stockTable: scala.xml.Elem = {
      stockTable$lzy = {
        {
          new scala.xml.Elem(null, "table", scala.xml.Null, scala.this.Predef.$scope, ({
            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
            $buf.&+(new scala.xml.Text("\012        "));
            $buf.&+({
              {
                new scala.xml.Elem(null, "tr", scala.xml.Null, scala.this.Predef.$scope, ({
                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                  $buf.&+(new scala.xml.Text("\012            "));
                  $buf.&+({
                    {
                      var $md: scala.xml.MetaData = scala.xml.Null;
                      $md = new scala.xml.UnprefixedAttribute("colspan", new scala.xml.Text("2"), $md);
                      new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope)
                    }
                  });
                  $buf.&+(new scala.xml.Text("\012            "));
                  $buf.&+({
                    {
                      var $md: scala.xml.MetaData = scala.xml.Null;
                      $md = new scala.xml.UnprefixedAttribute("colspan", new scala.xml.Text("2"), $md);
                      new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope, ({
                        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                        $buf.&+(new scala.xml.Text("Purchased"));
                        $buf
                      }: _*))
                    }
                  });
                  $buf.&+(new scala.xml.Text("\012            "));
                  $buf.&+({
                    {
                      var $md: scala.xml.MetaData = scala.xml.Null;
                      $md = new scala.xml.UnprefixedAttribute("colspan", new scala.xml.Text("2"), $md);
                      new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope)
                    }
                  });
                  $buf.&+(new scala.xml.Text("\012        "));
                  $buf
                }: _*))
              }
            });
            $buf.&+(new scala.xml.Text("\012        "));
            $buf.&+({
              {
                new scala.xml.Elem(null, "tr", scala.xml.Null, scala.this.Predef.$scope, ({
                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                  $buf.&+(new scala.xml.Text("\012            "));
                  $buf.&+({
                    {
                      new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                        $buf.&+(new scala.xml.Text("Ticker"));
                        $buf
                      }: _*))
                    }
                  });
                  $buf.&+(new scala.xml.Text("\012            "));
                  $buf.&+({
                    {
                      new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                        $buf.&+(new scala.xml.Text("Shares"));
                        $buf
                      }: _*))
                    }
                  });
                  $buf.&+(new scala.xml.Text("\012            "));
                  $buf.&+({
                    {
                      new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                        $buf.&+(new scala.xml.Text("on"));
                        $buf
                      }: _*))
                    }
                  });
                  $buf.&+(new scala.xml.Text("\012            "));
                  $buf.&+({
                    {
                      new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                        $buf.&+(new scala.xml.Text("at"));
                        $buf
                      }: _*))
                    }
                  });
                  $buf.&+(new scala.xml.Text("\012            "));
                  $buf.&+({
                    {
                      new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                        $buf.&+(new scala.xml.Text("Price"));
                        $buf
                      }: _*))
                    }
                  });
                  $buf.&+(new scala.xml.Text("\012            "));
                  $buf.&+({
                    {
                      new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                        $buf.&+(new scala.xml.Text("Dividends"));
                        $buf
                      }: _*))
                    }
                  });
                  $buf.&+(new scala.xml.Text("\012        "));
                  $buf
                }: _*))
              }
            });
            $buf.&+(new scala.xml.Text("\012        "));
            $buf.&+(tableRows);
            $buf.&+(new scala.xml.Text("\012    "));
            $buf
          }: _*))
        }
      };
      stockTable$lzy
    };
    lazy var tableRows$lzy: List[scala.xml.Elem] = _;
    <stable> <accessor> lazy def tableRows: List[scala.xml.Elem] = {
      tableRows$lzy = port.myStockAssets.map[scala.xml.Elem, List[scala.xml.Elem]](((asset: model.schema.StockAsset) => {
        {
          new scala.xml.Elem(null, "tr", scala.xml.Null, scala.this.Predef.$scope, ({
            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
            $buf.&+(new scala.xml.Text("\012        "));
            $buf.&+({
              {
                new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                  $buf.&+(asset.ticker);
                  $buf
                }: _*))
              }
            });
            $buf.&+(new scala.xml.Text("\012        "));
            $buf.&+({
              {
                new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                  $buf.&+(asset.shares.###());
                  $buf
                }: _*))
              }
            });
            $buf.&+(new scala.xml.Text("\012        "));
            $buf.&+({
              {
                new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                  $buf.&+(formats.`package`.dateTimeFormatted(asset.purchaseDate).toNearbyString);
                  $buf
                }: _*))
              }
            });
            $buf.&+(new scala.xml.Text("\012        "));
            $buf.&+({
              {
                new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                  $buf.&+(asset.purchasePrice.$);
                  $buf
                }: _*))
              }
            });
            $buf.&+(new scala.xml.Text("\012        "));
            $buf.&+({
              {
                new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                  $buf.&+(model.Stocks.stockPrice(asset.ticker).$);
                  $buf
                }: _*))
              }
            });
            $buf.&+(new scala.xml.Text("\012        "));
            $buf.&+({
              {
                new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                  $buf.&+(asset.totalDividends.$);
                  $buf
                }: _*))
              }
            });
            $buf.&+(new scala.xml.Text("\012    "));
            $buf
          }: _*))
        }
      }))(immutable.this.List.canBuildFrom[scala.xml.Elem]);
      tableRows$lzy
    };
    main
  }
}
stockChart: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
           apply

case class Stock extends java.lang.Object with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val symbol: String = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def symbol: String = Stock.this.symbol;
  def this(symbol: String): stockdata.Stock = {
    Stock.super.this();
    ()
  };
  private[this] val toString: String = Stock.this.symbol;
  override <stable> <accessor> def toString: String = Stock.this.toString;
  <synthetic> def copy(symbol: String = symbol): stockdata.Stock = new stockdata.this.Stock(symbol);
  <synthetic> def copy$default$1: String @scala.annotation.unchecked.uncheckedVariance = Stock.this.symbol;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(Stock.this);
  override def equals(x$1: Any): Boolean = Stock.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (symbol: String)stockdata.Stock((symbol$1 @ _)) if symbol$1.==(symbol) => x$1.asInstanceOf[stockdata.Stock].canEqual(Stock.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "Stock";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => symbol
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[stockdata.Stock]()
}
Stock: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
  symbol

final object TextAreaField extends java.lang.Object with ScalaObject {
  def this(): object intform.TextAreaField = {
    TextAreaField.super.this();
    ()
  };
  def apply(initText: String = ""): intform.TextAreaField = new TextAreaField(initText);
  <synthetic> def apply$default$1: String @scala.annotation.unchecked.uncheckedVariance = ""
}
TextAreaField: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
           apply

case class Request extends java.lang.Object with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val username: String = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def username: String = Request.this.username;
  <caseaccessor> <paramaccessor> private[this] val action: texttrading.Action = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def action: texttrading.Action = Request.this.action;
  def this(username: String, action: texttrading.Action): texttrading.Request = {
    Request.super.this();
    ()
  };
  <synthetic> def copy(username: String = username, action: texttrading.Action = action): texttrading.Request = new texttrading.this.Request(username, action);
  <synthetic> def copy$default$2: texttrading.Action @scala.annotation.unchecked.uncheckedVariance = Request.this.action;
  <synthetic> def copy$default$1: String @scala.annotation.unchecked.uncheckedVariance = Request.this.username;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(Request.this);
  override def toString(): String = ScalaRunTime.this._toString(Request.this);
  override def equals(x$1: Any): Boolean = Request.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (username: String, action: texttrading.Action)texttrading.Request((username$2 @ _), (action$1 @ _)) if username$2.==(username).&&(action$1.==(action)) => x$1.asInstanceOf[texttrading.Request].canEqual(Request.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "Request";
  override def productArity: Int = 2;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => username
    case 1 => action
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[texttrading.Request]()
}
Request: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
  action
 usernam

abstract trait ListRender extends java.lang.Object with intform.FieldRender with ScalaObject {
  def /*ListRender*/$init$(): Unit = {
    ()
  };
  <stable> <accessor> def renderer: (Seq[intform.ItemRender], scala.xml.NodeSeq) => scala.xml.NodeSeq;
  def items: Seq[intform.Field[Any] with intform.Renderable];
  def addOne(): Unit;
  def deleteOne(n: Int): Unit;
  def main: scala.xml.NodeSeq = ListRender.this.refresh.render;
  private[this] val refresh: intform.Refreshable.NeedRenderable with intform.Refreshable = Refreshable.apply(ListRender.this.renderer.apply(ListRender.this.items.zip[intform.Field[Any] with intform.Renderable, Int, Seq[(intform.Field[Any] with intform.Renderable, Int)]](ListRender.this.items.indices)(collection.this.Seq.canBuildFrom[(intform.Field[Any] with intform.Renderable, Int)]).map[intform.ItemRender, Seq[intform.ItemRender]](((x0$2: (intform.Field[Any] with intform.Renderable, Int)) => x0$2 match {
    case (_1: intform.Field[Any] with intform.Renderable, _2: Int)(intform.Field[Any] with intform.Renderable, Int)((item @ _), (index @ _)) => new intform.ItemRender(item.render, ListRender.this.del(index))
  }))(collection.this.Seq.canBuildFrom[intform.ItemRender]), ListRender.this.add));
  <stable> <accessor> def refresh: intform.Refreshable.NeedRenderable with intform.Refreshable = ListRender.this.refresh;
  def add: scala.xml.NodeSeq = net.liftweb.http.SHtml.ajaxSubmit("Add", (() => {
    ListRender.this.addOne();
    ListRender.this.refresh.refresh()
  }));
  def del(n: Int): scala.xml.NodeSeq = net.liftweb.http.SHtml.ajaxSubmit("Del", (() => {
    ListRender.this.deleteOne(n);
    ListRender.this.refresh.refresh()
  }))
}
ListRender: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.333
             add    main     del
 rendere                        
   items                        
 deleteO                     X  
  addOne     X                  

final case object NoSuchOffer extends java.lang.RuntimeException with errors.package.BadUser with ScalaObject with Product with Serializable {
  def this(): object SchemaErrors.this.NoSuchOffer = {
    NoSuchOffer.super.this();
    ()
  };
  final override def hashCode(): Int = 11147124;
  override def productPrefix: java.lang.String = "NoSuchOffer";
  override def productArity: Int = 0;
  override def productElement(x$1: Int): Any = x$1 match {
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[object SchemaErrors.this.NoSuchOffer]()
}
NoSuchOffer: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

case class Shares extends java.lang.Object with Ordered[model.Shares] with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val shares: scala.math.BigDecimal = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def shares: scala.math.BigDecimal = Shares.this.shares;
  def this(shares: scala.math.BigDecimal): model.Shares = {
    Shares.super.this();
    ()
  };
  def this(str: String): model.Shares = {
    Shares.this.this(scala.math.BigDecimal.apply(str));
    ()
  };
  def +(other: model.Shares): model.Shares = new model.Shares(Shares.this.shares.+(other.shares));
  def -(other: model.Shares): model.Shares = new model.Shares(Shares.this.shares.-(other.shares));
  def *(price: model.Price): model.Dollars = new model.Dollars(price.price.*(Shares.this.shares));
  def *(scale: model.Scale): model.Shares = new model.Shares(scale.scale.*(Shares.this.shares));
  def unary_-: model.Shares = Shares.this.copy(Shares.this.shares.unary_-);
  def compare(other: model.Shares): Int = Shares.this.shares.compare(other.shares);
  def ###(): String = scala.this.Predef.augmentString("%.0f").format(Shares.this.shares.doubleValue());
  override def toString(): String = Shares.this.###().+(if (Shares.this.shares.!=(1))
    " shares"
  else
    " share");
  def double: Double = Shares.this.shares.doubleValue();
  <synthetic> def copy$default$1: scala.math.BigDecimal @scala.annotation.unchecked.uncheckedVariance = Shares.this.shares;
  <synthetic> def copy(shares: scala.math.BigDecimal = shares): model.Shares = new model.this.Shares(shares);
  override def hashCode(): Int = ScalaRunTime.this._hashCode(Shares.this);
  override def equals(x$1: Any): Boolean = Shares.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (shares: scala.math.BigDecimal)model.Shares((shares$1 @ _)) if shares$1.==(shares) => x$1.asInstanceOf[model.Shares].canEqual(Shares.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "Shares";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => shares
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[model.Shares]()
}
Shares: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=0.208
         compare unary_$  $times  $times $hash$h  double   $plus  $minus
  shares     X       X       X       X       X       X       X       X  

abstract trait Processable[A >: Nothing <: Any] extends scala.AnyRef {
  def process(): Option[A]
}
Processable: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
 process

case class SecDollar extends Security with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val amount: model.Dollars = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def amount: model.Dollars = SecDollar.this.amount;
  def this(amount: model.Dollars): model.SecDollar = {
    SecDollar.super.this();
    ()
  };
  def *(scale: model.Scale): model.SecDollar = new model.SecDollar(SecDollar.this.amount.*(scale));
  def spotValue: model.Dollars = SecDollar.this.amount;
  <synthetic> def copy(amount: model.Dollars = amount): model.SecDollar = new model.this.SecDollar(amount);
  <synthetic> def copy$default$1: model.Dollars @scala.annotation.unchecked.uncheckedVariance = SecDollar.this.amount;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(SecDollar.this);
  override def toString(): String = ScalaRunTime.this._toString(SecDollar.this);
  override def equals(x$1: Any): Boolean = SecDollar.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (amount: model.Dollars)model.SecDollar((amount$1 @ _)) if amount$1.==(amount) => x$1.asInstanceOf[model.SecDollar].canEqual(SecDollar.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "SecDollar";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => amount
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[model.SecDollar]()
}
SecDollar: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=0.500
          $times spotVal
  amount     X       X  

class YahooStockDatabase extends java.lang.Object with stockdata.StockDatabase with net.liftweb.common.Loggable with ScalaObject {
  <paramaccessor> private[this] val queryService: stockdata.QueryService = _;
  def this(queryService: stockdata.QueryService): stockdata.YahooStockDatabase = {
    YahooStockDatabase.super.this();
    ()
  };
  private[this] val formats: net.liftweb.json.DefaultFormats.type = net.liftweb.json.DefaultFormats;
  implicit private <stable> <accessor> def formats: object net.liftweb.json.DefaultFormats = YahooStockDatabase.this.formats;
  private[this] val dateTimeFormat: org.joda.time.format.DateTimeFormatter = org.joda.time.format.DateTimeFormat.forPattern("M/d/yyyy h:mma");
  private <stable> <accessor> def dateTimeFormat: org.joda.time.format.DateTimeFormatter = YahooStockDatabase.this.dateTimeFormat;
  private[this] val responseFields: List[java.lang.String] = immutable.this.List.apply[java.lang.String]("Symbol", "StockExchange", "LastTradePriceOnly", "LastTradeDate", "LastTradeTime", "Name", "Open", "DaysHigh", "DaysLow", "ChangeinPercent", "DividendShare");
  private <stable> <accessor> def responseFields: List[java.lang.String] = YahooStockDatabase.this.responseFields;
  def getQuotes(stocks: Iterable[stockdata.Stock]): Iterable[stockdata.Quote] = {
    if (stocks.isEmpty)
      return scala.`package`.Iterable.apply[Nothing]()
    else
      ();
    val queryString: String = HttpQueryService.buildQuery(scala.this.Predef.Map.apply[java.lang.String, java.lang.String](scala.this.Predef.any2ArrowAssoc[java.lang.String]("q").->[java.lang.String](YahooStockDatabase.this.buildYQL(stocks)), scala.this.Predef.any2ArrowAssoc[java.lang.String]("format").->[java.lang.String]("json"), scala.this.Predef.any2ArrowAssoc[java.lang.String]("env").->[java.lang.String]("store://datatables.org/alltableswithkeys")), "ASCII");
    val url: java.net.URL = new java.net.URL("http://query.yahooapis.com/v1/public/yql?".+(queryString));
    val now: org.joda.time.DateTime = new org.joda.time.DateTime();
    val response: String = try {
      YahooStockDatabase.this.queryService.query(url)
    } catch {
      case (ex @ (_: java.io.IOException)) => throw new DatabaseException("Yahoo Finance query failed.", ex)
    };
    val root: net.liftweb.json.package.JValue = try {
      net.liftweb.json.JsonParser.parse(response)
    } catch {
      case (ex @ (_: net.liftweb.json.JsonParser.ParseException)) => throw new DatabaseException("Yahoo Finance returned invalid JSON.", ex)
    };
    val quoteMap: scala.collection.immutable.Map[stockdata.Stock,stockdata.Quote] = try {
      val count: Int = root.\("query").\("count").extract[Int](YahooStockDatabase.this.formats, reflect.this.Manifest.Int);
      val quoteElements: List[net.liftweb.json.JsonAST.JValue] = if (count.==(1))
        immutable.this.List.apply[net.liftweb.json.JsonAST.JValue](root.\("query").\("results").\("quote"))
      else
        root.\("query").\("results").\("quote").children;
      quoteElements.map[(stockdata.Stock, stockdata.Quote), List[(stockdata.Stock, stockdata.Quote)]](((quoteElement: net.liftweb.json.JsonAST.JValue) => {
  val stock: stockdata.Stock = new stockdata.Stock(quoteElement.\("Symbol").extract[String](YahooStockDatabase.this.formats, reflect.this.Manifest.classType[String](classOf[java.lang.String])));
  val updateTime: org.joda.time.DateTime = try {
    YahooStockDatabase.this.dateTimeFormat.parseDateTime(quoteElement.\("LastTradeDate").extract[String](YahooStockDatabase.this.formats, reflect.this.Manifest.classType[String](classOf[java.lang.String])).+(" ").+(quoteElement.\("LastTradeTime").extract[String](YahooStockDatabase.this.formats, reflect.this.Manifest.classType[String](classOf[java.lang.String]))))
  } catch {
    case (e @ (_: IllegalArgumentException)) => {
      YahooStockDatabase.this.logger.error("Failed to parse date", e);
      throw new NoSuchStockException(stock)
    }
  };
  val quote: stockdata.Quote = {
    val x$7: stockdata.Stock = stock;
    val x$8: String = quoteElement.\("Name").extract[String](YahooStockDatabase.this.formats, reflect.this.Manifest.classType[String](classOf[java.lang.String]));
    val x$9: String = quoteElement.\("StockExchange").extract[String](YahooStockDatabase.this.formats, reflect.this.Manifest.classType[String](classOf[java.lang.String]));
    val x$10: model.Price = model.Price.apply(quoteElement.\("LastTradePriceOnly").extract[String](YahooStockDatabase.this.formats, reflect.this.Manifest.classType[String](classOf[java.lang.String])));
    val x$11: org.joda.time.DateTime = new org.joda.time.DateTime();
    val x$12: stockdata.QuoteInfo = {
      val x$2: Some[scala.math.BigDecimal] = new Some[scala.math.BigDecimal](scala.`package`.BigDecimal.apply(scala.this.Predef.augmentString(quoteElement.\("ChangeinPercent").extract[String](YahooStockDatabase.this.formats, reflect.this.Manifest.classType[String](classOf[java.lang.String]))).stripSuffix("%")));
      val x$3: Option[BigDecimal] = YahooStockDatabase.this.tryExtractNumber(quoteElement.\("DividendShare"));
      val x$4: Option[BigDecimal] = YahooStockDatabase.this.tryExtractNumber(quoteElement.\("Open"));
      val x$5: Option[BigDecimal] = YahooStockDatabase.this.tryExtractNumber(quoteElement.\("DaysLow"));
      val x$6: Option[BigDecimal] = YahooStockDatabase.this.tryExtractNumber(quoteElement.\("DaysHigh"));
      new stockdata.QuoteInfo(x$2, x$4, x$5, x$6, x$3)
    };
    new stockdata.Quote(x$7, x$9, x$8, x$10, x$11, x$12)
  };
  new (stockdata.Stock, stockdata.Quote)(stock, quote)
}))(immutable.this.List.canBuildFrom[(stockdata.Stock, stockdata.Quote)]).toMap[stockdata.Stock, stockdata.Quote](scala.this.Predef.conforms[(stockdata.Stock, stockdata.Quote)])
    } catch {
      case (ex @ (_: net.liftweb.json.MappingException)) => throw new DatabaseException("Yahoo Finance returned JSON with unexpected structure.", ex)
      case (ex @ (_: NumberFormatException)) => throw new DatabaseException("Yahoo Finance returned an invalid stock price.", ex)
    };
    stocks.map[stockdata.Quote, Iterable[stockdata.Quote]](((stock: stockdata.Stock) => quoteMap.get(stock) match {
      case (x: stockdata.Quote)Some[stockdata.Quote]((quote @ (_: stockdata.Quote))) => quote
      case scala.None => {
        YahooStockDatabase.this.logger.error("Failed to find ".+(stock));
        YahooStockDatabase.this.logger.error(response);
        YahooStockDatabase.this.logger.error(queryString);
        YahooStockDatabase.this.makeUpQuote(stock)
      }
    }))(collection.this.Iterable.canBuildFrom[stockdata.Quote])
  };
  private def makeUpQuote(stock: stockdata.Stock): stockdata.Quote = new stockdata.Quote(stock, "PITFAIL", "Enterprise Solutions Inc", new model.Price(math.this.BigDecimal.double2bigDecimal(scala.math.`package`.random.*(100))), new org.joda.time.DateTime(), new stockdata.QuoteInfo(scala.None, scala.None, scala.None, scala.None, scala.None));
  private def tryExtractNumber(field: net.liftweb.json.JsonAST.JValue): Option[BigDecimal] = try {
    new Some[scala.math.BigDecimal](scala.`package`.BigDecimal.apply(field.extract[String](YahooStockDatabase.this.formats, reflect.this.Manifest.classType[String](classOf[java.lang.String]))))
  } catch {
    case _ => scala.None
  };
  private def buildYQL(symbols: Iterable[stockdata.Stock]): java.lang.String = "SELECT ".+(YahooStockDatabase.this.responseFields.mkString(",")).+(" FROM yahoo.finance.quotes ").+("WHERE symbol in (").+(symbols.map[String, Iterable[String]](((x$1: stockdata.Stock) => scala.this.Predef.augmentString("\'%s\'").format(x$1.symbol)))(collection.this.Iterable.canBuildFrom[String]).mkString(",")).+(")")
}
YahooStockDatabase: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.333
         makeUpQ buildYQ getQuot tryExtr
 querySe                     X          

final object portfolio extends java.lang.Object with ScalaObject {
  def this(): object code.snippet.portfolio = {
    portfolio.super.this();
    ()
  };
  def apply(port: model.schema.Portfolio, currentUser: Option[model.schema.User], modifiable: Boolean): scala.xml.Elem = {
    {
      new scala.xml.Elem(null, "div", scala.xml.Null, scala.this.Predef.$scope, ({
        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
        $buf.&+(new scala.xml.Text("\012        "));
        $buf.&+({
          val x$1: model.schema.Portfolio = port;
          val x$2: Boolean = modifiable;
          val x$3: Option[model.schema.User] = currentUser;
          tChart.apply(x$1, x$3, x$2)
        });
        $buf.&+(new scala.xml.Text("\012        "));
        $buf.&+(stockChart.apply(port, modifiable));
        $buf.&+(new scala.xml.Text("\012        "));
        $buf.&+(dividendChart.apply(port, modifiable));
        $buf.&+(new scala.xml.Text("\012    "));
        $buf
      }: _*))
    }
  }
}
portfolio: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
           apply

final object myPage extends java.lang.Object with ScalaObject {
  def this(): object code.snippet.myPage = {
    myPage.super.this();
    ()
  };
  def apply(): scala.xml.NodeBuffer = {
    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
    $buf.&+({
      {
        new scala.xml.Elem("lift", "PortfolioInvites", scala.xml.Null, scala.this.Predef.$scope)
      }
    });
    $buf.&+({
      {
        var $md: scala.xml.MetaData = scala.xml.Null;
        $md = new scala.xml.UnprefixedAttribute("type", new scala.xml.Text("Offers"), $md);
        new scala.xml.Elem("lift", "comet", $md, scala.this.Predef.$scope)
      }
    });
    $buf.&+({
      {
        var $md: scala.xml.MetaData = scala.xml.Null;
        $md = new scala.xml.UnprefixedAttribute("type", new scala.xml.Text("Dashboard"), $md);
        new scala.xml.Elem("lift", "comet", $md, scala.this.Predef.$scope)
      }
    });
    $buf.&+({
      {
        var $md: scala.xml.MetaData = scala.xml.Null;
        $md = new scala.xml.UnprefixedAttribute("type", new scala.xml.Text("OutgoingOffers"), $md);
        new scala.xml.Elem("lift", "comet", $md, scala.this.Predef.$scope)
      }
    });
    $buf
  }
}
myPage: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
           apply

class BoxOps[A >: Nothing <: Any] extends java.lang.Object with ScalaObject {
  <paramaccessor> private[this] val b: net.liftweb.common.Box[A] = _;
  def this(b: net.liftweb.common.Box[A]): errors.package.BoxOps[A] = {
    BoxOps.super.this();
    ()
  };
  def withMessage(m: String => A): A = BoxOps.this.b match {
    case net.liftweb.common.Empty => m.apply("Unknown error")
    case (msg: String, exception: net.liftweb.common.Box[Throwable], chain: net.liftweb.common.Box[net.liftweb.common.Failure])net.liftweb.common.Failure((msg @ _), _, _) => m.apply(msg)
    case (value: A)net.liftweb.common.Full[A]((a @ _)) => a
  }
}
BoxOps: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
         withMes
       b     X  

abstract class SubmitResult[A >: Nothing <: Any] extends java.lang.Object with ScalaObject {
  def this(): intform.SubmitResult[A] = {
    SubmitResult.super.this();
    ()
  }
}
SubmitResult: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

final object Price extends java.lang.Object with ScalaObject with Serializable {
  def this(): object model.Price = {
    Price.super.this();
    ()
  };
  def apply(str: String): model.Price = new model.Price(scala.math.BigDecimal.apply(str));
  case <synthetic> def unapply(x$0: model.Price): Option[scala.math.BigDecimal] = if (x$0.==(null))
    scala.this.None
  else
    new Some[scala.math.BigDecimal](x$0.price);
  case <synthetic> def apply(price: scala.math.BigDecimal): model.Price = new model.this.Price(price);
  protected def readResolve(): java.lang.Object = model.this.Price
}
Price: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.500
           apply readRes

abstract trait UserOps extends java.lang.Object with ScalaObject { self: UserSchema.this.User => 
  def /*UserOps*/$init$(): Unit = {
    ()
  };
  def myPortfolios: List[UserSchema.this.Portfolio] = UserSchema.this.readDB[List[UserSchema.this.Portfolio]](UserSchema.this.ownerships.filter(((x$1: UserSchema.this.Ownership) => x$1.user.~~(this))).map[UserSchema.this.Portfolio, scala.collection.mutable.ArrayBuffer[UserSchema.this.Portfolio]](((x$2: UserSchema.this.Ownership) => x$2.portfolio))(mutable.this.ArrayBuffer.canBuildFrom[UserSchema.this.Portfolio]).toList);
  def userCreatePortfolio(name: String): UserSchema.this.Portfolio = UserSchema.this.editDB[UserSchema.this.Portfolio](UserOps.this.createPortfolio(name));
  def portfolioByName(name: String): UserSchema.this.Portfolio = UserSchema.this.readDB[UserSchema.this.Portfolio](UserSchema.this.ownerships.filter(((x$3: UserSchema.this.Ownership) => x$3.user.~~(this))).map[UserSchema.this.Portfolio, scala.collection.mutable.ArrayBuffer[UserSchema.this.Portfolio]](((x$4: UserSchema.this.Ownership) => x$4.portfolio))(mutable.this.ArrayBuffer.canBuildFrom[UserSchema.this.Portfolio]).filter(((x$5: UserSchema.this.Portfolio) => x$5.name.==(name))).headOption.getOrElse[UserSchema.this.Portfolio](throw UserSchema.this.NoSuchPortfolio));
  def userSwitchPortfolio(port: UserSchema.this.Portfolio): Unit = UserSchema.this.editDB[Unit](UserOps.this.switchPortfolio(port));
  def myPortfolioInvites: List[UserSchema.this.PortfolioInvite] = UserSchema.this.readDB[List[UserSchema.this.PortfolioInvite]](UserSchema.this.portfolioInvites.filter(((x$6: UserSchema.this.PortfolioInvite) => x$6.to.~~(this))).toList);
  def userAcceptInvite(invite: UserSchema.this.PortfolioInvite): Unit = UserSchema.this.editDB[Unit](UserOps.this.acceptInvite(invite));
  def userDeclineInvite(invite: UserSchema.this.PortfolioInvite): UserSchema.this.PortfolioInvite = UserSchema.this.editDB[UserSchema.this.PortfolioInvite](UserOps.this.declineInvite(invite));
  private[model] def createPortfolio(name: String): UserSchema.this.Transaction[UserSchema.this.Portfolio] = {
    if (UserSchema.this.portfolios.exists(((x$7: UserSchema.this.Portfolio) => x$7.name.==(name))))
      throw UserSchema.this.NameInUse
    else
      ();
    val league: UserSchema.this.League = UserSchema.this.League.default();
    val cash: model.Dollars = league.startingCash;
    UserSchema.this.toOps[UserSchema.this.Portfolio]({
  val x$24: String = name;
  val x$25: model.Link[UserSchema.this.League] = model.this.KL.toLink[UserSchema.this.League](league);
  val x$26: model.Dollars = cash;
  val x$27: model.Dollars = cash;
  val x$28: Int(1000) = 1000;
  val x$29: model.package.Key = UserSchema.this.Portfolio.apply$default$1;
  new UserSchema.this.Portfolio(x$29, x$25, x$24, x$26, x$27, 1000)
}).insert(UserSchema.this.portfolios).flatMap[UserSchema.this.Portfolio](((port: UserSchema.this.Portfolio) => UserSchema.this.toOps[UserSchema.this.Ownership]({
  val x$30: UserSchema.this.User = this;
  val x$31: UserSchema.this.Portfolio = port;
  val x$32: model.package.Key = UserSchema.this.Ownership.apply$default$1;
  new UserSchema.this.Ownership(x$32, x$30, x$31)
}).insert(UserSchema.this.ownerships).map[UserSchema.this.Portfolio](((_: UserSchema.this.Ownership) => port))))
  };
  private[model] def switchPortfolio(port: UserSchema.this.Portfolio): UserSchema.this.Transaction[Unit] = UserSchema.this.toOps[UserSchema.this.User](this).update(((t: UserSchema.this.User) => {
    val x$33: model.Link[UserSchema.this.Portfolio] = model.this.KL.toLink[UserSchema.this.Portfolio](port);
    val x$34: model.package.Key = t.copy$default$1;
    val x$35: String = t.copy$default$2;
    t.copy(x$34, x$35, x$33)
  }))(UserSchema.this.users);
  private[model] def acceptInvite(invite: UserSchema.this.PortfolioInvite): UserSchema.this.Transaction[Unit] = UserSchema.this.toOps[UserSchema.this.Ownership]({
  val x$36: UserSchema.this.User = this;
  val x$37: UserSchema.this.Portfolio = invite.from;
  val x$38: model.package.Key = UserSchema.this.Ownership.apply$default$1;
  new UserSchema.this.Ownership(x$38, x$36, x$37)
}).insert(UserSchema.this.ownerships).flatMap[Unit](((_: UserSchema.this.Ownership) => UserSchema.this.toOps[UserSchema.this.PortfolioInvite](invite).delete(UserSchema.this.portfolioInvites).map[Unit](((_: UserSchema.this.PortfolioInvite) => ()))));
  private[model] def declineInvite(invite: UserSchema.this.PortfolioInvite): UserSchema.this.Transaction[UserSchema.this.PortfolioInvite] = UserSchema.this.toOps[UserSchema.this.PortfolioInvite](invite).delete(UserSchema.this.portfolioInvites)
}
UserOps: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.273
         acceptI portfol decline createP userDec myPortf userSwi myPortf userAcc userCre switchP

class CachedDividendDatabase extends java.lang.Object with stockdata.DividendDatabase with ScalaObject {
  <paramaccessor> private[this] val db: stockdata.DividendDatabase = _;
  def this(db: stockdata.DividendDatabase): stockdata.CachedDividendDatabase = {
    CachedDividendDatabase.super.this();
    ()
  };
  type Result = Seq[stockdata.Dividend];
  private[this] val map: stockdata.CacheMap[stockdata.Stock,CachedDividendDatabase.this.Result] = new stockdata.CacheMap[stockdata.Stock,CachedDividendDatabase.this.Result](new org.joda.time.Duration(300000L));
  <stable> <accessor> def map: stockdata.CacheMap[stockdata.Stock,CachedDividendDatabase.this.Result] = CachedDividendDatabase.this.map;
  def recentDividends(stock: stockdata.Stock): CachedDividendDatabase.this.Result = CachedDividendDatabase.this.map.get(stock)(CachedDividendDatabase.this.db.recentDividends(stock))
}
CachedDividendDatabase: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
         recentD
      db     X  

class PriceField extends intform.TextField[model.Price] with ScalaObject {
  <paramaccessor> private[this] val initText: String = _;
  def this(initText: String): code.snippet.PriceField = {
    PriceField.super.this(initText);
    ()
  };
  def produce(): intform.SubmitResult[model.Price] = try {
    new intform.OK[model.Price](model.Price.apply(PriceField.this.text))
  } catch {
    case (_: NumberFormatException) => new intform.Error("Should be a price in dollars")
  }
}
PriceField: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
         produce
 initTex        

final object Response extends  {
  def this() = _
}
Response: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

case class Error extends intform.SubmitResult[Nothing] with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val msg: String = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def msg: String = Error.this.msg;
  def this(msg: String): intform.Error = {
    Error.super.this();
    ()
  };
  <synthetic> def copy(msg: String = msg): intform.Error = new intform.this.Error(msg);
  <synthetic> def copy$default$1: String @scala.annotation.unchecked.uncheckedVariance = Error.this.msg;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(Error.this);
  override def toString(): String = ScalaRunTime.this._toString(Error.this);
  override def equals(x$1: Any): Boolean = Error.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (msg: String)intform.Error((msg$3 @ _)) if msg$3.==(msg) => x$1.asInstanceOf[intform.Error].canEqual(Error.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "Error";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => msg
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[intform.Error]()
}
Error: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
     msg

final object theirPage extends java.lang.Object with ScalaObject {
  def this(): object code.snippet.theirPage = {
    theirPage.super.this();
    ()
  };
  def apply(user: model.schema.User): scala.xml.Elem = {
    val ports: List[model.schema.Portfolio] = user.myPortfolios;
    val portStuff: Any = if (ports.length.==(0))
      {
        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
        $buf.&+({
          {
            new scala.xml.Elem(null, "p", scala.xml.Null, scala.this.Predef.$scope, ({
              val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
              $buf.&+(new scala.xml.Text("This user has no portfolios."));
              $buf
            }: _*))
          }
        });
        $buf.&+({
          {
            new scala.xml.Elem(null, "p", scala.xml.Null, scala.this.Predef.$scope, ({
              val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
              $buf.&+(new scala.xml.Text("You should whine to them about that."));
              $buf
            }: _*))
          }
        });
        $buf
      }
    else
      if (ports.length.==(1))
        ()
      else
        {
          val portList: List[scala.xml.Elem] = ports.map[scala.xml.Elem, List[scala.xml.Elem]](((port: model.schema.Portfolio) => {
            {
              new scala.xml.Elem(null, "li", scala.xml.Null, scala.this.Predef.$scope, ({
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+(PortfolioLink.apply(port));
                $buf
              }: _*))
            }
          }))(immutable.this.List.canBuildFrom[scala.xml.Elem]);
          {
            {
              new scala.xml.Elem(null, "ul", scala.xml.Null, scala.this.Predef.$scope, ({
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+(portList);
                $buf
              }: _*))
            }
          }
        };
    {
      {
        var $md: scala.xml.MetaData = scala.xml.Null;
        $md = new scala.xml.UnprefixedAttribute("id", new scala.xml.Text("user-page"), $md);
        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("block"), $md);
        new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
          $buf.&+(new scala.xml.Text("\012        "));
          $buf.&+({
            {
              new scala.xml.Elem(null, "h2", scala.xml.Null, scala.this.Predef.$scope, ({
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+(new scala.xml.Text("User: "));
                $buf.&+(user.username);
                $buf
              }: _*))
            }
          });
          $buf.&+(new scala.xml.Text("\012        "));
          $buf.&+(portStuff);
          $buf.&+(new scala.xml.Text("\012    "));
          $buf
        }: _*))
      }
    }
  }
}
theirPage: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
           apply

abstract trait Page extends java.lang.Object with net.liftweb.http.StatefulSnippet with intform.Renderable with ScalaObject {
  def /*Page*/$init$(): Unit = {
    ()
  };
  def dispatch: Page.this.DispatchIt = ((x0$1: String) => x0$1 match {
    case "render" => ((in: scala.xml.NodeSeq) => Page.this.render)
  })
}
Page: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
         dispatc

abstract trait AuctionOfferOps extends java.lang.Object with ScalaObject { self: AuctionSchema.this.AuctionOffer => 
  def /*AuctionOfferOps*/$init$(): Unit = {
    ()
  };
  def bids: Seq[AuctionSchema.this.AuctionBid] = AuctionSchema.this.auctionBids.filter(((x$1: AuctionSchema.this.AuctionBid) => x$1.offer.~~(this))).toList;
  def goingPrice: model.Dollars = if (AuctionOfferOps.this.bids.isEmpty)
    AuctionOfferOps.this.price
  else
    AuctionOfferOps.this.bids.map[model.Dollars, Seq[model.Dollars]](((x$2: AuctionSchema.this.AuctionBid) => x$2.price))(collection.this.Seq.canBuildFrom[model.Dollars]).max[model.Dollars](math.this.Ordering.ordered[model.Dollars](scala.this.Predef.conforms[model.Dollars]));
  def highBid: Option[AuctionSchema.this.AuctionBid] = if (AuctionOfferOps.this.bids.isEmpty)
    scala.None
  else
    new Some[AuctionSchema.this.AuctionBid](AuctionOfferOps.this.bids.maxBy[model.Dollars](((x$3: AuctionSchema.this.AuctionBid) => x$3.price))(math.this.Ordering.ordered[model.Dollars](scala.this.Predef.conforms[model.Dollars])));
  def userClose(): Unit = AuctionSchema.this.editDB[Unit]({
    val deletion: AuctionSchema.this.Transaction[Unit] = AuctionSchema.this.toOps[AuctionSchema.this.AuctionOffer](this).delete(AuctionSchema.this.auctionOffers).flatMap[Unit](((_: AuctionSchema.this.AuctionOffer) => scalaz.Scalaz.SeqMA[Seq, AuctionSchema.this.Transaction[AuctionSchema.this.AuctionBid]](AuctionOfferOps.this.bids.map[AuctionSchema.this.Transaction[AuctionSchema.this.AuctionBid], Seq[AuctionSchema.this.Transaction[AuctionSchema.this.AuctionBid]]](((x$4: AuctionSchema.this.AuctionBid) => AuctionSchema.this.toOps[AuctionSchema.this.AuctionBid](x$4).delete(AuctionSchema.this.auctionBids)))(collection.this.Seq.canBuildFrom[AuctionSchema.this.Transaction[AuctionSchema.this.AuctionBid]])).sequence[AuctionSchema.this.Transaction, AuctionSchema.this.AuctionBid](scala.this.Predef.conforms[AuctionSchema.this.Transaction[AuctionSchema.this.AuctionBid]], scalaz.this.Traverse.TraversableTraverse[Seq](scalaz.this.CanBuildAnySelf.GenericCanBuildSelf[Seq](collection.this.Seq.canBuildFrom[Nothing])), scalaz.this.Applicative.applicative[AuctionSchema.this.Transaction](AuctionSchema.this.TransactionPure, scalaz.this.Apply.FunctorBindApply[AuctionSchema.this.Transaction](AuctionSchema.this.TransactionFunctor, AuctionSchema.this.TransactionBind))).flatMap[Unit](((_: Seq[AuctionSchema.this.AuctionBid]) => new AuctionSchema.this.Closed(model.this.Link.extract[AuctionSchema.this.Portfolio](AuctionOfferOps.this.offerer)(AuctionSchema.this.portfolios), this).report().map[Unit](((_: AuctionSchema.this.NewsEvent) => ()))))));
    AuctionOfferOps.this.highBid match {
      case scala.None => deletion
      case (x: AuctionSchema.this.AuctionBid)Some[AuctionSchema.this.AuctionBid]((bid @ _)) => deletion.flatMap[Unit](((_: Unit) => model.this.Link.extract[AuctionSchema.this.Portfolio](bid.by)(AuctionSchema.this.portfolios).enterContractWithVotes(model.this.Link.extract[AuctionSchema.this.Portfolio](AuctionOfferOps.this.offerer)(AuctionSchema.this.portfolios), AuctionOfferOps.this.derivative, bid.price).filter(((check$ifrefutable$1: (AuctionSchema.this.DerivativeBuyerSetAside, AuctionSchema.this.DerivativeSellerSetAside)) => (check$ifrefutable$1: (AuctionSchema.this.DerivativeBuyerSetAside, AuctionSchema.this.DerivativeSellerSetAside) @unchecked) match {
  case (_1: AuctionSchema.this.DerivativeBuyerSetAside, _2: AuctionSchema.this.DerivativeSellerSetAside)(AuctionSchema.this.DerivativeBuyerSetAside, AuctionSchema.this.DerivativeSellerSetAside)((buyerAside @ _), (sellerAside @ _)) => true
  case _ => false
})).flatMap[Unit](((x$5: (AuctionSchema.this.DerivativeBuyerSetAside, AuctionSchema.this.DerivativeSellerSetAside)) => (x$5: (AuctionSchema.this.DerivativeBuyerSetAside, AuctionSchema.this.DerivativeSellerSetAside) @unchecked) match {
        case (_1: AuctionSchema.this.DerivativeBuyerSetAside, _2: AuctionSchema.this.DerivativeSellerSetAside)(AuctionSchema.this.DerivativeBuyerSetAside, AuctionSchema.this.DerivativeSellerSetAside)((buyerAside @ _), (sellerAside @ _)) => new AuctionSchema.this.Won(model.this.Link.extract[AuctionSchema.this.Portfolio](bid.by)(AuctionSchema.this.portfolios), model.this.Link.extract[AuctionSchema.this.Portfolio](AuctionOfferOps.this.offerer)(AuctionSchema.this.portfolios), AuctionOfferOps.this.derivative, model.this.KL.toLink[AuctionSchema.this.DerivativeBuyerSetAside](buyerAside), model.this.KL.toLink[AuctionSchema.this.DerivativeSellerSetAside](sellerAside)).report().map[Unit](((_: AuctionSchema.this.NewsEvent) => ()))
      }))))
    }
  })
}
AuctionOfferOps: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=1.000
         goingPr userClo    bids highBid

case class BidTooSmall extends java.lang.RuntimeException with errors.package.BadUser with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val going: model.Dollars = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def going: model.Dollars = BidTooSmall.this.going;
  def this(going: model.Dollars): SchemaErrors.this.BidTooSmall = {
    BidTooSmall.super.this();
    ()
  };
  <synthetic> def copy(going: model.Dollars = going): SchemaErrors.this.BidTooSmall = new SchemaErrors.this.BidTooSmall(going);
  <synthetic> def copy$default$1: model.Dollars @scala.annotation.unchecked.uncheckedVariance = BidTooSmall.this.going;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(BidTooSmall.this);
  override def equals(x$1: Any): Boolean = BidTooSmall.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (going: model.Dollars)SchemaErrors.this.BidTooSmall((going$1 @ _)) if going$1.==(going) => x$1.asInstanceOf[SchemaErrors.this.BidTooSmall].canEqual(BidTooSmall.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "BidTooSmall";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => going
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[SchemaErrors.this.BidTooSmall]()
}
BidTooSmall: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
   going

final object package extends java.lang.Object with ScalaObject {
  def this(): object model.package = {
    package.super.this();
    ()
  };
  type Key = String;
  def nextID: model.package.Key = java.util.UUID.randomUUID().toString().substring(0, 5);
  implicit def bigDecimalOps(b: scala.math.BigDecimal): java.lang.Object{def round(decimals: Int,mode: java.math.RoundingMode): scala.math.BigDecimal; def floor: scala.math.BigDecimal; def evenCents: scala.math.BigDecimal} = {
    final class $anon extends scala.AnyRef {
      def this(): anonymous class $anon = {
        $anon.super.this();
        ()
      };
      def round(decimals: Int, mode: java.math.RoundingMode): scala.math.BigDecimal = {
        val precision: Int = b.precision.-(b.scale).+(decimals);
        if (precision.>(0))
          {
            val context: java.math.MathContext = new java.math.MathContext(precision, mode);
            val out: scala.math.BigDecimal = b.round(context);
            out
          }
        else
          scala.math.BigDecimal.apply("0")
      };
      def floor: scala.math.BigDecimal = $anon.this.round(0, value FLOOR);
      def evenCents: scala.math.BigDecimal = $anon.this.round(2, value FLOOR)
    };
    new $anon()
  }
}
package: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.500
         bigDeci  nextID

abstract trait AutoTradeSchema extends java.lang.Object with ScalaObject { self: model.AutoTradeSchema with model.DBMagic with model.UserSchema => 
  def /*AutoTradeSchema*/$init$(): Unit = {
    ()
  };
  private[this] val autoTrades: model.Table[AutoTradeSchema.this.AutoTrade] = AutoTradeSchema.this.table[AutoTradeSchema.this.AutoTrade];
  implicit <stable> <accessor> def autoTrades: model.Table[AutoTradeSchema.this.AutoTrade] = AutoTradeSchema.this.autoTrades;
  case class AutoTrade extends java.lang.Object with model.KL with AutoTradeSchema.this.AutoTradeOps with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val id: model.package.Key = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def id: model.package.Key = AutoTrade.this.id;
    <caseaccessor> <paramaccessor> private[this] val owner: AutoTradeSchema.this.Portfolio = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def owner: AutoTradeSchema.this.Portfolio = AutoTrade.this.owner;
    <caseaccessor> <paramaccessor> private[this] val title: String = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def title: String = AutoTrade.this.title;
    <caseaccessor> <paramaccessor> private[this] val code: String = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def code: String = AutoTrade.this.code;
    def this(id: model.package.Key = model.this.`package`.nextID, owner: AutoTradeSchema.this.Portfolio, title: String, code: String): AutoTradeSchema.this.AutoTrade = {
      AutoTrade.super.this();
      ()
    };
    <synthetic> def copy(id: model.package.Key = id, owner: AutoTradeSchema.this.Portfolio = owner, title: String = title, code: String = code): AutoTradeSchema.this.AutoTrade = new AutoTradeSchema.this.AutoTrade(id, owner, title, code);
    <synthetic> def copy$default$4: String @scala.annotation.unchecked.uncheckedVariance = AutoTrade.this.code;
    <synthetic> def copy$default$3: String @scala.annotation.unchecked.uncheckedVariance = AutoTrade.this.title;
    <synthetic> def copy$default$2: AutoTradeSchema.this.Portfolio @scala.annotation.unchecked.uncheckedVariance = AutoTrade.this.owner;
    <synthetic> def copy$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = AutoTrade.this.id;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(AutoTrade.this);
    override def toString(): String = ScalaRunTime.this._toString(AutoTrade.this);
    override def equals(x$1: Any): Boolean = AutoTrade.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (id: model.package.Key, owner: AutoTradeSchema.this.Portfolio, title: String, code: String)AutoTradeSchema.this.AutoTrade((id$1 @ _), (owner$1 @ _), (title$1 @ _), (code$1 @ _)) if id$1.==(id).&&(owner$1.==(owner)).&&(title$1.==(title)).&&(code$1.==(code)) => x$1.asInstanceOf[AutoTradeSchema.this.AutoTrade].canEqual(AutoTrade.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "AutoTrade";
    override def productArity: Int = 4;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => id
      case 1 => owner
      case 2 => title
      case 3 => code
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[AutoTradeSchema.this.AutoTrade]()
  };
  final <synthetic> object AutoTrade extends scala.runtime.AbstractFunction4[model.package.Key,AutoTradeSchema.this.Portfolio,String,String,AutoTradeSchema.this.AutoTrade] with ScalaObject with Serializable {
    def this(): object AutoTradeSchema.this.AutoTrade = {
      AutoTrade.super.this();
      ()
    };
    final override def toString(): java.lang.String = "AutoTrade";
    <synthetic> def apply$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
    <synthetic> def init$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
    case <synthetic> def unapply(x$0: AutoTradeSchema.this.AutoTrade): Option[(model.package.Key, AutoTradeSchema.this.Portfolio, String, String)] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(model.package.Key, AutoTradeSchema.this.Portfolio, String, String)](new (model.package.Key, AutoTradeSchema.this.Portfolio, String, String)(x$0.id, x$0.owner, x$0.title, x$0.code));
    case <synthetic> def apply(id: model.package.Key = model.this.`package`.nextID, owner: AutoTradeSchema.this.Portfolio, title: String, code: String): AutoTradeSchema.this.AutoTrade = new AutoTradeSchema.this.AutoTrade(id, owner, title, code)
  };
  @volatile <synthetic> private[this] var AutoTrade$module: object AutoTradeSchema.this.AutoTrade = _;
  final <synthetic> <stable> def AutoTrade: object AutoTradeSchema.this.AutoTrade = new object AutoTradeSchema.this.AutoTrade();
  abstract trait PortfolioWithAutoTrades extends java.lang.Object with ScalaObject { self: AutoTradeSchema.this.Portfolio => 
    def /*PortfolioWithAutoTrades*/$init$(): Unit = {
      ()
    };
    def userMakeNewAutoTrade(): AutoTradeSchema.this.AutoTrade = AutoTradeSchema.this.editDB[AutoTradeSchema.this.AutoTrade](PortfolioWithAutoTrades.this.makeNewAutoTrade);
    def myAutoTrades: List[AutoTradeSchema.this.AutoTrade] = AutoTradeSchema.this.autoTrades.filter(((x$1: AutoTradeSchema.this.AutoTrade) => x$1.owner.~~(this))).toList;
    private[model] def makeNewAutoTrade: AutoTradeSchema.this.Transaction[AutoTradeSchema.this.AutoTrade] = AutoTradeSchema.this.toOps[AutoTradeSchema.this.AutoTrade]({
  val x$2: AutoTradeSchema.this.Portfolio = this;
  val x$3: java.lang.String("") = "";
  val x$4: java.lang.String("") = "";
  val x$5: model.package.Key = AutoTradeSchema.this.AutoTrade.apply$default$1;
  new AutoTradeSchema.this.AutoTrade(x$5, x$2, "", "")
}).insert(AutoTradeSchema.this.autoTrades)
  };
  abstract trait AutoTradeOps extends java.lang.Object with ScalaObject { self: AutoTradeSchema.this.AutoTrade => 
    def /*AutoTradeOps*/$init$(): Unit = {
      ()
    };
    def userModify(title: String, code: String): Unit = AutoTradeSchema.this.editDB[Unit](AutoTradeOps.this.modify(title, code));
    def userDelete(): AutoTradeSchema.this.AutoTrade = AutoTradeSchema.this.editDB[AutoTradeSchema.this.AutoTrade](AutoTradeSchema.this.toOps[AutoTradeSchema.this.AutoTrade](this).delete(AutoTradeSchema.this.autoTrades));
    private[model] def modify(title: String, code: String): AutoTradeSchema.this.Transaction[Unit] = AutoTradeSchema.this.toOps[AutoTradeSchema.this.AutoTrade](this).update(((t: AutoTradeSchema.this.AutoTrade) => {
      val x$6: String = title;
      val x$7: String = code;
      val x$8: model.package.Key = t.copy$default$1;
      val x$9: AutoTradeSchema.this.Portfolio = t.copy$default$2;
      t.copy(x$8, x$9, x$6, x$7)
    }))(AutoTradeSchema.this.autoTrades)
  }
}
AutoTradeSchema: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
 AutoTra

class YahooDividendDatabase extends java.lang.Object with stockdata.DividendDatabase with net.liftweb.common.Loggable with ScalaObject {
  <paramaccessor> private[this] val queryService: stockdata.QueryService = _;
  def this(queryService: stockdata.QueryService): stockdata.YahooDividendDatabase = {
    YahooDividendDatabase.super.this();
    ()
  };
  def recentDividends(stock: stockdata.Stock): Seq[stockdata.Dividend] = {
    val end: org.joda.time.DateTime = new org.joda.time.DateTime();
    val start: org.joda.time.DateTime = end.minusDays(7);
    val query: String = HttpQueryService.buildQuery(collection.this.Seq.apply[(java.lang.String, java.lang.String)](scala.this.Predef.any2ArrowAssoc[java.lang.String]("s").->[String](stock.symbol), scala.this.Predef.any2ArrowAssoc[java.lang.String]("a").->[String](scala.this.Predef.augmentString("%d").format(start.monthOfYear().get().-(1))), scala.this.Predef.any2ArrowAssoc[java.lang.String]("b").->[String](scala.this.Predef.augmentString("%d").format(start.dayOfMonth().get())), scala.this.Predef.any2ArrowAssoc[java.lang.String]("c").->[String](scala.this.Predef.augmentString("%d").format(start.year().get())), scala.this.Predef.any2ArrowAssoc[java.lang.String]("d").->[String](scala.this.Predef.augmentString("%d").format(end.monthOfYear().get().-(1))), scala.this.Predef.any2ArrowAssoc[java.lang.String]("e").->[String](scala.this.Predef.augmentString("%d").format(end.dayOfMonth().get())), scala.this.Predef.any2ArrowAssoc[java.lang.String]("f").->[String](scala.this.Predef.augmentString("%d").format(end.year().get())), scala.this.Predef.any2ArrowAssoc[java.lang.String]("g").->[java.lang.String]("v"), scala.this.Predef.any2ArrowAssoc[java.lang.String]("ignore").->[java.lang.String](".csv")), "UTF-8");
    val url: java.lang.String = "http://ichart.finance.yahoo.com/table.csv?".+(query);
    YahooDividendDatabase.this.logger.info("Querying ".+(url));
    val response: String = try {
      YahooDividendDatabase.this.queryService.query(new java.net.URL(url))
    } catch {
      case (e @ (_: java.io.IOException)) => {
        YahooDividendDatabase.this.logger.error("Failing URL was ".+(url));
        throw new stockdata.DatabaseException("Dividend query failed", e)
      }
    };
    val formatSpec: java.lang.String = "MM/dd";
    val format: org.joda.time.format.DateTimeFormatter = org.joda.time.format.DateTimeFormat.forPattern(formatSpec);
    scala.this.Predef.refArrayOps[java.lang.String](scala.this.Predef.refArrayOps[java.lang.String](scala.this.Predef.refArrayOps[java.lang.String](response.split("$")).tail).init).map[stockdata.Dividend, Seq[stockdata.Dividend]](((line: java.lang.String) => scala.this.Predef.refArrayOps[java.lang.String](line.split("\\,")).toList match {
      case (hd: java.lang.String, tl: List[java.lang.String])collection.immutable.::[java.lang.String]((dateString @ _), (hd: java.lang.String, tl: List[java.lang.String])collection.immutable.::[java.lang.String]((priceString @ _), _)) => new stockdata.Dividend(stock.symbol, format.parseDateTime(dateString), model.Price.apply(priceString))
      case _ => throw new stockdata.DatabaseException("I do not understand ".+(line), null)
    }))(scala.this.Array.fallbackCanBuildFrom[stockdata.Dividend](Predef.this.DummyImplicit.dummyImplicit))
  }
}
YahooDividendDatabase: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
         recentD
 querySe     X  

abstract trait DummySchema extends java.lang.Object with ScalaObject {
  def /*DummySchema*/$init$(): Unit = {
    ()
  };
  def init(): Unit = ();
  def clearDatabase(): Unit = ();
  def schemaDDL: String = ""
}
DummySchema: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=1.000
            init schemaD clearDa

final class $anon extends scala.AnyRef {
  def this(): anonymous class $anon = {
    $anon.super.this();
    ()
  };
  def round(decimals: Int, mode: java.math.RoundingMode): scala.math.BigDecimal = {
    val precision: Int = b.precision.-(b.scale).+(decimals);
    if (precision.>(0))
      {
        val context: java.math.MathContext = new java.math.MathContext(precision, mode);
        val out: scala.math.BigDecimal = b.round(context);
        out
      }
    else
      scala.math.BigDecimal.apply("0")
  };
  def floor: scala.math.BigDecimal = $anon.this.round(0, value FLOOR);
  def evenCents: scala.math.BigDecimal = $anon.this.round(2, value FLOOR)
}
$anon: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.333
           floor   round evenCen

final object Shares extends java.lang.Object with ScalaObject with Serializable {
  def this(): object model.Shares = {
    Shares.super.this();
    ()
  };
  def apply(str: String): model.Shares = new model.Shares(scala.math.BigDecimal.apply(str));
  case <synthetic> def unapply(x$0: model.Shares): Option[scala.math.BigDecimal] = if (x$0.==(null))
    scala.this.None
  else
    new Some[scala.math.BigDecimal](x$0.shares);
  case <synthetic> def apply(shares: scala.math.BigDecimal): model.Shares = new model.this.Shares(shares);
  protected def readResolve(): java.lang.Object = model.this.Shares
}
Shares: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.500
         readRes   apply

final object BooleanField extends java.lang.Object with ScalaObject {
  def this(): object intform.BooleanField = {
    BooleanField.super.this();
    ()
  };
  def apply(i: Boolean = false): intform.BooleanField = new BooleanField(i);
  <synthetic> def apply$default$1: Boolean @scala.annotation.unchecked.uncheckedVariance = false
}
BooleanField: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
           apply

final protected object requestToken extends net.liftweb.http.SessionVar[Option[org.scribe.model.Token]] with ScalaObject {
  def this(): object code.control.TwitterLogin.requestToken = {
    requestToken.super.this(scala.None);
    ()
  }
}
requestToken: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

class SellThisStock extends java.lang.Object with intform.Renderable with net.liftweb.common.Loggable with ScalaObject {
  <paramaccessor> private[this] val ticker: String = _;
  def this(ticker: String): code.snippet.SellThisStock = {
    SellThisStock.super.this();
    ()
  };
  def render: scala.xml.NodeSeq = intform.FormSubmit.rendered("Sell")({
    js.this.JsCmd.unitToJsCmd(SellThisStock.this.userSellStock())
  });
  def userSellStock(): Unit = {
    try {
      control.PortfolioSwitcher.currentPortfolio.userSellAll(SellThisStock.this.ticker)
    } catch {
      case control.LoginManager.NotLoggedIn => throw new intform.BadInput("You must be logged in to trade")
      case (ticker: String)model.schema.DontOwnStock(_) => throw new intform.BadInput("You don\'t own this stock")
    }
  }
}
SellThisStock: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
          render userSel
  ticker     X       X  

case class OK[A >: Nothing <: Any] extends intform.SubmitResult[A] with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val res: A = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def res: A = OK.this.res;
  def this(res: A): intform.OK[A] = {
    OK.super.this();
    ()
  };
  <synthetic> def copy[A >: Nothing <: Any](res: A = res): intform.OK[A] = new intform.this.OK[A](res);
  <synthetic> def copy$default$1[A >: Nothing <: Any]: A @scala.annotation.unchecked.uncheckedVariance = OK.this.res;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(OK.this);
  override def toString(): String = ScalaRunTime.this._toString(OK.this);
  override def equals(x$1: Any): Boolean = OK.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (res: Any)intform.OK[Any]((res$1 @ _)) if res$1.==(res) => x$1.asInstanceOf[intform.OK[A]].canEqual(OK.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "OK";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => res
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[intform.OK[A]]()
}
OK: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
     res

case class Insert[R >: Nothing <: model.KL] extends java.lang.Object with Transactions.this.EditOp with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val rec: R = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def rec: R = Insert.this.rec;
  <caseaccessor> <paramaccessor> private[this] val table: model.Table[R] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def table: model.Table[R] = Insert.this.table;
  def this(rec: R, table: model.Table[R]): Transactions.this.Insert[R] = {
    Insert.super.this();
    ()
  };
  def perform(): Unit = {
    Transactions.this.logger.info("Inserting ".+(Insert.this.rec));
    Insert.this.table.insert(Insert.this.rec)
  };
  private[this] val affectedTables: Seq[model.Table[R]] = collection.this.Seq.apply[model.Table[R]](Insert.this.table);
  <stable> <accessor> def affectedTables: Seq[model.Table[R]] = Insert.this.affectedTables;
  <synthetic> def copy[R >: Nothing <: model.KL](rec: R = rec, table: model.Table[R] = table): Transactions.this.Insert[R] = new Transactions.this.Insert[R](rec, table);
  <synthetic> def copy$default$2[R >: Nothing <: model.KL]: model.Table[R] @scala.annotation.unchecked.uncheckedVariance = Insert.this.table;
  <synthetic> def copy$default$1[R >: Nothing <: model.KL]: R @scala.annotation.unchecked.uncheckedVariance = Insert.this.rec;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(Insert.this);
  override def toString(): String = ScalaRunTime.this._toString(Insert.this);
  override def equals(x$1: Any): Boolean = Insert.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (rec: model.KL, table: model.Table[model.KL])Transactions.this.Insert[model.KL]((rec$1 @ _), (table$1 @ _)) if rec$1.==(rec).&&(table$1.==(table)) => x$1.asInstanceOf[Transactions.this.Insert[R]].canEqual(Insert.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "Insert";
  override def productArity: Int = 2;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => rec
    case 1 => table
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[Transactions.this.Insert[R]]()
}
Insert: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
         perform
   table     X  
     rec     X  

final object DependentListField extends java.lang.Object with ScalaObject {
  def this(): object intform.DependentListField = {
    DependentListField.super.this();
    ()
  };
  def apply[A >: Nothing <: Any](f: => Seq[intform.Field[A]], r: => scala.xml.NodeSeq): intform.DependentListField[A] = new intform.DependentListField[A]((() => f), (() => r))
}
DependentListField: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
           apply

case class Sell extends Action with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val asset: texttrading.StockAsset = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def asset: texttrading.StockAsset = Sell.this.asset;
  def this(asset: texttrading.StockAsset): texttrading.Sell = {
    Sell.super.this();
    ()
  };
  override def toString: java.lang.String = "Sold ".+(Sell.this.asset).+(".");
  <synthetic> def copy(asset: texttrading.StockAsset = asset): texttrading.Sell = new texttrading.this.Sell(asset);
  <synthetic> def copy$default$1: texttrading.StockAsset @scala.annotation.unchecked.uncheckedVariance = Sell.this.asset;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(Sell.this);
  override def equals(x$1: Any): Boolean = Sell.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (asset: texttrading.StockAsset)texttrading.Sell((asset$2 @ _)) if asset$2.==(asset) => x$1.asInstanceOf[texttrading.Sell].canEqual(Sell.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "Sell";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => asset
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[texttrading.Sell]()
}
Sell: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
   asset

abstract trait Refreshable extends java.lang.Object with intform.Renderable with ScalaObject {
  private <superaccessor> def super$render: scala.xml.NodeSeq;
  def /*Refreshable*/$init$(): Unit = {
    ()
  };
  private[this] val id: java.lang.String = java.util.UUID.randomUUID().toString();
  <stable> <accessor> def id: java.lang.String = Refreshable.this.id;
  absoverride def render: scala.xml.NodeSeq = {
    {
      var $md: scala.xml.MetaData = scala.xml.Null;
      $md = new scala.xml.UnprefixedAttribute("id", Refreshable.this.id, $md);
      new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
        $buf.&+(Refreshable.this.super$render);
        $buf
      }: _*))
    }
  };
  def refresh(): net.liftweb.http.js.JsCmd = new net.liftweb.http.js.JsCmds.SetHtml(Refreshable.this.id, Refreshable.this.render)
}
Refreshable: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
          render refresh
 super$r     X       X  

case class DerivativeOffer extends java.lang.Object with model.KL with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val id: model.package.Key = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def id: model.package.Key = DerivativeOffer.this.id;
  <caseaccessor> <paramaccessor> private[this] val derivative: model.Derivative = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def derivative: model.Derivative = DerivativeOffer.this.derivative;
  <caseaccessor> <paramaccessor> private[this] val from: model.Link[DerivativeSchema.this.Portfolio] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def from: model.Link[DerivativeSchema.this.Portfolio] = DerivativeOffer.this.from;
  <caseaccessor> <paramaccessor> private[this] val to: model.Link[DerivativeSchema.this.Portfolio] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def to: model.Link[DerivativeSchema.this.Portfolio] = DerivativeOffer.this.to;
  <caseaccessor> <paramaccessor> private[this] val price: model.Dollars = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def price: model.Dollars = DerivativeOffer.this.price;
  <caseaccessor> <paramaccessor> private[this] val expires: org.joda.time.DateTime = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def expires: org.joda.time.DateTime = DerivativeOffer.this.expires;
  def this(id: model.package.Key = model.this.`package`.nextID, derivative: model.Derivative, from: model.Link[DerivativeSchema.this.Portfolio], to: model.Link[DerivativeSchema.this.Portfolio], price: model.Dollars, expires: org.joda.time.DateTime): DerivativeSchema.this.DerivativeOffer = {
    DerivativeOffer.super.this();
    ()
  };
  <synthetic> def copy(id: model.package.Key = id, derivative: model.Derivative = derivative, from: model.Link[DerivativeSchema.this.Portfolio] = from, to: model.Link[DerivativeSchema.this.Portfolio] = to, price: model.Dollars = price, expires: org.joda.time.DateTime = expires): DerivativeSchema.this.DerivativeOffer = new DerivativeSchema.this.DerivativeOffer(id, derivative, from, to, price, expires);
  <synthetic> def copy$default$6: org.joda.time.DateTime @scala.annotation.unchecked.uncheckedVariance = DerivativeOffer.this.expires;
  <synthetic> def copy$default$5: model.Dollars @scala.annotation.unchecked.uncheckedVariance = DerivativeOffer.this.price;
  <synthetic> def copy$default$4: model.Link[DerivativeSchema.this.Portfolio] @scala.annotation.unchecked.uncheckedVariance = DerivativeOffer.this.to;
  <synthetic> def copy$default$3: model.Link[DerivativeSchema.this.Portfolio] @scala.annotation.unchecked.uncheckedVariance = DerivativeOffer.this.from;
  <synthetic> def copy$default$2: model.Derivative @scala.annotation.unchecked.uncheckedVariance = DerivativeOffer.this.derivative;
  <synthetic> def copy$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = DerivativeOffer.this.id;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(DerivativeOffer.this);
  override def toString(): String = ScalaRunTime.this._toString(DerivativeOffer.this);
  override def equals(x$1: Any): Boolean = DerivativeOffer.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (id: model.package.Key, derivative: model.Derivative, from: model.Link[DerivativeSchema.this.Portfolio], to: model.Link[DerivativeSchema.this.Portfolio], price: model.Dollars, expires: org.joda.time.DateTime)DerivativeSchema.this.DerivativeOffer((id$3 @ _), (derivative$2 @ _), (from$1 @ _), (to$1 @ _), (price$1 @ _), (expires$1 @ _)) if id$3.==(id).&&(derivative$2.==(derivative)).&&(from$1.==(from)).&&(to$1.==(to)).&&(price$1.==(price)).&&(expires$1.==(expires)) => x$1.asInstanceOf[DerivativeSchema.this.DerivativeOffer].canEqual(DerivativeOffer.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "DerivativeOffer";
  override def productArity: Int = 6;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => id
    case 1 => derivative
    case 2 => from
    case 3 => to
    case 4 => price
    case 5 => expires
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[DerivativeSchema.this.DerivativeOffer]()
}
DerivativeOffer: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
 derivat
      id
   price
      to
    from
 expires

case class NodePlus extends java.lang.Object with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val n: scala.xml.Node = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def n: scala.xml.Node = NodePlus.this.n;
  def this(n: scala.xml.Node): intform.package.NodePlus = {
    NodePlus.super.this();
    ()
  };
  def leafMap(f: scala.xml.Elem => scala.xml.Elem): scala.xml.Node = NodePlus.this.n match {
    case (e @ (_: scala.xml.Elem)) => f.apply(scala.xml.Elem.apply(e.prefix, e.label, e.attributes, e.scope, (package.this.nodeSeqPlus(e.child).leafMap(f): _*)))
    case (x @ _) => x
  };
  <synthetic> def copy(n: scala.xml.Node = n): intform.package.NodePlus = new package.this.NodePlus(n);
  <synthetic> def copy$default$1: scala.xml.Node @scala.annotation.unchecked.uncheckedVariance = NodePlus.this.n;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(NodePlus.this);
  override def toString(): String = ScalaRunTime.this._toString(NodePlus.this);
  override def equals(x$1: Any): Boolean = NodePlus.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (n: scala.xml.Node)intform.package.NodePlus((n$2 @ _)) if n$2.==(n) => x$1.asInstanceOf[intform.package.NodePlus].canEqual(NodePlus.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "NodePlus";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => n
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[intform.package.NodePlus]()
}
NodePlus: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
         leafMap
       n     X  

abstract trait CheckBoxRender extends java.lang.Object with intform.FieldRender with ScalaObject {
  def /*CheckBoxRender*/$init$(): Unit = {
    ()
  };
  <accessor> def state: Boolean;
  <accessor> def state_=(x$1: Boolean): Unit;
  def main: scala.xml.NodeSeq = net.liftweb.http.SHtml.checkbox(CheckBoxRender.this.state, ((x$3: Boolean) => CheckBoxRender.this.state_=(x$3)))
}
CheckBoxRender: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
            main
 state_$     X  
   state     X  

sealed abstract trait EditOp extends scala.AnyRef {
  def perform(): Unit;
  <stable> <accessor> def affectedTables: Seq[model.Table[_]]
}
EditOp: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
 affecte
 perform

final object TestServlet extends  {
  def this() = _;
  private <static> val serialVersionUID: Long = _;
  final object Response extends  {
    def this() = _
  };
  <static> class Response extends _root_.java.lang.Object {
    def this() = _;
    var cash: Double = _;
    var assets: List[ResponseAsset] = _
  };
  final object ResponseAsset extends  {
    def this() = _
  };
  <static> class ResponseAsset extends _root_.java.lang.Object {
    def this() = _;
    var ticker: String = _;
    var shares: Double = _;
    var price: Double = _;
    var dollars: Double = _
  }
}
TestServlet: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

case class LazyQuote extends java.lang.Object with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val id: Long = _;
  private <stable> <accessor> <paramaccessor> def id: Long = LazyQuote.this.id;
  def this(id: Long): BatchingStockDatabase.this.LazyQuote = {
    LazyQuote.super.this();
    ()
  };
  <synthetic> def copy(id: Long = id): BatchingStockDatabase.this.LazyQuote = new BatchingStockDatabase.this.LazyQuote(id);
  <synthetic> def copy$default$1: Long @scala.annotation.unchecked.uncheckedVariance = LazyQuote.this.id;
  <synthetic> <stable> <caseaccessor> def id$1: Long = LazyQuote.this.id;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(LazyQuote.this);
  override def toString(): String = ScalaRunTime.this._toString(LazyQuote.this);
  override def equals(x$1: Any): Boolean = LazyQuote.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (id: Long)BatchingStockDatabase.this.LazyQuote((id$1$1 @ _)) if id$1$1.==(id$1) => x$1.asInstanceOf[BatchingStockDatabase.this.LazyQuote].canEqual(LazyQuote.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "LazyQuote";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => id$1
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[BatchingStockDatabase.this.LazyQuote]()
}
LazyQuote: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
      id

final class $anon extends java.lang.Object with net.liftweb.actor.LiftActor {
  def this(): anonymous class $anon = {
    $anon.super.this();
    ()
  };
  def messageHandler: PartialFunction[Any,Unit] = ((x0$1: Any) => x0$1 match {
    case _ => TwitterFrontend.this.run()
  })
}
$anon: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
         message

case class DerivativeSellerVote extends java.lang.Object with model.KL with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val id: model.package.Key = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def id: model.package.Key = DerivativeSellerVote.this.id;
  <caseaccessor> <paramaccessor> private[this] val caster: model.Link[VotingSchema.this.Portfolio] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def caster: model.Link[VotingSchema.this.Portfolio] = DerivativeSellerVote.this.caster;
  <caseaccessor> <paramaccessor> private[this] val event: model.Link[VotingSchema.this.NewsEvent] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def event: model.Link[VotingSchema.this.NewsEvent] = DerivativeSellerVote.this.event;
  def this(id: model.package.Key = model.this.`package`.nextID, caster: model.Link[VotingSchema.this.Portfolio], event: model.Link[VotingSchema.this.NewsEvent]): VotingSchema.this.DerivativeSellerVote = {
    DerivativeSellerVote.super.this();
    ()
  };
  <synthetic> def copy(id: model.package.Key = id, caster: model.Link[VotingSchema.this.Portfolio] = caster, event: model.Link[VotingSchema.this.NewsEvent] = event): VotingSchema.this.DerivativeSellerVote = new VotingSchema.this.DerivativeSellerVote(id, caster, event);
  <synthetic> def copy$default$3: model.Link[VotingSchema.this.NewsEvent] @scala.annotation.unchecked.uncheckedVariance = DerivativeSellerVote.this.event;
  <synthetic> def copy$default$2: model.Link[VotingSchema.this.Portfolio] @scala.annotation.unchecked.uncheckedVariance = DerivativeSellerVote.this.caster;
  <synthetic> def copy$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = DerivativeSellerVote.this.id;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(DerivativeSellerVote.this);
  override def toString(): String = ScalaRunTime.this._toString(DerivativeSellerVote.this);
  override def equals(x$1: Any): Boolean = DerivativeSellerVote.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (id: model.package.Key, caster: model.Link[VotingSchema.this.Portfolio], event: model.Link[VotingSchema.this.NewsEvent])VotingSchema.this.DerivativeSellerVote((id$4 @ _), (caster$2 @ _), (event$2 @ _)) if id$4.==(id).&&(caster$2.==(caster)).&&(event$2.==(event)) => x$1.asInstanceOf[VotingSchema.this.DerivativeSellerVote].canEqual(DerivativeSellerVote.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "DerivativeSellerVote";
  override def productArity: Int = 3;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => id
    case 1 => caster
    case 2 => event
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[VotingSchema.this.DerivativeSellerVote]()
}
DerivativeSellerVote: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
   event
      id
  caster

case class ResponseError extends java.lang.Object with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val error: Throwable = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def error: Throwable = ResponseError.this.error;
  def this(error: Throwable): FailoverStockDatabase.this.ResponseError = {
    ResponseError.super.this();
    ()
  };
  <synthetic> def copy(error: Throwable = error): FailoverStockDatabase.this.ResponseError = new FailoverStockDatabase.this.ResponseError(error);
  <synthetic> def copy$default$1: Throwable @scala.annotation.unchecked.uncheckedVariance = ResponseError.this.error;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(ResponseError.this);
  override def toString(): String = ScalaRunTime.this._toString(ResponseError.this);
  override def equals(x$1: Any): Boolean = ResponseError.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (error: Throwable)FailoverStockDatabase.this.ResponseError((error$1 @ _)) if error$1.==(error) => x$1.asInstanceOf[FailoverStockDatabase.this.ResponseError].canEqual(ResponseError.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "ResponseError";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => error
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[FailoverStockDatabase.this.ResponseError]()
}
ResponseError: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
   error

class EventPage extends java.lang.Object with intform.Page with net.liftweb.common.Loggable with ScalaObject {
  def this(): code.snippet.EventPage = {
    EventPage.super.this();
    ()
  };
  def render: scala.xml.NodeSeq = EventPage.this.refreshable.render;
  private[this] val param: net.liftweb.common.Box[String] = net.liftweb.http.S.param("id");
  <stable> <accessor> def param: net.liftweb.common.Box[String] = EventPage.this.param;
  private[this] val refreshable: intform.Refreshable.NeedRenderable with intform.Refreshable = intform.Refreshable.apply(EventPage.this.doRender);
  <stable> <accessor> def refreshable: intform.Refreshable.NeedRenderable with intform.Refreshable = EventPage.this.refreshable;
  def doRender: scala.xml.NodeSeq = EventPage.this.param.map[scala.xml.NodeSeq]({
  ((id: String) => EventPage.this.eventPage(id))
}).openOr[scala.xml.NodeSeq]({
    {
      new scala.xml.Elem(null, "p", scala.xml.Null, scala.this.Predef.$scope, ({
        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
        $buf.&+(new scala.xml.Text("This event does not seem to exist"));
        $buf
      }: _*))
    }
  });
  def eventPage(id: String): scala.xml.NodeSeq = try {
    val ev: model.schema.NewsEvent = model.schema.NewsEvent.byID(id);
    {
      {
        var $md: scala.xml.MetaData = scala.xml.Null;
        $md = new scala.xml.UnprefixedAttribute("id", new scala.xml.Text("event"), $md);
        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("block"), $md);
        new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
          $buf.&+(new scala.xml.Text("\012            "));
          $buf.&+({
            {
              var $md: scala.xml.MetaData = scala.xml.Null;
              $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("event"), $md);
              new scala.xml.Elem(null, "h3", $md, scala.this.Predef.$scope, ({
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+({
                  {
                    var $md: scala.xml.MetaData = scala.xml.Null;
                    $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("eventDate"), $md);
                    new scala.xml.Elem(null, "span", $md, scala.this.Predef.$scope, ({
                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                      $buf.&+(formats.`package`.dateTimeFormatted(ev.when).toNearbyString);
                      $buf
                    }: _*))
                  }
                });
                $buf.&+(new scala.xml.Text(":\012                "));
                $buf.&+(comet.News.eventDescription(ev, false));
                $buf.&+(new scala.xml.Text("\012                "));
                $buf.&+(EventPage.this.voteTally(ev));
                $buf.&+(new scala.xml.Text("\012                "));
                $buf.&+(voteControls.apply(EventPage.this.refreshable, ev));
                $buf.&+(new scala.xml.Text("\012            "));
                $buf
              }: _*))
            }
          });
          $buf.&+(new scala.xml.Text("\012                \012            "));
          $buf.&+(commentPage.apply(ev));
          $buf.&+(new scala.xml.Text("\012        "));
          $buf
        }: _*))
      }
    }
  } catch {
    case (_: errors.package.BadUser) => {
      {
        new scala.xml.Elem(null, "p", scala.xml.Null, scala.this.Predef.$scope, ({
          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
          $buf.&+(new scala.xml.Text("This event seems to not exist"));
          $buf
        }: _*))
      }
    }
  };
  def voteTally(ev: model.schema.NewsEvent): scala.collection.immutable.Seq[scala.xml.Node] with Serializable = if (ev.isVotable)
    {
      {
        var $md: scala.xml.MetaData = scala.xml.Null;
        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("long-tally"), $md);
        new scala.xml.Elem(null, "span", $md, scala.this.Predef.$scope, ({
          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
          $buf.&+(ev.buyerTally);
          $buf.&+(new scala.xml.Text(" Up / "));
          $buf.&+(ev.sellerTally);
          $buf.&+(new scala.xml.Text(" Down"));
          $buf
        }: _*))
      }
    }
  else
    immutable.this.Nil
}
EventPage: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.250
         voteTal  render eventPa doRende

final object Stocks extends java.lang.Object with ScalaObject {
  def this(): object model.Stocks = {
    Stocks.super.this();
    ()
  };
  private[this] var syntheticDividends: List[stockdata.Dividend] = immutable.this.Nil;
  <accessor> def syntheticDividends: List[stockdata.Dividend] = Stocks.this.syntheticDividends;
  <accessor> def syntheticDividends_=(x$1: List[stockdata.Dividend]): Unit = Stocks.this.syntheticDividends = x$1;
  def stockPrice(ticker: String): model.Price = {
    val stock: stockdata.Stock = new stockdata.Stock(ticker);
    val quote: stockdata.Quote = StockPriceSource.getQuotes(collection.this.Seq.apply[stockdata.Stock](stock)).head;
    quote.price
  };
  def recentDividends(ticker: String): Seq[stockdata.Dividend] = {
    val actual: model.DividendSource.Result = DividendSource.recentDividends(new stockdata.Stock(ticker));
    actual.++[stockdata.Dividend, Seq[stockdata.Dividend]](Stocks.this.syntheticDividends.filter(((x$18: stockdata.Dividend) => x$18.ticker.==(ticker))))(collection.this.Seq.canBuildFrom[stockdata.Dividend])
  }
}
Stocks: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=1.000
         stockPr recentD
 synthet             X  

final object TextTrader extends java.lang.Object with ScalaObject {
  def this(): object texttrading.TextTrader = {
    TextTrader.super.this();
    ()
  };
  def runCommand(user: String, command: String, backend: texttrading.Backend): Seq[String] = {
    val parsed: texttrading.parser.ParseResult[Product with Serializable with texttrading.Action] = parser.parseAction(command);
    val huh: String = scala.this.Predef.augmentString(scala.this.Predef.augmentString("|I don\'t understand your command\012               |Try:\012               |%s\012               |").stripMargin).format(texttrading.this.`package`.commandIntro);
    parsed match {
      case (result: Product with Serializable with texttrading.Action, next: texttrading.parser.Input)texttrading.parser.Success[Product with Serializable with texttrading.Action]((action @ _), _) => {
        val request: texttrading.Request = new texttrading.Request(user, action);
        val response: texttrading.Response = backend.perform(request);
        response.extraMsgs.:+[String, Seq[String]](response.status match {
          case OK => action match {
            case (a @ (ticker: String)texttrading.SellAll(_)) => a.toString()
            case (a @ (asset: texttrading.StockAsset)texttrading.Sell(_)) => a.toString()
            case (a @ _) => "Successfuly ".+(a)
          }
          case (msg: String)texttrading.StringResponse((str @ _)) => str
          case (ticker: String, dollars: model.Dollars, shares: model.Shares)texttrading.TransactionResponse((ticker @ _), (dollars @ _), (shares @ _)) => scala.this.Predef.augmentString("Bought %s shares of %s for %s").format(shares.###(), ticker, dollars.$)
          case (msg: String)texttrading.Failed((msg @ _)) => msg
        })(collection.this.Seq.canBuildFrom[String])
      }
      case (msg: String, next: texttrading.parser.Input)texttrading.parser.Failure(_, _) => collection.this.Seq.apply[String](huh)
      case (msg: String, next: texttrading.parser.Input)texttrading.parser.Error(_, _) => collection.this.Seq.apply[String](huh)
    }
  };
  def looksLikeCommand(text: String): Boolean = {
    parser.parseAction(text) match {
      case (result: Product with Serializable with texttrading.Action, next: texttrading.parser.Input)texttrading.parser.Success[Product with Serializable with texttrading.Action](_, _) => true
      case _ => false
    }
  }
}
TextTrader: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.750
         looksLi runComm

class RefreshHack extends java.lang.Object with intform.Page with net.liftweb.common.Loggable with ScalaObject {
  def this(): code.snippet.RefreshHack = {
    RefreshHack.super.this();
    ()
  };
  def render: scala.xml.NodeSeq = {
    model.schema.tables.foreach[Unit](((x$1: model.Table[_]) => x$1.!(model.Refresh)));
    (xml.this.NodeSeq.seqToNodeSeq(immutable.this.Nil): scala.xml.NodeSeq)
  }
}
RefreshHack: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
          render

final object LoginStatus extends java.lang.Object with net.liftweb.common.Loggable with ScalaObject {
  def this(): object code.snippet.LoginStatus = {
    LoginStatus.super.this();
    ()
  };
  def ifLoggedIn(in: scala.xml.NodeSeq): scala.xml.NodeSeq = if (code.control.LoginManager.loggedIn_?)
    in
  else
    xml.this.NodeSeq.seqToNodeSeq(immutable.this.Nil);
  def ifLoggedOut(in: scala.xml.NodeSeq): scala.xml.NodeSeq = if (code.control.LoginManager.loggedIn_$qmark.unary_!)
    in
  else
    xml.this.NodeSeq.seqToNodeSeq(immutable.this.Nil);
  def username(in: scala.xml.NodeSeq): scala.xml.NodeSeq = {
    val name: String = code.control.LoginManager.currentLogin match {
      case (x: String)Some[String]((n @ _)) => n
      case _ => "Nobody"
    };
    {
      {
        var $md: scala.xml.MetaData = scala.xml.Null;
        $md = new scala.xml.UnprefixedAttribute("href", "/user?name=".+(name), $md);
        new scala.xml.Elem(null, "a", $md, scala.this.Predef.$scope, ({
          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
          $buf.&+(name);
          $buf
        }: _*))
      }
    }
  }
}
LoginStatus: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=1.000
         ifLogge ifLogge usernam

final object package extends java.lang.Object with net.liftweb.common.Loggable with ScalaObject {
  def this(): object jsapi.package = {
    package.super.this();
    ()
  };
  lazy private[this] var jsFuncDefs: scala.xml.NodeSeq = _;
  <stable> <accessor> lazy def jsFuncDefs: scala.xml.NodeSeq = {
    package.this.jsFuncDefs = {
      {
        new scala.xml.Elem(null, "head", scala.xml.Null, scala.this.Predef.$scope, ({
          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
          $buf.&+(new scala.xml.Text("\012        "));
          $buf.&+({
            {
              var $md: scala.xml.MetaData = scala.xml.Null;
              $md = new scala.xml.UnprefixedAttribute("type", new scala.xml.Text("text/javascript"), $md);
              new scala.xml.Elem(null, "script", $md, scala.this.Predef.$scope, ({
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+(new scala.xml.Text("\012            "));
                $buf.&+(package.this.setup);
                $buf.&+(new scala.xml.Text("\012        "));
                $buf
              }: _*))
            }
          });
          $buf.&+(new scala.xml.Text("\012    "));
          $buf
        }: _*))
      }
    };
    package.this.jsFuncDefs
  };
  lazy private[this] var api: scala.collection.immutable.Map[java.lang.String,java.lang.String] = _;
  <stable> <accessor> lazy def api: scala.collection.immutable.Map[java.lang.String,java.lang.String] = {
    package.this.api = scala.this.Predef.Map.apply[java.lang.String, java.lang.String](scala.this.Predef.any2ArrowAssoc[java.lang.String]("buyDollars").->[java.lang.String](package.this.func("ticker", "dollars")(((result: Map[String,String]) => {
      val ticker: String = result.apply("ticker");
      val dollars: model.Dollars = model.Dollars.apply(result.apply("dollars"));
      package.this.me.userBuyStock(ticker, dollars);
      net.liftweb.http.js.JsCmds.Noop
    }))), scala.this.Predef.any2ArrowAssoc[java.lang.String]("buyShares").->[java.lang.String](package.this.func("ticker", "shares")(((result: Map[String,String]) => {
      val ticker: String = result.apply("ticker");
      val shares: model.Shares = model.Shares.apply(result.apply("shares"));
      package.this.me.userBuyStock(ticker, shares);
      net.liftweb.http.js.JsCmds.Noop
    }))), scala.this.Predef.any2ArrowAssoc[java.lang.String]("sellDollars").->[java.lang.String](package.this.func("ticker", "dollars")(((result: Map[String,String]) => {
      val ticker: String = result.apply("ticker");
      val dollars: model.Dollars = model.Dollars.apply(result.apply("dollars"));
      package.this.me.userSellStock(ticker, dollars);
      net.liftweb.http.js.JsCmds.Noop
    }))), scala.this.Predef.any2ArrowAssoc[java.lang.String]("sellShares").->[java.lang.String](package.this.func("ticker", "shares")(((result: Map[String,String]) => {
      val ticker: String = result.apply("ticker");
      val shares: model.Shares = model.Shares.apply(result.apply("shares"));
      package.this.me.userSellStock(ticker, shares);
      net.liftweb.http.js.JsCmds.Noop
    }))), scala.this.Predef.any2ArrowAssoc[java.lang.String]("sellAll").->[java.lang.String](package.this.func("ticker")(((result: Map[String,String]) => {
      val ticker: String = result.apply("ticker");
      package.this.me.userSellAll(ticker);
      net.liftweb.http.js.JsCmds.Noop
    }))), scala.this.Predef.any2ArrowAssoc[java.lang.String]("stockPrice").->[java.lang.String](package.this.func("ticker")(((result: Map[String,String]) => {
      val ticker: String = result.apply("ticker");
      js.this.JsCmds.jsExpToJsCmd(net.liftweb.http.js.JE.Num.apply(model.Stocks.stockPrice(ticker).price.doubleValue()))
    }))), scala.this.Predef.any2ArrowAssoc[java.lang.String]("howManySharesDoIOwn").->[java.lang.String](package.this.func("ticker")(((result: Map[String,String]) => {
      val ticker: String = result.apply("ticker");
      js.this.JsCmds.jsExpToJsCmd(new net.liftweb.http.js.JE.Num(package.this.me.howManyShares(ticker).shares))
    }))), scala.this.Predef.any2ArrowAssoc[java.lang.String]("howManyDollarsDoIOwn").->[java.lang.String](package.this.func("ticker")(((result: Map[String,String]) => {
      val ticker: String = result.apply("ticker");
      js.this.JsCmds.jsExpToJsCmd(new net.liftweb.http.js.JE.Num(package.this.me.howManyDollars(ticker).dollars))
    }))), scala.this.Predef.any2ArrowAssoc[java.lang.String]("news").->[java.lang.String](package.this.func()(((result: Map[String,String]) => js.this.JsCmds.jsExpToJsCmd(net.liftweb.http.js.JE.JsArray.apply(model.schema.recentEvents(10).flatMap[net.liftweb.http.js.JsObj, List[net.liftweb.http.js.JsObj]](((ev: model.schema.NewsEvent) => ev.action match {
      case (buyer: model.schema.P, stock: String, shares: model.Shares, dollars: model.Dollars, price: model.Price)model.schema.Bought((buyer @ _), (stock @ _), (shares @ _), (dollars @ _), (price @ _)) => scala.this.Option.option2Iterable[net.liftweb.http.js.JsObj](new Some[net.liftweb.http.js.JsObj](net.liftweb.http.js.JE.JsObj.apply(scala.this.Predef.any2ArrowAssoc[java.lang.String]("action").->[net.liftweb.http.js.JE.Str](js.this.JsExp.strToJsExp("bought")), scala.this.Predef.any2ArrowAssoc[java.lang.String]("trader").->[net.liftweb.http.js.JE.Str](js.this.JsExp.strToJsExp(buyer.name)), scala.this.Predef.any2ArrowAssoc[java.lang.String]("ticker").->[net.liftweb.http.js.JE.Str](js.this.JsExp.strToJsExp(stock)), scala.this.Predef.any2ArrowAssoc[java.lang.String]("shares").->[net.liftweb.http.js.JE.Num](js.this.JsExp.doubleToJsExp(shares.double)), scala.this.Predef.any2ArrowAssoc[java.lang.String]("dollars").->[net.liftweb.http.js.JE.Num](js.this.JsExp.doubleToJsExp(dollars.double)), scala.this.Predef.any2ArrowAssoc[java.lang.String]("price").->[net.liftweb.http.js.JE.Num](js.this.JsExp.doubleToJsExp(price.double)))))
      case (seller: model.schema.P, stock: String, shares: model.Shares, dollars: model.Dollars, price: model.Price)model.schema.Sold((seller @ _), (stock @ _), (shares @ _), (dollars @ _), (price @ _)) => scala.this.Option.option2Iterable[net.liftweb.http.js.JsObj](new Some[net.liftweb.http.js.JsObj](net.liftweb.http.js.JE.JsObj.apply(scala.this.Predef.any2ArrowAssoc[java.lang.String]("action").->[net.liftweb.http.js.JE.Str](js.this.JsExp.strToJsExp("sold")), scala.this.Predef.any2ArrowAssoc[java.lang.String]("trader").->[net.liftweb.http.js.JE.Str](js.this.JsExp.strToJsExp(seller.name)), scala.this.Predef.any2ArrowAssoc[java.lang.String]("ticker").->[net.liftweb.http.js.JE.Str](js.this.JsExp.strToJsExp(stock)), scala.this.Predef.any2ArrowAssoc[java.lang.String]("shares").->[net.liftweb.http.js.JE.Num](js.this.JsExp.doubleToJsExp(shares.double)), scala.this.Predef.any2ArrowAssoc[java.lang.String]("dollars").->[net.liftweb.http.js.JE.Num](js.this.JsExp.doubleToJsExp(dollars.double)), scala.this.Predef.any2ArrowAssoc[java.lang.String]("price").->[net.liftweb.http.js.JE.Num](js.this.JsExp.doubleToJsExp(price.double)))))
      case (from: model.schema.P, to: model.schema.P, derivative: model.Derivative, price: model.Dollars)model.schema.Offered((from @ _), (to @ _), (derivative @ _), (price @ _)) => scala.this.Option.option2Iterable[Nothing](scala.None)
      case (from: model.schema.P, to: model.schema.P, derivative: model.Derivative, price: model.Dollars, buyerAside: model.Link[model.schema.DerivativeBuyerSetAside], sellerAside: model.Link[model.schema.DerivativeSellerSetAside])model.schema.Accepted((from @ _), (to @ _), (derivative @ _), (price @ _), _, _) => scala.this.Option.option2Iterable[Nothing](scala.None)
      case (from: model.schema.P, to: model.schema.P, derivative: model.Derivative, price: model.Dollars)model.schema.Declined((from @ _), (to @ _), (derivative @ _), (price @ _)) => scala.this.Option.option2Iterable[Nothing](scala.None)
      case (from: model.schema.P, derivative: model.Derivative, price: model.Dollars)model.schema.Auctioned((from @ _), (derivative @ _), (price @ _)) => scala.this.Option.option2Iterable[Nothing](scala.None)
      case (from: model.schema.P, on: model.schema.AuctionOffer, price: model.Dollars)model.schema.Bid((from @ _), (on @ _), (price @ _)) => scala.this.Option.option2Iterable[Nothing](scala.None)
      case (offerer: model.schema.P, offer: model.schema.AuctionOffer)model.schema.Closed((port @ _), (offer @ _)) => scala.this.Option.option2Iterable[Nothing](scala.None)
      case (user: model.schema.P, derivative: model.Derivative)model.schema.Exercised((port @ _), (derivative @ _)) => scala.this.Option.option2Iterable[Nothing](scala.None)
    }))(immutable.this.List.canBuildFrom[net.liftweb.http.js.JsObj])))))));
    package.this.api
  };
  def me: model.schema.Portfolio = code.control.PortfolioSwitcher.currentPortfolio;
  lazy private[this] var setup: java.lang.String = _;
  <stable> <accessor> lazy def setup: java.lang.String = {
    package.this.setup = "$(function () {\012".+(package.this.api.map[java.lang.String, scala.collection.immutable.Iterable[java.lang.String]](((x0$1: (java.lang.String, java.lang.String)) => x0$1 match {
  case (_1: java.lang.String, _2: java.lang.String)(java.lang.String, java.lang.String)((name @ _), (value @ _)) => "    self.".+(name).+(" = ").+(value)
}))(immutable.this.Iterable.canBuildFrom[java.lang.String]).mkString(";\012")).+(package.this.otherLibs).+("\012} )");
    package.this.setup
  };
  lazy private[this] var otherLibs: String = _;
  <stable> <accessor> lazy def otherLibs: String = {
    package.this.otherLibs = scala.this.Predef.augmentString("|\012        | self.runAutoTrade = (function(key) {\012        |    var code = $(\"#code-\"+key).val()\012        |    var outplace = $(\"#output-\"+key)\012        |    outplace.text(\"\")\012        |    fullCode = \"key = \'\"+key+\"\'; output = $(\'#pane-\'+key); {\\n\" + code + \"\\n}\"\012        |    try {\012        |        eval(fullCode)\012        |    }\012        |    catch (e) {\012        |        outplace.text(outplace.text() + e + \"\\n\")\012        |    }\012        | })\012        |\012        |").stripMargin;
    package.this.otherLibs
  };
  def func(args: String*)(callback: Map[String,String] => net.liftweb.http.js.JsCmd): java.lang.String = {
    def opFunc(arg: Any): net.liftweb.http.js.JsCmd = {
      package.this.logger.info("Got AutoTrade ".+(arg.asInstanceOf[AnyRef].toString()));
      try {
        callback.apply(arg.asInstanceOf[Map[String,String]])
      } catch {
        case (_: ClassCastException) => {
          package.this.logger.error("Got bad data from Ajaxy stuff ".+(arg));
          net.liftweb.http.js.JsCmds.Noop
        }
      }
    };
    val catchList: String = args.map[java.lang.String, Seq[java.lang.String]](((name: String) => "\'".+(name).+("\':").+(name).+("+\'\'")))(collection.this.Seq.canBuildFrom[java.lang.String]).mkString(",");
    val argList: String = args.:+[String, Seq[String]]("callback")(collection.this.Seq.canBuildFrom[String]).mkString(", ");
    <synthetic> private[this] val x$1: (String, net.liftweb.http.js.JsExp) = (net.liftweb.http.SHtml.jsonCall(new net.liftweb.http.js.JE.JsRaw("{".+(catchList).+("}")), {
      ((arg: Any) => opFunc(arg))
    }): (String, net.liftweb.http.js.JsExp) @unchecked) match {
      case (_1: String, _2: net.liftweb.http.js.JsExp)(String, net.liftweb.http.js.JsExp)((id @ _), (stuff @ _)) => new (String, net.liftweb.http.js.JsExp)(id, stuff)
    };
    val id: String = x$1._1;
    val stuff: net.liftweb.http.js.JsExp = x$1._2;
    val js: java.lang.String = "liftAjax.lift_ajaxHandler(\'".+(id).+("=\' + encodeURIComponent(JSON.stringify({").+(catchList).+("})), ").+("function(x) callback(eval(x)), null, null)");
    "(function(".+(argList).+(") { ").+(js).+("});")
  }
}
package: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.500
              me    func
 jsFuncD                
   setup                
 otherLi                
     api                

abstract trait TextAreaRender extends java.lang.Object with intform.FieldRender with ScalaObject {
  def /*TextAreaRender*/$init$(): Unit = {
    ()
  };
  <stable> <accessor> def initText: String;
  <accessor> def text: String;
  <accessor> def text_=(x$1: String): Unit;
  def main: scala.xml.NodeSeq = net.liftweb.http.SHtml.onSubmit(((x$4: String) => TextAreaRender.this.text_=(x$4))).apply({
    {
      new scala.xml.Elem(null, "textarea", scala.xml.Null, scala.this.Predef.$scope, ({
        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
        $buf.&+(TextAreaRender.this.text);
        $buf
      }: _*))
    }
  })
}
TextAreaRender: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
            main
    text     X  
 initTex        
 text_$e     X  

abstract trait Reply extends java.lang.Object with ScalaObject {
  def /*Reply*/$init$(): Unit = {
    ()
  };
  def reply(text: String): Unit;
  def apply(text: String): Unit = Reply.this.reply(text)
}
Reply: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
           apply
   reply     X  

final object Logout extends java.lang.Object with ScalaObject {
  def this(): object code.control.Logout = {
    Logout.super.this();
    ()
  };
  def dispatchPF: net.liftweb.http.LiftRules.DispatchPF = net.liftweb.util.NamedPF.apply[net.liftweb.http.Req, () => net.liftweb.common.Box[net.liftweb.http.LiftResponse]]("Twitter login callback")(((x0$1: net.liftweb.http.Req) => x0$1 match {
    case (req @ net.liftweb.http.Req.unapply(<unapply-selector>) <unapply> ((hd: String, tl: List[String])collection.immutable.::[String]("logout", immutable.this.Nil), "", _)) => {
      (() => Logout.this.userLogout(req)())
    }
  }));
  def userLogout(req: net.liftweb.http.Req)(): net.liftweb.common.Box[net.liftweb.http.LiftResponse] = {
    LoginManager.logout();
    new net.liftweb.common.Full[net.liftweb.http.RedirectResponse](net.liftweb.http.RedirectResponse.apply(net.liftweb.http.S.referer.openOr[String]("/")))
  }
}
Logout: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.500
         userLog dispatc

final class $anon extends intform.TextField[model.ComparableSecurity] {
  def this(): anonymous class $anon = {
    $anon.super.this("");
    ()
  };
  def produce(): intform.OK[model.ComparableSecurity] = new intform.OK[model.ComparableSecurity](try {
    new model.CompSecDollar(model.Price.apply($anon.this.text))
  } catch {
    case (_: NumberFormatException) => new model.CompSecStock($anon.this.text)
  })
}
$anon: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
         produce

final class $anon extends DollarsField with intform.FieldErrorRender {
  def this(): anonymous class $anon = {
    $anon.super.this("");
    ()
  }
}
$anon: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

final object LazyQuote extends java.lang.Object with ScalaObject with Serializable {
  def this(): object BatchingStockDatabase.this.LazyQuote = {
    LazyQuote.super.this();
    ()
  };
  implicit def forceLazyQuote(lazyQuote: BatchingStockDatabase.this.LazyQuote): stockdata.Quote = BatchingStockDatabase.this.storedQuotes.get(lazyQuote.id) match {
    case (x: stockdata.Quote)Some[stockdata.Quote]((quote @ _)) => quote
    case scala.None => BatchingStockDatabase.this.fetchPendingStock(lazyQuote.id)
  };
  case <synthetic> def unapply(x$0: BatchingStockDatabase.this.LazyQuote): Option[Long] = if (x$0.==(null))
    scala.this.None
  else
    new Some[Long](x$0.id);
  case <synthetic> def apply(id: Long): BatchingStockDatabase.this.LazyQuote = new BatchingStockDatabase.this.LazyQuote(id)
}
LazyQuote: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
         forceLa

case class NewsEvent extends java.lang.Object with model.KL with NewsSchema.this.NewsEventWithComments with NewsSchema.this.NewsEventWithVotes with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val id: model.package.Key = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def id: model.package.Key = NewsEvent.this.id;
  <caseaccessor> <paramaccessor> private[this] val when: org.joda.time.DateTime = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def when: org.joda.time.DateTime = NewsEvent.this.when;
  <caseaccessor> <paramaccessor> private[this] val action: NewsSchema.this.Action = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def action: NewsSchema.this.Action = NewsEvent.this.action;
  def this(id: model.package.Key = model.this.`package`.nextID, when: org.joda.time.DateTime, action: NewsSchema.this.Action): NewsSchema.this.NewsEvent = {
    NewsEvent.super.this();
    ()
  };
  <synthetic> def copy(id: model.package.Key = id, when: org.joda.time.DateTime = when, action: NewsSchema.this.Action = action): NewsSchema.this.NewsEvent = new NewsSchema.this.NewsEvent(id, when, action);
  <synthetic> def copy$default$3: NewsSchema.this.Action @scala.annotation.unchecked.uncheckedVariance = NewsEvent.this.action;
  <synthetic> def copy$default$2: org.joda.time.DateTime @scala.annotation.unchecked.uncheckedVariance = NewsEvent.this.when;
  <synthetic> def copy$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = NewsEvent.this.id;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(NewsEvent.this);
  override def toString(): String = ScalaRunTime.this._toString(NewsEvent.this);
  override def equals(x$1: Any): Boolean = NewsEvent.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (id: model.package.Key, when: org.joda.time.DateTime, action: NewsSchema.this.Action)NewsSchema.this.NewsEvent((id$1 @ _), (when$1 @ _), (action$1 @ _)) if id$1.==(id).&&(when$1.==(when)).&&(action$1.==(action)) => x$1.asInstanceOf[NewsSchema.this.NewsEvent].canEqual(NewsEvent.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "NewsEvent";
  override def productArity: Int = 3;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => id
    case 1 => when
    case 2 => action
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[NewsSchema.this.NewsEvent]()
}
NewsEvent: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
    when
      id
  action

class ConsoleFrontend extends java.lang.Object with texttrading.Frontend with ScalaObject {
  <paramaccessor> private[this] val username: String = _;
  def this(username: String): texttrading.ConsoleFrontend = {
    ConsoleFrontend.super.this();
    ()
  };
  def messages: Iterator[texttrading.Message] = scala.io.Source.stdin.getLines().map[texttrading.Message](((line: String) => new texttrading.Message(ConsoleFrontend.this.username, line, ConsoleFrontend.this.reply)));
  private[this] val reply: java.lang.Object with texttrading.Reply = {
    final class $anon extends java.lang.Object with texttrading.Reply {
      def this(): anonymous class $anon = {
        $anon.super.this();
        ()
      };
      def reply(text: String): Unit = scala.this.Predef.println(text)
    };
    new $anon()
  };
  <stable> <accessor> def reply: java.lang.Object with texttrading.Reply = ConsoleFrontend.this.reply
}
ConsoleFrontend: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
         message
 usernam     X  

final private object redirectBackTo extends net.liftweb.http.SessionVar[String] with ScalaObject {
  def this(): object code.control.OpenIDLogin.redirectBackTo = {
    redirectBackTo.super.this("/");
    ()
  }
}
redirectBackTo: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

final object NumberField extends java.lang.Object with ScalaObject {
  def this(): object intform.NumberField = {
    NumberField.super.this();
    ()
  };
  def apply(i: String = ""): intform.NumberField = new NumberField(i);
  <synthetic> def apply$default$1: String @scala.annotation.unchecked.uncheckedVariance = ""
}
NumberField: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
           apply

final class $anon extends PortfolioField with intform.FieldErrorRender {
  def this(): anonymous class $anon = {
    $anon.super.this("");
    ()
  }
}
$anon: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

final class $anon extends DollarsField with intform.FieldErrorRender {
  def this(): anonymous class $anon = {
    $anon.super.this("1000");
    ()
  }
}
$anon: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

case class ResponseValid extends java.lang.Object with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val quotes: Iterable[stockdata.Quote] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def quotes: Iterable[stockdata.Quote] = ResponseValid.this.quotes;
  def this(quotes: Iterable[stockdata.Quote]): FailoverStockDatabase.this.ResponseValid = {
    ResponseValid.super.this();
    ()
  };
  <synthetic> def copy(quotes: Iterable[stockdata.Quote] = quotes): FailoverStockDatabase.this.ResponseValid = new FailoverStockDatabase.this.ResponseValid(quotes);
  <synthetic> def copy$default$1: Iterable[stockdata.Quote] @scala.annotation.unchecked.uncheckedVariance = ResponseValid.this.quotes;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(ResponseValid.this);
  override def toString(): String = ScalaRunTime.this._toString(ResponseValid.this);
  override def equals(x$1: Any): Boolean = ResponseValid.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (quotes: Iterable[stockdata.Quote])FailoverStockDatabase.this.ResponseValid((quotes$1 @ _)) if quotes$1.==(quotes) => x$1.asInstanceOf[FailoverStockDatabase.this.ResponseValid].canEqual(ResponseValid.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "ResponseValid";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => quotes
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[FailoverStockDatabase.this.ResponseValid]()
}
ResponseValid: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
  quotes

abstract trait PortfolioWithStocks extends java.lang.Object with ScalaObject { self: StockSchema.this.Portfolio => 
  def /*PortfolioWithStocks*/$init$(): Unit = {
    ()
  };
  def myStockAssets: List[StockSchema.this.StockAsset] = StockSchema.this.stockAssets.filter(((x$1: StockSchema.this.StockAsset) => x$1.owner.~~(PortfolioWithStocks.this))).toList;
  def myStockAssetsGrouped: Seq[StockSchema.this.GroupedStockAsset] = PortfolioWithStocks.this.myStockAssets.groupBy[String](((x$2: StockSchema.this.StockAsset) => x$2.ticker)).map[StockSchema.this.GroupedStockAsset, scala.collection.immutable.Iterable[StockSchema.this.GroupedStockAsset]](((x0$1: (String, List[StockSchema.this.StockAsset])) => x0$1 match {
  case (_1: String, _2: List[StockSchema.this.StockAsset])(String, List[StockSchema.this.StockAsset])((ticker @ _), (assets @ _)) => new StockSchema.this.GroupedStockAsset(ticker, new model.Shares(assets.map[scala.math.BigDecimal, List[scala.math.BigDecimal]](((x$3: StockSchema.this.StockAsset) => x$3.shares.shares))(immutable.this.List.canBuildFrom[scala.math.BigDecimal]).sum[scala.math.BigDecimal](math.this.Numeric.BigDecimalIsFractional)), model.this.KL.toLink[StockSchema.this.Portfolio](this), {
    val dollars: List[model.Dollars] = assets.map[model.Dollars, List[model.Dollars]](((a: StockSchema.this.StockAsset) => a.shares.*(a.purchasePrice)))(immutable.this.List.canBuildFrom[model.Dollars]);
    val shares: List[model.Shares] = assets.map[model.Shares, List[model.Shares]](((x$4: StockSchema.this.StockAsset) => x$4.shares))(immutable.this.List.canBuildFrom[model.Shares]);
    dollars.reduceLeft[model.Dollars](((x$5: model.Dollars, x$6: model.Dollars) => x$5.+(x$6)))./(shares.reduceLeft[model.Shares](((x$7: model.Shares, x$8: model.Shares) => x$7.+(x$8))))
  })
}))(immutable.this.Iterable.canBuildFrom[StockSchema.this.GroupedStockAsset]).toList;
  def getMyStockAssets: java.util.List[StockSchema.this.StockAsset] = StockSchema.this.readDB[java.util.List[StockSchema.this.StockAsset]](scala.collection.JavaConversions.seqAsJavaList[StockSchema.this.StockAsset](PortfolioWithStocks.this.myStockAssets));
  def howManyShares(ticker: String): model.Shares = StockSchema.this.readDB[model.Shares]({
    val s: scala.math.BigDecimal = PortfolioWithStocks.this.myStockAssets.filter(((x$9: StockSchema.this.StockAsset) => x$9.ticker.==(ticker))).map[scala.math.BigDecimal, List[scala.math.BigDecimal]](((x$10: StockSchema.this.StockAsset) => x$10.shares.shares))(immutable.this.List.canBuildFrom[scala.math.BigDecimal]).sum[scala.math.BigDecimal](math.this.Numeric.BigDecimalIsFractional);
    new model.Shares(s)
  });
  def howManyDollars(ticker: String): model.Dollars = PortfolioWithStocks.this.howManyShares(ticker).*(Stocks.stockPrice(ticker));
  def userBuyStock(ticker: String, shares: model.Shares): StockSchema.this.StockPurchase = StockSchema.this.editDB[StockSchema.this.StockPurchase](PortfolioWithStocks.this.buyStock(ticker, shares));
  def userBuyStock(ticker: String, dollars: model.Dollars): StockSchema.this.StockPurchase = StockSchema.this.editDB[StockSchema.this.StockPurchase](PortfolioWithStocks.this.buyStock(ticker, dollars));
  def userSellStock(ticker: String, shares: model.Shares): Unit = StockSchema.this.editDB[Unit](PortfolioWithStocks.this.sellStock(ticker, shares));
  def userSellStock(ticker: String, dollars: model.Dollars): Unit = StockSchema.this.editDB[Unit](PortfolioWithStocks.this.sellStock(ticker, dollars));
  def userSellAll(ticker: String): Unit = StockSchema.this.editDB[Unit](PortfolioWithStocks.this.sellAll(ticker));
  private[model] def buyStock(ticker: String, shares: model.Shares): StockSchema.this.Transaction[StockSchema.this.StockPurchase] = {
    val price: model.Price = Stocks.stockPrice(ticker);
    PortfolioWithStocks.this.buyStock(ticker, price.*(shares), shares, price)
  };
  private[model] def buyStock(ticker: String, dollars: model.Dollars): StockSchema.this.Transaction[StockSchema.this.StockPurchase] = {
    val price: model.Price = Stocks.stockPrice(ticker);
    PortfolioWithStocks.this.buyStock(ticker, dollars, dollars./-/(price), price)
  };
  private[model] def buyStock(ticker: String, dollars: model.Dollars, shares: model.Shares, price: model.Price): StockSchema.this.Transaction[StockSchema.this.StockPurchase] = {
    if (PortfolioWithStocks.this.cash.<=(dollars))
      throw new StockSchema.this.NotEnoughCash(PortfolioWithStocks.this.cash, dollars)
    else
      ();
    StockSchema.this.toOps[StockSchema.this.StockAsset]({
  val x$19: String = ticker;
  val x$20: model.Shares = shares;
  val x$21: model.Link[StockSchema.this.Portfolio] = model.this.KL.toLink[StockSchema.this.Portfolio](this);
  val x$22: model.Price = price;
  val x$23: model.Price = price;
  val x$24: org.joda.time.DateTime = new org.joda.time.DateTime();
  val x$25: org.joda.time.DateTime = new org.joda.time.DateTime();
  val x$26: model.Dollars = new model.Dollars(math.this.BigDecimal.int2bigDecimal(0));
  val x$27: model.package.Key = StockSchema.this.StockAsset.apply$default$1;
  new StockSchema.this.StockAsset(x$27, x$19, x$20, x$21, x$22, x$23, x$24, x$25, x$26)
}).insert(StockSchema.this.stockAssets).flatMap[StockSchema.this.StockPurchase](((asset: StockSchema.this.StockAsset) => StockSchema.this.toOps[StockSchema.this.Portfolio](this).update(((t: StockSchema.this.Portfolio) => {
  val x$28: model.Dollars = t.cash.-(dollars);
  val x$29: model.package.Key = t.copy$default$1;
  val x$30: model.Link[StockSchema.this.League] = t.copy$default$2;
  val x$31: String = t.copy$default$3;
  val x$32: model.Dollars = t.copy$default$5;
  val x$33: Int = t.copy$default$6;
  t.copy(x$29, x$30, x$31, x$28, x$32, x$33)
}))(StockSchema.this.portfolios).flatMap[StockSchema.this.StockPurchase](((_: Unit) => new StockSchema.this.Bought(this, ticker, shares, dollars, price).report().map[StockSchema.this.StockPurchase](((_: StockSchema.this.NewsEvent) => new StockSchema.this.StockPurchase(shares, dollars, asset.id)))))))
  };
  private[model] def sellStock(ticker: String, shares: model.Shares): StockSchema.this.Transaction[Unit] = {
    val price: model.Price = Stocks.stockPrice(ticker);
    PortfolioWithStocks.this.sellStock(ticker, shares.*(price), shares, price)
  };
  private[model] def sellStock(ticker: String, dollars: model.Dollars): StockSchema.this.Transaction[Unit] = {
    val price: model.Price = Stocks.stockPrice(ticker);
    PortfolioWithStocks.this.sellStock(ticker, dollars, dollars./-/(price), price)
  };
  private[model] def sellStock(ticker: String, dollars: model.Dollars, shares: model.Shares, price: model.Price): StockSchema.this.Transaction[Unit] = {
    val allAssets: List[StockSchema.this.StockAsset] = PortfolioWithStocks.this.myStockAssets.filter(((x$11: StockSchema.this.StockAsset) => x$11.ticker.==(ticker))).sortBy[scala.math.BigDecimal](((x$12: StockSchema.this.StockAsset) => x$12.shares.shares))(math.this.Ordering.BigDecimal);
    def processAssets(soFar: model.Shares, assets: List[StockSchema.this.StockAsset]): StockSchema.this.Transaction[Unit] = assets match {
      case immutable.this.Nil => if (allAssets.isEmpty)
        throw new StockSchema.this.DontOwnStock(ticker)
      else
        throw new StockSchema.this.NotEnoughShares(soFar, shares)
      case (hd: StockSchema.this.StockAsset, tl: List[StockSchema.this.StockAsset])collection.immutable.::[StockSchema.this.StockAsset]((asset @ _), (restAssets @ _)) => if (asset.shares.+(soFar).==(shares))
        StockSchema.this.toOps[StockSchema.this.StockAsset](asset).delete(StockSchema.this.stockAssets).map[Unit](((x$13: StockSchema.this.StockAsset) => ()))
      else
        if (asset.shares.+(soFar).>=(shares))
          {
            val remaining: model.Shares = shares.-(soFar);
            StockSchema.this.toOps[StockSchema.this.StockAsset](asset).update(((a: StockSchema.this.StockAsset) => {
              val x$34: model.Shares = a.shares.-(remaining);
              val x$35: model.package.Key = a.copy$default$1;
              val x$36: String = a.copy$default$2;
              val x$37: model.Link[StockSchema.this.Portfolio] = a.copy$default$4;
              val x$38: model.Price = a.copy$default$5;
              val x$39: model.Price = a.copy$default$6;
              val x$40: org.joda.time.DateTime = a.copy$default$7;
              val x$41: org.joda.time.DateTime = a.copy$default$8;
              val x$42: model.Dollars = a.copy$default$9;
              a.copy(x$35, x$36, x$34, x$37, x$38, x$39, x$40, x$41, x$42)
            }))(StockSchema.this.stockAssets)
          }
        else
          StockSchema.this.toOps[StockSchema.this.StockAsset](asset).delete(StockSchema.this.stockAssets).flatMap[Unit](((x$14: StockSchema.this.StockAsset) => processAssets(soFar.-(asset.shares), restAssets)))
    };
    processAssets(new model.Shares(math.this.BigDecimal.int2bigDecimal(0)), allAssets.toList).flatMap[Unit](((_: Unit) => StockSchema.this.toOps[StockSchema.this.Portfolio](this).update(((t: StockSchema.this.Portfolio) => {
  val x$43: model.Dollars = t.cash.+(dollars);
  val x$44: model.package.Key = t.copy$default$1;
  val x$45: model.Link[StockSchema.this.League] = t.copy$default$2;
  val x$46: String = t.copy$default$3;
  val x$47: model.Dollars = t.copy$default$5;
  val x$48: Int = t.copy$default$6;
  t.copy(x$44, x$45, x$46, x$43, x$47, x$48)
}))(StockSchema.this.portfolios).flatMap[Unit](((_: Unit) => new StockSchema.this.Sold(this, ticker, shares, dollars, price).report().map[Unit](((_: StockSchema.this.NewsEvent) => ()))))))
  };
  private[model] def sellAll(ticker: String): StockSchema.this.Transaction[Unit] = {
    val assets: List[StockSchema.this.StockAsset] = PortfolioWithStocks.this.myStockAssets.filter(((x$15: StockSchema.this.StockAsset) => x$15.ticker.==(ticker)));
    val delete: StockSchema.this.Transaction[List[StockSchema.this.StockAsset]] = scalaz.Scalaz.SeqMA[List, StockSchema.this.Transaction[StockSchema.this.StockAsset]](assets.map[StockSchema.this.Transaction[StockSchema.this.StockAsset], List[StockSchema.this.Transaction[StockSchema.this.StockAsset]]](((x$16: StockSchema.this.StockAsset) => StockSchema.this.toOps[StockSchema.this.StockAsset](x$16).delete(StockSchema.this.stockAssets)))(immutable.this.List.canBuildFrom[StockSchema.this.Transaction[StockSchema.this.StockAsset]])).sequence[StockSchema.this.Transaction, StockSchema.this.StockAsset](scala.this.Predef.conforms[StockSchema.this.Transaction[StockSchema.this.StockAsset]], scalaz.this.Traverse.TraversableTraverse[List](scalaz.this.CanBuildAnySelf.GenericCanBuildSelf[List](immutable.this.List.canBuildFrom[Nothing])), scalaz.this.Applicative.applicative[StockSchema.this.Transaction](StockSchema.this.TransactionPure, scalaz.this.Apply.FunctorBindApply[StockSchema.this.Transaction](StockSchema.this.TransactionFunctor, StockSchema.this.TransactionBind)));
    val totalShares: model.Shares = new model.Shares(assets.map[scala.math.BigDecimal, List[scala.math.BigDecimal]](((x$17: StockSchema.this.StockAsset) => x$17.shares.shares))(immutable.this.List.canBuildFrom[scala.math.BigDecimal]).sum[scala.math.BigDecimal](math.this.Numeric.BigDecimalIsFractional));
    val price: model.Price = Stocks.stockPrice(ticker);
    val dollars: model.Dollars = totalShares.*(price);
    delete.flatMap[Unit](((_: List[StockSchema.this.StockAsset]) => StockSchema.this.toOps[StockSchema.this.Portfolio](this).update(((t: StockSchema.this.Portfolio) => {
  val x$49: model.Dollars = t.cash.+(dollars);
  val x$50: model.package.Key = t.copy$default$1;
  val x$51: model.Link[StockSchema.this.League] = t.copy$default$2;
  val x$52: String = t.copy$default$3;
  val x$53: model.Dollars = t.copy$default$5;
  val x$54: Int = t.copy$default$6;
  t.copy(x$50, x$51, x$52, x$49, x$53, x$54)
}))(StockSchema.this.portfolios).flatMap[Unit](((_: Unit) => new StockSchema.this.Sold(this, ticker, totalShares, dollars, price).report().map[Unit](((_: StockSchema.this.NewsEvent) => ()))))))
  }
}
PortfolioWithStocks: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.412
         getMySt howMany howMany buyStoc buyStoc userSel sellSto userSel myStock myStock sellSto buyStoc userBuy sellSto userBuy sellAll userSel

case class DatabaseException extends scala.`package`.Exception with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val message: String = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def message: String = DatabaseException.this.message;
  <caseaccessor> <paramaccessor> private[this] val source: Throwable = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def source: Throwable = DatabaseException.this.source;
  def this(message: String, source: Throwable): stockdata.DatabaseException = {
    DatabaseException.super.this(message, source);
    ()
  };
  <synthetic> def copy(message: String = message, source: Throwable = source): stockdata.DatabaseException = new stockdata.this.DatabaseException(message, source);
  <synthetic> def copy$default$2: Throwable @scala.annotation.unchecked.uncheckedVariance = DatabaseException.this.source;
  <synthetic> def copy$default$1: String @scala.annotation.unchecked.uncheckedVariance = DatabaseException.this.message;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(DatabaseException.this);
  override def equals(x$1: Any): Boolean = DatabaseException.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (message: String, source: Throwable)stockdata.DatabaseException((message$1 @ _), (source$1 @ _)) if message$1.==(message).&&(source$1.==(source)) => x$1.asInstanceOf[stockdata.DatabaseException].canEqual(DatabaseException.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "DatabaseException";
  override def productArity: Int = 2;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => message
    case 1 => source
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[stockdata.DatabaseException]()
}
DatabaseException: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
 message
  source

abstract trait Renderable extends scala.AnyRef {
  def render: scala.xml.NodeSeq
}
Renderable: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
  render

final object Transaction extends java.lang.Object with ScalaObject with Serializable {
  def this(): object Transactions.this.Transaction = {
    Transaction.super.this();
    ()
  };
  def apply[A >: Nothing <: Any](result: A): Transactions.this.Transaction[A] = new Transactions.this.Transaction[A](result, collection.this.Seq.apply[Nothing]());
  case <synthetic> def unapply[A >: Nothing <: Any](x$0: Transactions.this.Transaction[A]): Option[(A, Seq[Transactions.this.EditOp])] = if (x$0.==(null))
    scala.this.None
  else
    new Some[(A, Seq[Transactions.this.EditOp])](new (A, Seq[Transactions.this.EditOp])(x$0.result, x$0.ops));
  case <synthetic> def apply[A >: Nothing <: Any](result: A, ops: Seq[Transactions.this.EditOp]): Transactions.this.Transaction[A] = new Transactions.this.Transaction[A](result, ops)
}
Transaction: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
           apply

class MergeAttr extends java.lang.Object with ScalaObject {
  <paramaccessor> private[this] val n1: scala.xml.NodeSeq = _;
  def this(n1: scala.xml.NodeSeq): intform.package.MergeAttr = {
    MergeAttr.super.this();
    ()
  };
  def &(n2: scala.xml.Node): scala.xml.NodeSeq = package.this.nodeSeqPlus(MergeAttr.this.n1).leafMap(((e: scala.xml.Elem) => if (e.label.==(n2.label))
    e.%(n2.head.attributes)
  else
    e))
}
MergeAttr: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
            $amp
      n1     X  

final object ListField extends java.lang.Object with ScalaObject {
  def this(): object intform.ListField = {
    ListField.super.this();
    ()
  };
  def apply[A >: Nothing <: Any](g: => intform.Field[A] with intform.Renderable, r: (Seq[intform.ItemRender], scala.xml.NodeSeq) => scala.xml.NodeSeq): intform.ListField[A] = new intform.ListField[A]((() => g), r)
}
ListField: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
           apply

final object ResponseAsset extends  {
  def this() = _
}
ResponseAsset: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

abstract trait H2Schema extends java.lang.Object with org.squeryl.Schema with ScalaObject {
  def /*H2Schema*/$init$(): Unit = {
    ()
  };
  private[this] val dbDriver: java.lang.String = "org.h2.Driver";
  <stable> <accessor> def dbDriver: java.lang.String = H2Schema.this.dbDriver;
  private[this] val adapter: org.squeryl.adapters.H2Adapter = new org.squeryl.adapters.H2Adapter();
  <stable> <accessor> def adapter: org.squeryl.adapters.H2Adapter = H2Schema.this.adapter;
  private[this] val dbUrl: java.lang.String = "jdbc:h2:data;AUTO_SERVER=TRUE";
  <stable> <accessor> def dbUrl: java.lang.String = H2Schema.this.dbUrl;
  private[this] val dbFile: java.lang.String = "data.h2.db";
  <stable> <accessor> def dbFile: java.lang.String = H2Schema.this.dbFile;
  def init(): Unit = {
    java.this.lang.Class.forName(H2Schema.this.dbDriver);
    org.squeryl.SessionFactory.concreteFactory_=(new Some[() => org.squeryl.Session]((() => org.squeryl.Session.create(java.sql.DriverManager.getConnection(H2Schema.this.dbUrl), H2Schema.this.adapter))))
  };
  def clearDatabase(): Unit = {
    new java.io.File(H2Schema.this.dbFile).delete();
    H2Schema.this.init();
    org.squeryl.PrimitiveTypeMode.transaction[Unit](this.create)
  };
  def schemaDDL: String = {
    var schema: String = "";
    this.printDdl(((st: String) => {
      schema = schema.+(st);
      schema = schema.+("\012");
      schema = schema.+("\012")
    }));
    schema
  }
}
H2Schema: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=1.000
            init clearDa schemaD

final case object ToBuyer extends Direction with ScalaObject with Product with Serializable {
  def this(): object code.snippet.ToBuyer = {
    ToBuyer.super.this();
    ()
  };
  def sign(x: model.Dollars): model.Dollars = x;
  def sign(x: model.Shares): model.Shares = x;
  def sign(x: Int): Int = x;
  final override def hashCode(): Int = 483291096;
  final override def toString(): java.lang.String = "ToBuyer";
  override def productPrefix: java.lang.String = "ToBuyer";
  override def productArity: Int = 0;
  override def productElement(x$1: Int): Any = x$1 match {
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[object code.snippet.ToBuyer]();
  protected def readResolve(): java.lang.Object = snippet.this.ToBuyer
}
ToBuyer: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.250
            sign readRes    sign    sign

class SellServlet extends HttpServlet {
  import SellServlet._;
  def this() = _;
  protected[servlets] def doPost(request: HttpServletRequest = _, response: HttpServletResponse = _): Unit = _
}
SellServlet: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
          doPost

case class Update[R >: Nothing <: model.KL] extends java.lang.Object with Transactions.this.EditOp with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val rec: R = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def rec: R = Update.this.rec;
  <caseaccessor> <paramaccessor> private[this] val by: R => R = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def by: R => R = Update.this.by;
  <caseaccessor> <paramaccessor> private[this] val table: model.Table[R] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def table: model.Table[R] = Update.this.table;
  def this(rec: R, by: R => R, table: model.Table[R]): Transactions.this.Update[R] = {
    Update.super.this();
    ()
  };
  def perform(): Unit = Update.this.table.update({
    Transactions.this.logger.info("Updating ".+(Update.this.rec));
    val old: R = Update.this.table.lookup(Update.this.rec.id).getOrElse[R](throw Transactions.this.NotFound);
    Transactions.this.logger.info("->Updating ".+(old));
    val next: R = Update.this.by.apply(old);
    scala.this.Predef.assert(next.id.==(old.id), "You changed an object\'s ID");
    Transactions.this.logger.info("~>Updating ".+(next));
    next
  });
  private[this] val affectedTables: Seq[model.Table[R]] = collection.this.Seq.apply[model.Table[R]](Update.this.table);
  <stable> <accessor> def affectedTables: Seq[model.Table[R]] = Update.this.affectedTables;
  <synthetic> def copy[R >: Nothing <: model.KL](rec: R = rec, by: R => R = by, table: model.Table[R] = table): Transactions.this.Update[R] = new Transactions.this.Update[R](rec, by, table);
  <synthetic> def copy$default$3[R >: Nothing <: model.KL]: model.Table[R] @scala.annotation.unchecked.uncheckedVariance = Update.this.table;
  <synthetic> def copy$default$2[R >: Nothing <: model.KL]: R => R @scala.annotation.unchecked.uncheckedVariance = Update.this.by;
  <synthetic> def copy$default$1[R >: Nothing <: model.KL]: R @scala.annotation.unchecked.uncheckedVariance = Update.this.rec;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(Update.this);
  override def toString(): String = ScalaRunTime.this._toString(Update.this);
  override def equals(x$1: Any): Boolean = Update.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (rec: model.KL, by: model.KL => model.KL, table: model.Table[model.KL])Transactions.this.Update[model.KL]((rec$2 @ _), (by$1 @ _), (table$2 @ _)) if rec$2.==(rec).&&(by$1.==(by)).&&(table$2.==(table)) => x$1.asInstanceOf[Transactions.this.Update[R]].canEqual(Update.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "Update";
  override def productArity: Int = 3;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => rec
    case 1 => by
    case 2 => table
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[Transactions.this.Update[R]]()
}
Update: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
         perform
      by     X  
   table     X  
     rec     X  

final class $anon extends java.lang.Object with scalaz.Bind[Transactions.this.Transaction] {
  def this(): anonymous class $anon = {
    $anon.super.this();
    ()
  };
  def bind[A >: Nothing <: Any, B >: Nothing <: Any](a: Transactions.this.Transaction[A], f: A => Transactions.this.Transaction[B]): Transactions.this.Transaction[B] = a.flatMap[B](f)
}
$anon: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
            bind

case class Derivative extends java.lang.Object with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val securities: Seq[model.Security] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def securities: Seq[model.Security] = Derivative.this.securities;
  <caseaccessor> <paramaccessor> private[this] val exec: org.joda.time.DateTime = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def exec: org.joda.time.DateTime = Derivative.this.exec;
  <caseaccessor> <paramaccessor> private[this] val condition: model.Condition = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def condition: model.Condition = Derivative.this.condition;
  <caseaccessor> <paramaccessor> private[this] val early: Boolean = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def early: Boolean = Derivative.this.early;
  def this(securities: Seq[model.Security], exec: org.joda.time.DateTime, condition: model.Condition, early: Boolean): model.Derivative = {
    Derivative.super.this();
    ()
  };
  def *(scale: model.Scale): model.Derivative = this.copy(Derivative.this.securities.map[model.Security, Seq[model.Security]](((x$7: model.Security) => x$7.*(scale)))(collection.this.Seq.canBuildFrom[model.Security]), this.copy$default$2, this.copy$default$3, this.copy$default$4);
  def spotValue: model.Dollars = Derivative.this.securities.map[model.Dollars, Seq[model.Dollars]](((x$8: model.Security) => x$8.spotValue))(collection.this.Seq.canBuildFrom[model.Dollars]).foldLeft[model.Dollars](new model.Dollars(math.this.BigDecimal.int2bigDecimal(0)))(((x$9: model.Dollars, x$10: model.Dollars) => x$9.+(x$10)));
  <synthetic> def copy$default$4: Boolean @scala.annotation.unchecked.uncheckedVariance = Derivative.this.early;
  <synthetic> def copy$default$3: model.Condition @scala.annotation.unchecked.uncheckedVariance = Derivative.this.condition;
  <synthetic> def copy$default$2: org.joda.time.DateTime @scala.annotation.unchecked.uncheckedVariance = Derivative.this.exec;
  <synthetic> def copy$default$1: Seq[model.Security] @scala.annotation.unchecked.uncheckedVariance = Derivative.this.securities;
  <synthetic> def copy(securities: Seq[model.Security] = securities, exec: org.joda.time.DateTime = exec, condition: model.Condition = condition, early: Boolean = early): model.Derivative = new model.this.Derivative(securities, exec, condition, early);
  override def hashCode(): Int = ScalaRunTime.this._hashCode(Derivative.this);
  override def toString(): String = ScalaRunTime.this._toString(Derivative.this);
  override def equals(x$1: Any): Boolean = Derivative.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (securities: Seq[model.Security], exec: org.joda.time.DateTime, condition: model.Condition, early: Boolean)model.Derivative((securities$1 @ _), (exec$2 @ _), (condition$1 @ _), (early$1 @ _)) if securities$1.==(securities).&&(exec$2.==(exec)).&&(condition$1.==(condition)).&&(early$1.==(early)) => x$1.asInstanceOf[model.Derivative].canEqual(Derivative.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "Derivative";
  override def productArity: Int = 4;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => securities
    case 1 => exec
    case 2 => condition
    case 3 => early
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[model.Derivative]()
}
Derivative: SCOM=1.000 CC=0.250 LSCC=0.250 CAMC=0.500
          $times spotVal
    exec     X          
 securit     X       X  
 conditi     X          
   early     X          

class StockOrderer extends java.lang.Object with intform.Page with net.liftweb.common.Loggable with ScalaObject {
  def this(): code.snippet.StockOrderer = {
    StockOrderer.super.this();
    ()
  };
  private[this] var currentQuote: Option[stockdata.Quote] = scala.None;
  private <accessor> def currentQuote: Option[stockdata.Quote] = StockOrderer.this.currentQuote;
  private <accessor> def currentQuote_=(x$1: Option[stockdata.Quote]): Unit = StockOrderer.this.currentQuote = x$1;
  private[this] var listeners: List[code.snippet.StockOrder => net.liftweb.http.js.JsCmd] = immutable.this.Nil;
  private <accessor> def listeners: List[code.snippet.StockOrder => net.liftweb.http.js.JsCmd] = StockOrderer.this.listeners;
  private <accessor> def listeners_=(x$1: List[code.snippet.StockOrder => net.liftweb.http.js.JsCmd]): Unit = StockOrderer.this.listeners = x$1;
  private[this] val refreshable: intform.Refreshable.NeedRenderable with intform.Refreshable = intform.Refreshable.apply(StockOrderer.this.currentQuote match {
    case (x: stockdata.Quote)Some[stockdata.Quote]((quote @ _)) => StockOrderer.this.purchaseForm(quote)
    case scala.None => xml.this.NodeSeq.seqToNodeSeq(immutable.this.Nil)
  });
  private <stable> <accessor> def refreshable: intform.Refreshable.NeedRenderable with intform.Refreshable = StockOrderer.this.refreshable;
  def purchaseForm(quote: stockdata.Quote): scala.xml.NodeSeq = {
    lazy var form$lzy: intform.Form[model.Dollars] = _;
    <stable> <accessor> lazy def form: intform.Form[model.Dollars] = {
      form$lzy = intform.Form.apply[model.Dollars, up.HList.:+:[model.Dollars,up.HNil]](intform.`package`.hlistify1[model.Dollars, model.Dollars]({
        ((x: model.Dollars) => scala.this.Predef.identity[model.Dollars](x))
      }), intform.`package`.klist1[intform.Field, model.Dollars]((volumeField: intform.Field[model.Dollars])), {
        {
          var $md: scala.xml.MetaData = scala.xml.Null;
          $md = new scala.xml.UnprefixedAttribute("id", new scala.xml.Text("search-buy"), $md);
          $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("block"), $md);
          new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
            $buf.&+(new scala.xml.Text("\012                "));
            $buf.&+({
              {
                new scala.xml.Elem(null, "h2", scala.xml.Null, scala.this.Predef.$scope, ({
                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                  $buf.&+(new scala.xml.Text("Choose Volume"));
                  $buf
                }: _*))
              }
            });
            $buf.&+(new scala.xml.Text("\012                "));
            $buf.&+({
              {
                new scala.xml.Elem(null, "p", scala.xml.Null, scala.this.Predef.$scope, ({
                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                  $buf.&+(new scala.xml.Text("Enter the amount you would like to purchase in dollars. This will be\012                converted to shares and will be added to your portfolio."));
                  $buf
                }: _*))
              }
            });
            $buf.&+(new scala.xml.Text("\012\012                "));
            $buf.&+({
              {
                var $md: scala.xml.MetaData = scala.xml.Null;
                $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("price-input"), $md);
                new scala.xml.Elem(null, "p", $md, scala.this.Predef.$scope, ({
                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                  $buf.&+(new scala.xml.Text("\012                    $"));
                  $buf.&+(intform.`package`.mergeAttr(volumeField.main).&({
                    {
                      var $md: scala.xml.MetaData = scala.xml.Null;
                      $md = new scala.xml.UnprefixedAttribute("id", new scala.xml.Text("search-quantity"), $md);
                      $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("blank"), $md);
                      new scala.xml.Elem(null, "input", $md, scala.this.Predef.$scope)
                    }
                  }));
                  $buf.&+(new scala.xml.Text("\012                    "));
                  $buf.&+({
                    {
                      var $md: scala.xml.MetaData = scala.xml.Null;
                      $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("error"), $md);
                      new scala.xml.Elem(null, "span", $md, scala.this.Predef.$scope, ({
                        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                        $buf.&+(submitBuy.errors);
                        $buf.&+(submitAdd.errors);
                        $buf
                      }: _*))
                    }
                  });
                  $buf.&+(new scala.xml.Text("\012                "));
                  $buf
                }: _*))
              }
            });
            $buf.&+(new scala.xml.Text("\012\012                "));
            $buf.&+({
              {
                var $md: scala.xml.MetaData = scala.xml.Null;
                $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("buttons"), $md);
                new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                  $buf.&+(new scala.xml.Text("\012                    "));
                  $buf.&+(intform.`package`.mergeAttr(submitBuy.main).&({
                    {
                      new scala.xml.Elem(null, "input", scala.xml.Null, scala.this.Predef.$scope)
                    }
                  }));
                  $buf.&+(new scala.xml.Text(" \012                    "));
                  $buf.&+(intform.`package`.mergeAttr(submitAdd.main).&({
                    {
                      new scala.xml.Elem(null, "input", scala.xml.Null, scala.this.Predef.$scope)
                    }
                  }));
                  $buf.&+(new scala.xml.Text(" \012                    "));
                  $buf.&+(intform.`package`.mergeAttr(submitCancel.main).&({
                    {
                      new scala.xml.Elem(null, "input", scala.xml.Null, scala.this.Predef.$scope)
                    }
                  }));
                  $buf.&+(new scala.xml.Text(" \012                "));
                  $buf
                }: _*))
              }
            });
            $buf.&+(new scala.xml.Text("\012            "));
            $buf
          }: _*))
        }
      });
      form$lzy
    };
    lazy var volumeField$lzy: code.snippet.DollarsField with intform.FieldErrorRender = _;
    <stable> <accessor> lazy def volumeField: code.snippet.DollarsField with intform.FieldErrorRender = {
      volumeField$lzy = {
        final class $anon extends DollarsField with intform.FieldErrorRender {
          def this(): anonymous class $anon = {
            $anon.super.this("1000");
            ()
          }
        };
        new $anon()
      };
      volumeField$lzy
    };
    lazy var submitBuy$lzy: intform.Submit[model.Dollars] = _;
    <stable> <accessor> lazy def submitBuy: intform.Submit[model.Dollars] = {
      submitBuy$lzy = intform.Submit.apply[model.Dollars](form, "Buy Shares", intform.Submit.apply$default$3[Nothing])(((volume: model.Dollars) => {
        try {
          StockOrderer.this.buyStock(quote, volume)
        } catch {
          case model.schema.NegativeVolume => throw new intform.BadFieldInput(volumeField, "You must buy more than $0.00 of a stock")
          case (have: model.Dollars, need: model.Dollars)model.schema.NotEnoughCash((have @ _), (need @ _)) => throw new intform.BadFieldInput(volumeField, scala.this.Predef.augmentString("You need at least %s you only have %s").format(need.$, have.$))
          case control.LoginManager.NotLoggedIn => throw new intform.BadInput("You must be logged in to buy stock")
        }
      }));
      submitBuy$lzy
    };
    lazy var submitAdd$lzy: intform.Submit[model.Dollars] = _;
    <stable> <accessor> lazy def submitAdd: intform.Submit[model.Dollars] = {
      submitAdd$lzy = intform.Submit.apply[model.Dollars](form, "Add to Derivative", intform.Submit.apply$default$3[Nothing])(((v: model.Dollars) => StockOrderer.this.addStockToDerivative(quote, v./-/(quote.price))));
      submitAdd$lzy
    };
    lazy var submitCancel$lzy: intform.Submit[model.Dollars] = _;
    <stable> <accessor> lazy def submitCancel: intform.Submit[model.Dollars] = {
      submitCancel$lzy = intform.Submit.apply[model.Dollars](form, "Cancel", intform.Submit.apply$default$3[Nothing])(((v: model.Dollars) => StockOrderer.this.notifyAndRefresh(new code.snippet.NoOrder())));
      submitCancel$lzy
    };
    form.render
  };
  private def buyStock(quote: stockdata.Quote, dollars: model.Dollars): net.liftweb.http.js.JsCmd = {
    this.logger.info(scala.this.Predef.augmentString("Buying %s of %s").format(dollars, quote));
    val shares: model.Shares = dollars./-/(quote.price);
    if (shares.>(new model.Shares(math.this.BigDecimal.int2bigDecimal(0))))
      {
        control.PortfolioSwitcher.currentPortfolio.userBuyStock(quote.stock.symbol, shares);
        StockOrderer.this.currentQuote_=(scala.None);
        StockOrderer.this.notifyAndRefresh(new code.snippet.BuyShares(quote, dollars))
      }
    else
      throw new intform.BadInput("You must buy a minimum of one share.")
  };
  private def addStockToDerivative(quote: stockdata.Quote, shares: model.Shares): net.liftweb.http.js.JsCmd = {
    StockOrderer.this.currentQuote_=(scala.None);
    StockOrderer.this.notifyAndRefresh(new code.snippet.AddToDerivative(quote, shares))
  };
  private def notify(action: code.snippet.StockOrder): net.liftweb.http.js.JsCmd = StockOrderer.this.listeners.map[net.liftweb.http.js.JsCmd, List[net.liftweb.http.js.JsCmd]](((callback: code.snippet.StockOrder => net.liftweb.http.js.JsCmd) => callback.apply(action)))(immutable.this.List.canBuildFrom[net.liftweb.http.js.JsCmd]).foldLeft[net.liftweb.http.js.JsCmd](net.liftweb.http.js.JsCmds.Noop)(((x$1: net.liftweb.http.js.JsCmd, x$2: net.liftweb.http.js.JsCmd) => x$1.&(x$2)));
  private def notifyAndRefresh(action: code.snippet.StockOrder): net.liftweb.http.js.JsCmd = StockOrderer.this.notify(action).&(StockOrderer.this.refreshable.refresh());
  def listen(callback: code.snippet.StockOrder => net.liftweb.http.js.JsCmd): Unit = StockOrderer.this.listeners_=(StockOrderer.this.listeners.::[code.snippet.StockOrder => net.liftweb.http.js.JsCmd](callback));
  def changeQuote(quote: stockdata.Quote): net.liftweb.http.js.JsCmd = {
    StockOrderer.this.currentQuote_=(new Some[stockdata.Quote](quote));
    StockOrderer.this.refreshable.refresh()
  };
  def clearQuote: net.liftweb.http.js.JsCmd = {
    StockOrderer.this.currentQuote_=(scala.None);
    StockOrderer.this.refreshable.refresh()
  };
  override def render: scala.xml.NodeSeq = StockOrderer.this.refreshable.render
}
StockOrderer: SCOM=0.556 CC=0.403 LSCC=0.347 CAMC=0.200
          listen changeQ notifyA buyStoc  notify  render purchas addStoc clearQu
 current             X               X                       X       X       X  
 listene     X               X       X       X               X       X          

final object quoteReport extends java.lang.Object with net.liftweb.common.Loggable with ScalaObject {
  def this(): object code.snippet.quoteReport = {
    quoteReport.super.this();
    ()
  };
  def apply(quote: stockdata.Quote): scala.xml.NodeSeq = {
    def quoteBlockPresent: scala.xml.Elem = {
      {
        var $md: scala.xml.MetaData = scala.xml.Null;
        $md = new scala.xml.UnprefixedAttribute("id", new scala.xml.Text("search-quote"), $md);
        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("quote block"), $md);
        new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
          $buf.&+(new scala.xml.Text("\012            "));
          $buf.&+({
            {
              new scala.xml.Elem(null, "h2", scala.xml.Null, scala.this.Predef.$scope, ({
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+(quote.stock.symbol);
                $buf.&+(new scala.xml.Text(" - "));
                $buf.&+(quote.company);
                $buf
              }: _*))
            }
          });
          $buf.&+(new scala.xml.Text("\012            "));
          $buf.&+({
            {
              new scala.xml.Elem(null, "h3", scala.xml.Null, scala.this.Predef.$scope, ({
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+(new scala.xml.Text("\012                "));
                $buf.&+({
                  {
                    var $md: scala.xml.MetaData = scala.xml.Null;
                    $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("quote-price"), $md);
                    new scala.xml.Elem(null, "span", $md, scala.this.Predef.$scope, ({
                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                      $buf.&+(quote.price.$);
                      $buf
                    }: _*))
                  }
                });
                $buf.&+(new scala.xml.Text(" -\012                "));
                $buf.&+({
                  {
                    var $md: scala.xml.MetaData = scala.xml.Null;
                    $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("quote-change"), $md);
                    new scala.xml.Elem(null, "span", $md, scala.this.Predef.$scope, ({
                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                      $buf.&+(formats.`package`.bigDecimalOptionFormatted(quote.info.percentChange).%());
                      $buf
                    }: _*))
                  }
                });
                $buf.&+(new scala.xml.Text("\012            "));
                $buf
              }: _*))
            }
          });
          $buf.&+(new scala.xml.Text("\012            "));
          $buf.&+({
            {
              new scala.xml.Elem(null, "dl", scala.xml.Null, scala.this.Predef.$scope, ({
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+(new scala.xml.Text(" "));
                $buf.&+({
                  {
                    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                    $buf.&+({
                      {
                        new scala.xml.Elem(null, "dt", scala.xml.Null, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(new scala.xml.Text("Open"));
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+({
                      {
                        var $md: scala.xml.MetaData = scala.xml.Null;
                        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("quote-open"), $md);
                        new scala.xml.Elem(null, "dd", $md, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(formats.`package`.bigDecimalOptionFormatted(quote.info.openPrice).$);
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+({
                      {
                        new scala.xml.Elem(null, "dt", scala.xml.Null, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(new scala.xml.Text("Low"));
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+({
                      {
                        var $md: scala.xml.MetaData = scala.xml.Null;
                        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("quote-low"), $md);
                        new scala.xml.Elem(null, "dd", $md, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(formats.`package`.bigDecimalOptionFormatted(quote.info.lowPrice).$);
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+({
                      {
                        new scala.xml.Elem(null, "dt", scala.xml.Null, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(new scala.xml.Text("High"));
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+({
                      {
                        var $md: scala.xml.MetaData = scala.xml.Null;
                        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("quote-high"), $md);
                        new scala.xml.Elem(null, "dd", $md, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(formats.`package`.bigDecimalOptionFormatted(quote.info.highPrice).$);
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+({
                      {
                        new scala.xml.Elem(null, "dt", scala.xml.Null, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(new scala.xml.Text("Dividend"));
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+({
                      {
                        var $md: scala.xml.MetaData = scala.xml.Null;
                        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("quote-dividend"), $md);
                        new scala.xml.Elem(null, "dd", $md, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(formats.`package`.bigDecimalOptionFormatted(quote.info.dividendShare).$);
                          $buf
                        }: _*))
                      }
                    });
                    $buf
                  }
                });
                $buf.&+(new scala.xml.Text(" "));
                $buf
              }: _*))
            }
          });
          $buf.&+(new scala.xml.Text("\012            "));
          $buf.&+(quoteGraph);
          $buf.&+(new scala.xml.Text("\012        "));
          $buf
        }: _*))
      }
    };
    def quoteGraph: scala.xml.Elem = {
      {
        var $md: scala.xml.MetaData = scala.xml.Null;
        $md = new scala.xml.UnprefixedAttribute("src", graphURL, $md);
        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("quote-graph"), $md);
        $md = new scala.xml.UnprefixedAttribute("alt", new scala.xml.Text("stock price over time"), $md);
        new scala.xml.Elem(null, "img", $md, scala.this.Predef.$scope)
      }
    };
    def graphURL: String = scala.this.Predef.augmentString("http://ichart.finance.yahoo.com/instrument/1.0/%s/chart;range=1d/image;size=239x110").format(quote.stock.symbol.toLowerCase());
    quoteBlockPresent
  }
}
quoteReport: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
           apply

abstract trait PortfolioWithDerivatives extends java.lang.Object with ScalaObject { self: DerivativeSchema.this.Portfolio => 
  def /*PortfolioWithDerivatives*/$init$(): Unit = {
    ()
  };
  def myDerivativeAssets: List[DerivativeSchema.this.DerivativeAsset] = DerivativeSchema.this.derivativeAssets.filter(((x$2: DerivativeSchema.this.DerivativeAsset) => x$2.owner.~~(this))).toList;
  def myDerivativeLiabilities: List[DerivativeSchema.this.DerivativeLiability] = DerivativeSchema.this.derivativeLiabilities.filter(((x$3: DerivativeSchema.this.DerivativeLiability) => x$3.owner.~~(this))).toList;
  def myDerivativeOffers: List[DerivativeSchema.this.DerivativeOffer] = DerivativeSchema.this.derivativeOffers.filter(((x$4: DerivativeSchema.this.DerivativeOffer) => x$4.to.~~(this))).toList;
  def userOfferDerivativeTo(recip: DerivativeSchema.this.Portfolio, deriv: model.Derivative, price: model.Dollars): DerivativeSchema.this.DerivativeOffer = DerivativeSchema.this.editDB[DerivativeSchema.this.DerivativeOffer](DerivativeSchema.this.toOps[DerivativeSchema.this.DerivativeOffer]({
  val x$35: model.Derivative = deriv;
  val x$36: model.Link[DerivativeSchema.this.Portfolio] = model.this.KL.toLink[DerivativeSchema.this.Portfolio](this);
  val x$37: model.Link[DerivativeSchema.this.Portfolio] = model.this.KL.toLink[DerivativeSchema.this.Portfolio](recip);
  val x$38: model.Dollars = price;
  val x$39: org.joda.time.DateTime = new org.joda.time.DateTime();
  val x$40: model.package.Key = DerivativeSchema.this.DerivativeOffer.apply$default$1;
  new DerivativeSchema.this.DerivativeOffer(x$40, x$35, x$36, x$37, x$38, x$39)
}).insert(DerivativeSchema.this.derivativeOffers).flatMap[DerivativeSchema.this.DerivativeOffer](((offer: DerivativeSchema.this.DerivativeOffer) => new DerivativeSchema.this.Offered(this, recip, deriv, price).report().map[DerivativeSchema.this.DerivativeOffer](((_: DerivativeSchema.this.NewsEvent) => offer)))));
  def userOfferDerivativeAtAuction(deriv: model.Derivative, price: model.Dollars, expires: org.joda.time.DateTime): Unit = DerivativeSchema.this.editDB[Unit](DerivativeSchema.this.toOps[DerivativeSchema.this.AuctionOffer]({
  val x$41: model.Derivative = deriv;
  val x$42: model.Link[DerivativeSchema.this.Portfolio] = model.this.KL.toLink[DerivativeSchema.this.Portfolio](this);
  val x$43: model.Dollars = price;
  val x$44: org.joda.time.DateTime = new org.joda.time.DateTime();
  val x$45: org.joda.time.DateTime = expires;
  val x$46: model.package.Key = DerivativeSchema.this.AuctionOffer.apply$default$1;
  new DerivativeSchema.this.AuctionOffer(x$46, x$41, x$42, x$43, x$44, x$45)
}).insert(DerivativeSchema.this.auctionOffers).flatMap[Unit](((_: DerivativeSchema.this.AuctionOffer) => new DerivativeSchema.this.Auctioned(this, deriv, price).report().map[Unit](((_: DerivativeSchema.this.NewsEvent) => ())))));
  def userAcceptOffer(id: String): DerivativeSchema.this.NewsEvent = DerivativeSchema.this.editDB[DerivativeSchema.this.NewsEvent]({
    val offer: DerivativeSchema.this.DerivativeOffer = DerivativeSchema.this.derivativeOffers.lookup(id).getOrElse[DerivativeSchema.this.DerivativeOffer](throw DerivativeSchema.this.NoSuchOffer);
    PortfolioWithDerivatives.this.enterContractWithVotes(model.this.Link.extract[DerivativeSchema.this.Portfolio](offer.from)(DerivativeSchema.this.portfolios), offer.derivative, offer.price).filter(((check$ifrefutable$1: (DerivativeSchema.this.DerivativeBuyerSetAside, DerivativeSchema.this.DerivativeSellerSetAside)) => (check$ifrefutable$1: (DerivativeSchema.this.DerivativeBuyerSetAside, DerivativeSchema.this.DerivativeSellerSetAside) @unchecked) match {
  case (_1: DerivativeSchema.this.DerivativeBuyerSetAside, _2: DerivativeSchema.this.DerivativeSellerSetAside)(DerivativeSchema.this.DerivativeBuyerSetAside, DerivativeSchema.this.DerivativeSellerSetAside)((buyerAside @ _), (sellerAside @ _)) => true
  case _ => false
})).flatMap[DerivativeSchema.this.NewsEvent](((x$5: (DerivativeSchema.this.DerivativeBuyerSetAside, DerivativeSchema.this.DerivativeSellerSetAside)) => (x$5: (DerivativeSchema.this.DerivativeBuyerSetAside, DerivativeSchema.this.DerivativeSellerSetAside) @unchecked) match {
      case (_1: DerivativeSchema.this.DerivativeBuyerSetAside, _2: DerivativeSchema.this.DerivativeSellerSetAside)(DerivativeSchema.this.DerivativeBuyerSetAside, DerivativeSchema.this.DerivativeSellerSetAside)((buyerAside @ _), (sellerAside @ _)) => DerivativeSchema.this.toOps[DerivativeSchema.this.DerivativeOffer](offer).delete(DerivativeSchema.this.derivativeOffers).flatMap[DerivativeSchema.this.NewsEvent](((_: DerivativeSchema.this.DerivativeOffer) => new DerivativeSchema.this.Accepted(model.this.Link.extract[DerivativeSchema.this.Portfolio](offer.from)(DerivativeSchema.this.portfolios), model.this.Link.extract[DerivativeSchema.this.Portfolio](offer.to)(DerivativeSchema.this.portfolios), offer.derivative, offer.price, model.this.KL.toLink[DerivativeSchema.this.DerivativeBuyerSetAside](buyerAside), model.this.KL.toLink[DerivativeSchema.this.DerivativeSellerSetAside](sellerAside)).report().map[DerivativeSchema.this.NewsEvent](((event: DerivativeSchema.this.NewsEvent) => event))))
    }))
  });
  def userDeclineOffer(id: String): Unit = DerivativeSchema.this.editDB[Unit]({
    val offer: DerivativeSchema.this.DerivativeOffer = DerivativeSchema.this.derivativeOffers.lookup(id).getOrElse[DerivativeSchema.this.DerivativeOffer](throw DerivativeSchema.this.NoSuchOffer);
    DerivativeSchema.this.toOps[DerivativeSchema.this.DerivativeOffer](offer).delete(DerivativeSchema.this.derivativeOffers).flatMap[Unit](((_: DerivativeSchema.this.DerivativeOffer) => new DerivativeSchema.this.Declined(model.this.Link.extract[DerivativeSchema.this.Portfolio](offer.from)(DerivativeSchema.this.portfolios), model.this.Link.extract[DerivativeSchema.this.Portfolio](offer.to)(DerivativeSchema.this.portfolios), offer.derivative, offer.price).report().map[Unit](((_: DerivativeSchema.this.NewsEvent) => ()))))
  });
  private[model] def enterContract(seller: DerivativeSchema.this.Portfolio, deriv: model.Derivative, price: model.Dollars, hidden: Boolean = false): DerivativeSchema.this.Transaction[Unit] = DerivativeSchema.this.toOps[DerivativeSchema.this.DerivativeLiability]({
  val x$11: model.package.Key = model.this.`package`.nextID;
  val x$12: model.Derivative = deriv;
  val x$13: model.Scale = Scale.apply("1.0");
  val x$14: org.joda.time.DateTime = deriv.exec;
  val x$15: model.Link[DerivativeSchema.this.Portfolio] = model.this.KL.toLink[DerivativeSchema.this.Portfolio](seller);
  val x$16: Boolean = hidden;
  val x$17: model.package.Key = DerivativeSchema.this.DerivativeLiability.apply$default$1;
  new DerivativeSchema.this.DerivativeLiability(x$17, x$11, x$12, x$13, x$14, x$15, x$16)
}).insert(DerivativeSchema.this.derivativeLiabilities).flatMap[Unit](((liab: DerivativeSchema.this.DerivativeLiability) => DerivativeSchema.this.toOps[DerivativeSchema.this.DerivativeAsset]({
  val x$18: model.Link[DerivativeSchema.this.DerivativeLiability] = model.this.KL.toLink[DerivativeSchema.this.DerivativeLiability](liab);
  val x$19: model.Scale = Scale.apply("1.0");
  val x$20: model.Link[DerivativeSchema.this.Portfolio] = model.this.KL.toLink[DerivativeSchema.this.Portfolio](this);
  val x$21: Boolean = hidden;
  val x$22: model.package.Key = DerivativeSchema.this.DerivativeAsset.apply$default$1;
  new DerivativeSchema.this.DerivativeAsset(x$22, x$18, x$19, x$20, x$21)
}).insert(DerivativeSchema.this.derivativeAssets).flatMap[Unit](((asset: DerivativeSchema.this.DerivativeAsset) => DerivativeSchema.this.toOps[DerivativeSchema.this.Portfolio](this).update(((t: DerivativeSchema.this.Portfolio) => {
  val x$23: model.Dollars = t.cash.-(price);
  val x$24: model.package.Key = t.copy$default$1;
  val x$25: model.Link[DerivativeSchema.this.League] = t.copy$default$2;
  val x$26: String = t.copy$default$3;
  val x$27: model.Dollars = t.copy$default$5;
  val x$28: Int = t.copy$default$6;
  t.copy(x$24, x$25, x$26, x$23, x$27, x$28)
}))(DerivativeSchema.this.portfolios).flatMap[Unit](((_: Unit) => DerivativeSchema.this.toOps[DerivativeSchema.this.Portfolio](seller).update(((t: DerivativeSchema.this.Portfolio) => {
  val x$29: model.Dollars = t.cash.+(price);
  val x$30: model.package.Key = t.copy$default$1;
  val x$31: model.Link[DerivativeSchema.this.League] = t.copy$default$2;
  val x$32: String = t.copy$default$3;
  val x$33: model.Dollars = t.copy$default$5;
  val x$34: Int = t.copy$default$6;
  t.copy(x$30, x$31, x$32, x$29, x$33, x$34)
}))(DerivativeSchema.this.portfolios).map[Unit](((_: Unit) => if (PortfolioWithDerivatives.this.cash.<(price))
    throw new DerivativeSchema.this.NotEnoughCash(PortfolioWithDerivatives.this.cash, price)
  else
    ()))))))));
  <synthetic> def enterContract$default$4: Boolean @scala.annotation.unchecked.uncheckedVariance = false;
  private[model] def enterContractWithVotes(seller: DerivativeSchema.this.Portfolio, deriv: model.Derivative, price: model.Dollars): DerivativeSchema.this.Transaction[(DerivativeSchema.this.DerivativeBuyerSetAside, DerivativeSchema.this.DerivativeSellerSetAside)] = PortfolioWithDerivatives.this.enterContract(seller, deriv, price, PortfolioWithDerivatives.this.enterContract$default$4).flatMap[(DerivativeSchema.this.DerivativeBuyerSetAside, DerivativeSchema.this.DerivativeSellerSetAside)](((_: Unit) => PortfolioWithDerivatives.this.setupSetAside(this, seller, deriv, price).filter(((check$ifrefutable$2: (DerivativeSchema.this.DerivativeBuyerSetAside, DerivativeSchema.this.DerivativeSellerSetAside)) => (check$ifrefutable$2: (DerivativeSchema.this.DerivativeBuyerSetAside, DerivativeSchema.this.DerivativeSellerSetAside) @unchecked) match {
  case (_1: DerivativeSchema.this.DerivativeBuyerSetAside, _2: DerivativeSchema.this.DerivativeSellerSetAside)(DerivativeSchema.this.DerivativeBuyerSetAside, DerivativeSchema.this.DerivativeSellerSetAside)((buyerAside @ _), (sellerAside @ _)) => true
  case _ => false
})).map[(DerivativeSchema.this.DerivativeBuyerSetAside, DerivativeSchema.this.DerivativeSellerSetAside)](((x$6: (DerivativeSchema.this.DerivativeBuyerSetAside, DerivativeSchema.this.DerivativeSellerSetAside)) => (x$6: (DerivativeSchema.this.DerivativeBuyerSetAside, DerivativeSchema.this.DerivativeSellerSetAside) @unchecked) match {
    case (_1: DerivativeSchema.this.DerivativeBuyerSetAside, _2: DerivativeSchema.this.DerivativeSellerSetAside)(DerivativeSchema.this.DerivativeBuyerSetAside, DerivativeSchema.this.DerivativeSellerSetAside)((buyerAside @ _), (sellerAside @ _)) => new (DerivativeSchema.this.DerivativeBuyerSetAside, DerivativeSchema.this.DerivativeSellerSetAside)(buyerAside, sellerAside)
  }))))
}
PortfolioWithDerivatives: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.278
         userOff userOff userAcc myDeriv myDeriv userDec enterCo enterCo myDeriv

case class DateTimeFormatted extends java.lang.Object with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val d: org.joda.time.DateTime = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def d: org.joda.time.DateTime = DateTimeFormatted.this.d;
  def this(d: org.joda.time.DateTime): formats.package.DateTimeFormatted = {
    DateTimeFormatted.super.this();
    ()
  };
  def toNearbyString: String = DateTimeFormatted.this.d.toString("M/d");
  <synthetic> def copy(d: org.joda.time.DateTime = d): formats.package.DateTimeFormatted = new package.this.DateTimeFormatted(d);
  <synthetic> def copy$default$1: org.joda.time.DateTime @scala.annotation.unchecked.uncheckedVariance = DateTimeFormatted.this.d;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(DateTimeFormatted.this);
  override def toString(): String = ScalaRunTime.this._toString(DateTimeFormatted.this);
  override def equals(x$1: Any): Boolean = DateTimeFormatted.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (d: org.joda.time.DateTime)formats.package.DateTimeFormatted((d$1 @ _)) if d$1.==(d) => x$1.asInstanceOf[formats.package.DateTimeFormatted].canEqual(DateTimeFormatted.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "DateTimeFormatted";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => d
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[formats.package.DateTimeFormatted]()
}
DateTimeFormatted: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
         toNearb
       d     X  

abstract trait BadUser extends scala.`package`.RuntimeException
BadUser: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

abstract trait NewsSchema extends java.lang.Object with ScalaObject { self: model.NewsSchema with model.DBMagic with model.SchemaErrors with model.UserSchema with model.AuctionSchema with model.StockSchema with model.CommentSchema with model.VotingSchema => 
  def /*NewsSchema*/$init$(): Unit = {
    ()
  };
  private[this] val newsEvents: model.Table[NewsSchema.this.NewsEvent] = NewsSchema.this.table[NewsSchema.this.NewsEvent];
  implicit <stable> <accessor> def newsEvents: model.Table[NewsSchema.this.NewsEvent] = NewsSchema.this.newsEvents;
  sealed abstract trait Action extends java.lang.Object with ScalaObject {
    def /*Action*/$init$(): Unit = {
      ()
    };
    protected[model] def report(): NewsSchema.this.Transaction[NewsSchema.this.NewsEvent] = NewsSchema.this.reportEvent(this)
  };
  type P = NewsSchema.this.Portfolio;
  type BSA = NewsSchema.this.DerivativeBuyerSetAside;
  type SSA = NewsSchema.this.DerivativeSellerSetAside;
  case class Bought extends java.lang.Object with NewsSchema.this.Action with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val buyer: NewsSchema.this.P = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def buyer: NewsSchema.this.P = Bought.this.buyer;
    <caseaccessor> <paramaccessor> private[this] val stock: String = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def stock: String = Bought.this.stock;
    <caseaccessor> <paramaccessor> private[this] val shares: model.Shares = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def shares: model.Shares = Bought.this.shares;
    <caseaccessor> <paramaccessor> private[this] val dollars: model.Dollars = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def dollars: model.Dollars = Bought.this.dollars;
    <caseaccessor> <paramaccessor> private[this] val price: model.Price = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def price: model.Price = Bought.this.price;
    def this(buyer: NewsSchema.this.P, stock: String, shares: model.Shares, dollars: model.Dollars, price: model.Price): NewsSchema.this.Bought = {
      Bought.super.this();
      ()
    };
    <synthetic> def copy(buyer: NewsSchema.this.P = buyer, stock: String = stock, shares: model.Shares = shares, dollars: model.Dollars = dollars, price: model.Price = price): NewsSchema.this.Bought = new NewsSchema.this.Bought(buyer, stock, shares, dollars, price);
    <synthetic> def copy$default$5: model.Price @scala.annotation.unchecked.uncheckedVariance = Bought.this.price;
    <synthetic> def copy$default$4: model.Dollars @scala.annotation.unchecked.uncheckedVariance = Bought.this.dollars;
    <synthetic> def copy$default$3: model.Shares @scala.annotation.unchecked.uncheckedVariance = Bought.this.shares;
    <synthetic> def copy$default$2: String @scala.annotation.unchecked.uncheckedVariance = Bought.this.stock;
    <synthetic> def copy$default$1: NewsSchema.this.P @scala.annotation.unchecked.uncheckedVariance = Bought.this.buyer;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(Bought.this);
    override def toString(): String = ScalaRunTime.this._toString(Bought.this);
    override def equals(x$1: Any): Boolean = Bought.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (buyer: NewsSchema.this.P, stock: String, shares: model.Shares, dollars: model.Dollars, price: model.Price)NewsSchema.this.Bought((buyer$1 @ _), (stock$1 @ _), (shares$1 @ _), (dollars$1 @ _), (price$1 @ _)) if buyer$1.==(buyer).&&(stock$1.==(stock)).&&(shares$1.==(shares)).&&(dollars$1.==(dollars)).&&(price$1.==(price)) => x$1.asInstanceOf[NewsSchema.this.Bought].canEqual(Bought.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "Bought";
    override def productArity: Int = 5;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => buyer
      case 1 => stock
      case 2 => shares
      case 3 => dollars
      case 4 => price
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[NewsSchema.this.Bought]()
  };
  final <synthetic> object Bought extends scala.runtime.AbstractFunction5[NewsSchema.this.P,String,model.Shares,model.Dollars,model.Price,NewsSchema.this.Bought] with ScalaObject with Serializable {
    def this(): object NewsSchema.this.Bought = {
      Bought.super.this();
      ()
    };
    final override def toString(): java.lang.String = "Bought";
    case <synthetic> def unapply(x$0: NewsSchema.this.Bought): Option[(NewsSchema.this.P, String, model.Shares, model.Dollars, model.Price)] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(NewsSchema.this.P, String, model.Shares, model.Dollars, model.Price)](new (NewsSchema.this.P, String, model.Shares, model.Dollars, model.Price)(x$0.buyer, x$0.stock, x$0.shares, x$0.dollars, x$0.price));
    case <synthetic> def apply(buyer: NewsSchema.this.P, stock: String, shares: model.Shares, dollars: model.Dollars, price: model.Price): NewsSchema.this.Bought = new NewsSchema.this.Bought(buyer, stock, shares, dollars, price)
  };
  @volatile <synthetic> private[this] var Bought$module: object NewsSchema.this.Bought = _;
  final <synthetic> <stable> def Bought: object NewsSchema.this.Bought = new object NewsSchema.this.Bought();
  case class Sold extends java.lang.Object with NewsSchema.this.Action with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val seller: NewsSchema.this.P = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def seller: NewsSchema.this.P = Sold.this.seller;
    <caseaccessor> <paramaccessor> private[this] val stock: String = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def stock: String = Sold.this.stock;
    <caseaccessor> <paramaccessor> private[this] val shares: model.Shares = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def shares: model.Shares = Sold.this.shares;
    <caseaccessor> <paramaccessor> private[this] val dollars: model.Dollars = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def dollars: model.Dollars = Sold.this.dollars;
    <caseaccessor> <paramaccessor> private[this] val price: model.Price = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def price: model.Price = Sold.this.price;
    def this(seller: NewsSchema.this.P, stock: String, shares: model.Shares, dollars: model.Dollars, price: model.Price): NewsSchema.this.Sold = {
      Sold.super.this();
      ()
    };
    <synthetic> def copy(seller: NewsSchema.this.P = seller, stock: String = stock, shares: model.Shares = shares, dollars: model.Dollars = dollars, price: model.Price = price): NewsSchema.this.Sold = new NewsSchema.this.Sold(seller, stock, shares, dollars, price);
    <synthetic> def copy$default$5: model.Price @scala.annotation.unchecked.uncheckedVariance = Sold.this.price;
    <synthetic> def copy$default$4: model.Dollars @scala.annotation.unchecked.uncheckedVariance = Sold.this.dollars;
    <synthetic> def copy$default$3: model.Shares @scala.annotation.unchecked.uncheckedVariance = Sold.this.shares;
    <synthetic> def copy$default$2: String @scala.annotation.unchecked.uncheckedVariance = Sold.this.stock;
    <synthetic> def copy$default$1: NewsSchema.this.P @scala.annotation.unchecked.uncheckedVariance = Sold.this.seller;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(Sold.this);
    override def toString(): String = ScalaRunTime.this._toString(Sold.this);
    override def equals(x$1: Any): Boolean = Sold.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (seller: NewsSchema.this.P, stock: String, shares: model.Shares, dollars: model.Dollars, price: model.Price)NewsSchema.this.Sold((seller$1 @ _), (stock$2 @ _), (shares$2 @ _), (dollars$2 @ _), (price$2 @ _)) if seller$1.==(seller).&&(stock$2.==(stock)).&&(shares$2.==(shares)).&&(dollars$2.==(dollars)).&&(price$2.==(price)) => x$1.asInstanceOf[NewsSchema.this.Sold].canEqual(Sold.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "Sold";
    override def productArity: Int = 5;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => seller
      case 1 => stock
      case 2 => shares
      case 3 => dollars
      case 4 => price
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[NewsSchema.this.Sold]()
  };
  final <synthetic> object Sold extends scala.runtime.AbstractFunction5[NewsSchema.this.P,String,model.Shares,model.Dollars,model.Price,NewsSchema.this.Sold] with ScalaObject with Serializable {
    def this(): object NewsSchema.this.Sold = {
      Sold.super.this();
      ()
    };
    final override def toString(): java.lang.String = "Sold";
    case <synthetic> def unapply(x$0: NewsSchema.this.Sold): Option[(NewsSchema.this.P, String, model.Shares, model.Dollars, model.Price)] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(NewsSchema.this.P, String, model.Shares, model.Dollars, model.Price)](new (NewsSchema.this.P, String, model.Shares, model.Dollars, model.Price)(x$0.seller, x$0.stock, x$0.shares, x$0.dollars, x$0.price));
    case <synthetic> def apply(seller: NewsSchema.this.P, stock: String, shares: model.Shares, dollars: model.Dollars, price: model.Price): NewsSchema.this.Sold = new NewsSchema.this.Sold(seller, stock, shares, dollars, price)
  };
  @volatile <synthetic> private[this] var Sold$module: object NewsSchema.this.Sold = _;
  final <synthetic> <stable> def Sold: object NewsSchema.this.Sold = new object NewsSchema.this.Sold();
  case class Offered extends java.lang.Object with NewsSchema.this.Action with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val from: NewsSchema.this.P = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def from: NewsSchema.this.P = Offered.this.from;
    <caseaccessor> <paramaccessor> private[this] val to: NewsSchema.this.P = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def to: NewsSchema.this.P = Offered.this.to;
    <caseaccessor> <paramaccessor> private[this] val derivative: model.Derivative = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def derivative: model.Derivative = Offered.this.derivative;
    <caseaccessor> <paramaccessor> private[this] val price: model.Dollars = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def price: model.Dollars = Offered.this.price;
    def this(from: NewsSchema.this.P, to: NewsSchema.this.P, derivative: model.Derivative, price: model.Dollars): NewsSchema.this.Offered = {
      Offered.super.this();
      ()
    };
    <synthetic> def copy(from: NewsSchema.this.P = from, to: NewsSchema.this.P = to, derivative: model.Derivative = derivative, price: model.Dollars = price): NewsSchema.this.Offered = new NewsSchema.this.Offered(from, to, derivative, price);
    <synthetic> def copy$default$4: model.Dollars @scala.annotation.unchecked.uncheckedVariance = Offered.this.price;
    <synthetic> def copy$default$3: model.Derivative @scala.annotation.unchecked.uncheckedVariance = Offered.this.derivative;
    <synthetic> def copy$default$2: NewsSchema.this.P @scala.annotation.unchecked.uncheckedVariance = Offered.this.to;
    <synthetic> def copy$default$1: NewsSchema.this.P @scala.annotation.unchecked.uncheckedVariance = Offered.this.from;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(Offered.this);
    override def toString(): String = ScalaRunTime.this._toString(Offered.this);
    override def equals(x$1: Any): Boolean = Offered.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (from: NewsSchema.this.P, to: NewsSchema.this.P, derivative: model.Derivative, price: model.Dollars)NewsSchema.this.Offered((from$1 @ _), (to$1 @ _), (derivative$1 @ _), (price$3 @ _)) if from$1.==(from).&&(to$1.==(to)).&&(derivative$1.==(derivative)).&&(price$3.==(price)) => x$1.asInstanceOf[NewsSchema.this.Offered].canEqual(Offered.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "Offered";
    override def productArity: Int = 4;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => from
      case 1 => to
      case 2 => derivative
      case 3 => price
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[NewsSchema.this.Offered]()
  };
  final <synthetic> object Offered extends scala.runtime.AbstractFunction4[NewsSchema.this.P,NewsSchema.this.P,model.Derivative,model.Dollars,NewsSchema.this.Offered] with ScalaObject with Serializable {
    def this(): object NewsSchema.this.Offered = {
      Offered.super.this();
      ()
    };
    final override def toString(): java.lang.String = "Offered";
    case <synthetic> def unapply(x$0: NewsSchema.this.Offered): Option[(NewsSchema.this.P, NewsSchema.this.P, model.Derivative, model.Dollars)] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(NewsSchema.this.P, NewsSchema.this.P, model.Derivative, model.Dollars)](new (NewsSchema.this.P, NewsSchema.this.P, model.Derivative, model.Dollars)(x$0.from, x$0.to, x$0.derivative, x$0.price));
    case <synthetic> def apply(from: NewsSchema.this.P, to: NewsSchema.this.P, derivative: model.Derivative, price: model.Dollars): NewsSchema.this.Offered = new NewsSchema.this.Offered(from, to, derivative, price)
  };
  @volatile <synthetic> private[this] var Offered$module: object NewsSchema.this.Offered = _;
  final <synthetic> <stable> def Offered: object NewsSchema.this.Offered = new object NewsSchema.this.Offered();
  case class Accepted extends java.lang.Object with NewsSchema.this.Action with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val from: NewsSchema.this.P = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def from: NewsSchema.this.P = Accepted.this.from;
    <caseaccessor> <paramaccessor> private[this] val to: NewsSchema.this.P = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def to: NewsSchema.this.P = Accepted.this.to;
    <caseaccessor> <paramaccessor> private[this] val derivative: model.Derivative = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def derivative: model.Derivative = Accepted.this.derivative;
    <caseaccessor> <paramaccessor> private[this] val price: model.Dollars = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def price: model.Dollars = Accepted.this.price;
    <caseaccessor> <paramaccessor> private[this] val buyerAside: model.Link[NewsSchema.this.DerivativeBuyerSetAside] = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def buyerAside: model.Link[NewsSchema.this.DerivativeBuyerSetAside] = Accepted.this.buyerAside;
    <caseaccessor> <paramaccessor> private[this] val sellerAside: model.Link[NewsSchema.this.DerivativeSellerSetAside] = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def sellerAside: model.Link[NewsSchema.this.DerivativeSellerSetAside] = Accepted.this.sellerAside;
    def this(from: NewsSchema.this.P, to: NewsSchema.this.P, derivative: model.Derivative, price: model.Dollars, buyerAside: model.Link[NewsSchema.this.DerivativeBuyerSetAside], sellerAside: model.Link[NewsSchema.this.DerivativeSellerSetAside]): NewsSchema.this.Accepted = {
      Accepted.super.this();
      ()
    };
    <synthetic> def copy(from: NewsSchema.this.P = from, to: NewsSchema.this.P = to, derivative: model.Derivative = derivative, price: model.Dollars = price, buyerAside: model.Link[NewsSchema.this.DerivativeBuyerSetAside] = buyerAside, sellerAside: model.Link[NewsSchema.this.DerivativeSellerSetAside] = sellerAside): NewsSchema.this.Accepted = new NewsSchema.this.Accepted(from, to, derivative, price, buyerAside, sellerAside);
    <synthetic> def copy$default$6: model.Link[NewsSchema.this.DerivativeSellerSetAside] @scala.annotation.unchecked.uncheckedVariance = Accepted.this.sellerAside;
    <synthetic> def copy$default$5: model.Link[NewsSchema.this.DerivativeBuyerSetAside] @scala.annotation.unchecked.uncheckedVariance = Accepted.this.buyerAside;
    <synthetic> def copy$default$4: model.Dollars @scala.annotation.unchecked.uncheckedVariance = Accepted.this.price;
    <synthetic> def copy$default$3: model.Derivative @scala.annotation.unchecked.uncheckedVariance = Accepted.this.derivative;
    <synthetic> def copy$default$2: NewsSchema.this.P @scala.annotation.unchecked.uncheckedVariance = Accepted.this.to;
    <synthetic> def copy$default$1: NewsSchema.this.P @scala.annotation.unchecked.uncheckedVariance = Accepted.this.from;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(Accepted.this);
    override def toString(): String = ScalaRunTime.this._toString(Accepted.this);
    override def equals(x$1: Any): Boolean = Accepted.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (from: NewsSchema.this.P, to: NewsSchema.this.P, derivative: model.Derivative, price: model.Dollars, buyerAside: model.Link[NewsSchema.this.DerivativeBuyerSetAside], sellerAside: model.Link[NewsSchema.this.DerivativeSellerSetAside])NewsSchema.this.Accepted((from$2 @ _), (to$2 @ _), (derivative$2 @ _), (price$4 @ _), (buyerAside$1 @ _), (sellerAside$1 @ _)) if from$2.==(from).&&(to$2.==(to)).&&(derivative$2.==(derivative)).&&(price$4.==(price)).&&(buyerAside$1.==(buyerAside)).&&(sellerAside$1.==(sellerAside)) => x$1.asInstanceOf[NewsSchema.this.Accepted].canEqual(Accepted.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "Accepted";
    override def productArity: Int = 6;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => from
      case 1 => to
      case 2 => derivative
      case 3 => price
      case 4 => buyerAside
      case 5 => sellerAside
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[NewsSchema.this.Accepted]()
  };
  final <synthetic> object Accepted extends scala.runtime.AbstractFunction6[NewsSchema.this.P,NewsSchema.this.P,model.Derivative,model.Dollars,model.Link[NewsSchema.this.DerivativeBuyerSetAside],model.Link[NewsSchema.this.DerivativeSellerSetAside],NewsSchema.this.Accepted] with ScalaObject with Serializable {
    def this(): object NewsSchema.this.Accepted = {
      Accepted.super.this();
      ()
    };
    final override def toString(): java.lang.String = "Accepted";
    case <synthetic> def unapply(x$0: NewsSchema.this.Accepted): Option[(NewsSchema.this.P, NewsSchema.this.P, model.Derivative, model.Dollars, model.Link[NewsSchema.this.DerivativeBuyerSetAside], model.Link[NewsSchema.this.DerivativeSellerSetAside])] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(NewsSchema.this.P, NewsSchema.this.P, model.Derivative, model.Dollars, model.Link[NewsSchema.this.DerivativeBuyerSetAside], model.Link[NewsSchema.this.DerivativeSellerSetAside])](new (NewsSchema.this.P, NewsSchema.this.P, model.Derivative, model.Dollars, model.Link[NewsSchema.this.DerivativeBuyerSetAside], model.Link[NewsSchema.this.DerivativeSellerSetAside])(x$0.from, x$0.to, x$0.derivative, x$0.price, x$0.buyerAside, x$0.sellerAside));
    case <synthetic> def apply(from: NewsSchema.this.P, to: NewsSchema.this.P, derivative: model.Derivative, price: model.Dollars, buyerAside: model.Link[NewsSchema.this.DerivativeBuyerSetAside], sellerAside: model.Link[NewsSchema.this.DerivativeSellerSetAside]): NewsSchema.this.Accepted = new NewsSchema.this.Accepted(from, to, derivative, price, buyerAside, sellerAside)
  };
  @volatile <synthetic> private[this] var Accepted$module: object NewsSchema.this.Accepted = _;
  final <synthetic> <stable> def Accepted: object NewsSchema.this.Accepted = new object NewsSchema.this.Accepted();
  case class Declined extends java.lang.Object with NewsSchema.this.Action with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val from: NewsSchema.this.P = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def from: NewsSchema.this.P = Declined.this.from;
    <caseaccessor> <paramaccessor> private[this] val to: NewsSchema.this.P = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def to: NewsSchema.this.P = Declined.this.to;
    <caseaccessor> <paramaccessor> private[this] val derivative: model.Derivative = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def derivative: model.Derivative = Declined.this.derivative;
    <caseaccessor> <paramaccessor> private[this] val price: model.Dollars = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def price: model.Dollars = Declined.this.price;
    def this(from: NewsSchema.this.P, to: NewsSchema.this.P, derivative: model.Derivative, price: model.Dollars): NewsSchema.this.Declined = {
      Declined.super.this();
      ()
    };
    <synthetic> def copy(from: NewsSchema.this.P = from, to: NewsSchema.this.P = to, derivative: model.Derivative = derivative, price: model.Dollars = price): NewsSchema.this.Declined = new NewsSchema.this.Declined(from, to, derivative, price);
    <synthetic> def copy$default$4: model.Dollars @scala.annotation.unchecked.uncheckedVariance = Declined.this.price;
    <synthetic> def copy$default$3: model.Derivative @scala.annotation.unchecked.uncheckedVariance = Declined.this.derivative;
    <synthetic> def copy$default$2: NewsSchema.this.P @scala.annotation.unchecked.uncheckedVariance = Declined.this.to;
    <synthetic> def copy$default$1: NewsSchema.this.P @scala.annotation.unchecked.uncheckedVariance = Declined.this.from;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(Declined.this);
    override def toString(): String = ScalaRunTime.this._toString(Declined.this);
    override def equals(x$1: Any): Boolean = Declined.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (from: NewsSchema.this.P, to: NewsSchema.this.P, derivative: model.Derivative, price: model.Dollars)NewsSchema.this.Declined((from$3 @ _), (to$3 @ _), (derivative$3 @ _), (price$5 @ _)) if from$3.==(from).&&(to$3.==(to)).&&(derivative$3.==(derivative)).&&(price$5.==(price)) => x$1.asInstanceOf[NewsSchema.this.Declined].canEqual(Declined.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "Declined";
    override def productArity: Int = 4;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => from
      case 1 => to
      case 2 => derivative
      case 3 => price
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[NewsSchema.this.Declined]()
  };
  final <synthetic> object Declined extends scala.runtime.AbstractFunction4[NewsSchema.this.P,NewsSchema.this.P,model.Derivative,model.Dollars,NewsSchema.this.Declined] with ScalaObject with Serializable {
    def this(): object NewsSchema.this.Declined = {
      Declined.super.this();
      ()
    };
    final override def toString(): java.lang.String = "Declined";
    case <synthetic> def unapply(x$0: NewsSchema.this.Declined): Option[(NewsSchema.this.P, NewsSchema.this.P, model.Derivative, model.Dollars)] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(NewsSchema.this.P, NewsSchema.this.P, model.Derivative, model.Dollars)](new (NewsSchema.this.P, NewsSchema.this.P, model.Derivative, model.Dollars)(x$0.from, x$0.to, x$0.derivative, x$0.price));
    case <synthetic> def apply(from: NewsSchema.this.P, to: NewsSchema.this.P, derivative: model.Derivative, price: model.Dollars): NewsSchema.this.Declined = new NewsSchema.this.Declined(from, to, derivative, price)
  };
  @volatile <synthetic> private[this] var Declined$module: object NewsSchema.this.Declined = _;
  final <synthetic> <stable> def Declined: object NewsSchema.this.Declined = new object NewsSchema.this.Declined();
  case class Auctioned extends java.lang.Object with NewsSchema.this.Action with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val from: NewsSchema.this.P = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def from: NewsSchema.this.P = Auctioned.this.from;
    <caseaccessor> <paramaccessor> private[this] val derivative: model.Derivative = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def derivative: model.Derivative = Auctioned.this.derivative;
    <caseaccessor> <paramaccessor> private[this] val price: model.Dollars = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def price: model.Dollars = Auctioned.this.price;
    def this(from: NewsSchema.this.P, derivative: model.Derivative, price: model.Dollars): NewsSchema.this.Auctioned = {
      Auctioned.super.this();
      ()
    };
    <synthetic> def copy(from: NewsSchema.this.P = from, derivative: model.Derivative = derivative, price: model.Dollars = price): NewsSchema.this.Auctioned = new NewsSchema.this.Auctioned(from, derivative, price);
    <synthetic> def copy$default$3: model.Dollars @scala.annotation.unchecked.uncheckedVariance = Auctioned.this.price;
    <synthetic> def copy$default$2: model.Derivative @scala.annotation.unchecked.uncheckedVariance = Auctioned.this.derivative;
    <synthetic> def copy$default$1: NewsSchema.this.P @scala.annotation.unchecked.uncheckedVariance = Auctioned.this.from;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(Auctioned.this);
    override def toString(): String = ScalaRunTime.this._toString(Auctioned.this);
    override def equals(x$1: Any): Boolean = Auctioned.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (from: NewsSchema.this.P, derivative: model.Derivative, price: model.Dollars)NewsSchema.this.Auctioned((from$4 @ _), (derivative$4 @ _), (price$6 @ _)) if from$4.==(from).&&(derivative$4.==(derivative)).&&(price$6.==(price)) => x$1.asInstanceOf[NewsSchema.this.Auctioned].canEqual(Auctioned.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "Auctioned";
    override def productArity: Int = 3;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => from
      case 1 => derivative
      case 2 => price
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[NewsSchema.this.Auctioned]()
  };
  final <synthetic> object Auctioned extends scala.runtime.AbstractFunction3[NewsSchema.this.P,model.Derivative,model.Dollars,NewsSchema.this.Auctioned] with ScalaObject with Serializable {
    def this(): object NewsSchema.this.Auctioned = {
      Auctioned.super.this();
      ()
    };
    final override def toString(): java.lang.String = "Auctioned";
    case <synthetic> def unapply(x$0: NewsSchema.this.Auctioned): Option[(NewsSchema.this.P, model.Derivative, model.Dollars)] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(NewsSchema.this.P, model.Derivative, model.Dollars)](new (NewsSchema.this.P, model.Derivative, model.Dollars)(x$0.from, x$0.derivative, x$0.price));
    case <synthetic> def apply(from: NewsSchema.this.P, derivative: model.Derivative, price: model.Dollars): NewsSchema.this.Auctioned = new NewsSchema.this.Auctioned(from, derivative, price)
  };
  @volatile <synthetic> private[this] var Auctioned$module: object NewsSchema.this.Auctioned = _;
  final <synthetic> <stable> def Auctioned: object NewsSchema.this.Auctioned = new object NewsSchema.this.Auctioned();
  case class Bid extends java.lang.Object with NewsSchema.this.Action with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val from: NewsSchema.this.P = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def from: NewsSchema.this.P = Bid.this.from;
    <caseaccessor> <paramaccessor> private[this] val on: NewsSchema.this.AuctionOffer = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def on: NewsSchema.this.AuctionOffer = Bid.this.on;
    <caseaccessor> <paramaccessor> private[this] val price: model.Dollars = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def price: model.Dollars = Bid.this.price;
    def this(from: NewsSchema.this.P, on: NewsSchema.this.AuctionOffer, price: model.Dollars): NewsSchema.this.Bid = {
      Bid.super.this();
      ()
    };
    <synthetic> def copy(from: NewsSchema.this.P = from, on: NewsSchema.this.AuctionOffer = on, price: model.Dollars = price): NewsSchema.this.Bid = new NewsSchema.this.Bid(from, on, price);
    <synthetic> def copy$default$3: model.Dollars @scala.annotation.unchecked.uncheckedVariance = Bid.this.price;
    <synthetic> def copy$default$2: NewsSchema.this.AuctionOffer @scala.annotation.unchecked.uncheckedVariance = Bid.this.on;
    <synthetic> def copy$default$1: NewsSchema.this.P @scala.annotation.unchecked.uncheckedVariance = Bid.this.from;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(Bid.this);
    override def toString(): String = ScalaRunTime.this._toString(Bid.this);
    override def equals(x$1: Any): Boolean = Bid.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (from: NewsSchema.this.P, on: NewsSchema.this.AuctionOffer, price: model.Dollars)NewsSchema.this.Bid((from$5 @ _), (on$1 @ _), (price$7 @ _)) if from$5.==(from).&&(on$1.==(on)).&&(price$7.==(price)) => x$1.asInstanceOf[NewsSchema.this.Bid].canEqual(Bid.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "Bid";
    override def productArity: Int = 3;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => from
      case 1 => on
      case 2 => price
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[NewsSchema.this.Bid]()
  };
  final <synthetic> object Bid extends scala.runtime.AbstractFunction3[NewsSchema.this.P,NewsSchema.this.AuctionOffer,model.Dollars,NewsSchema.this.Bid] with ScalaObject with Serializable {
    def this(): object NewsSchema.this.Bid = {
      Bid.super.this();
      ()
    };
    final override def toString(): java.lang.String = "Bid";
    case <synthetic> def unapply(x$0: NewsSchema.this.Bid): Option[(NewsSchema.this.P, NewsSchema.this.AuctionOffer, model.Dollars)] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(NewsSchema.this.P, NewsSchema.this.AuctionOffer, model.Dollars)](new (NewsSchema.this.P, NewsSchema.this.AuctionOffer, model.Dollars)(x$0.from, x$0.on, x$0.price));
    case <synthetic> def apply(from: NewsSchema.this.P, on: NewsSchema.this.AuctionOffer, price: model.Dollars): NewsSchema.this.Bid = new NewsSchema.this.Bid(from, on, price)
  };
  @volatile <synthetic> private[this] var Bid$module: object NewsSchema.this.Bid = _;
  final <synthetic> <stable> def Bid: object NewsSchema.this.Bid = new object NewsSchema.this.Bid();
  case class Won extends java.lang.Object with NewsSchema.this.Action with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val buyer: NewsSchema.this.P = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def buyer: NewsSchema.this.P = Won.this.buyer;
    <caseaccessor> <paramaccessor> private[this] val seller: NewsSchema.this.P = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def seller: NewsSchema.this.P = Won.this.seller;
    <caseaccessor> <paramaccessor> private[this] val derivative: model.Derivative = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def derivative: model.Derivative = Won.this.derivative;
    <caseaccessor> <paramaccessor> private[this] val buyerAside: model.Link[NewsSchema.this.BSA] = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def buyerAside: model.Link[NewsSchema.this.BSA] = Won.this.buyerAside;
    <caseaccessor> <paramaccessor> private[this] val sellerAside: model.Link[NewsSchema.this.SSA] = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def sellerAside: model.Link[NewsSchema.this.SSA] = Won.this.sellerAside;
    def this(buyer: NewsSchema.this.P, seller: NewsSchema.this.P, derivative: model.Derivative, buyerAside: model.Link[NewsSchema.this.BSA], sellerAside: model.Link[NewsSchema.this.SSA]): NewsSchema.this.Won = {
      Won.super.this();
      ()
    };
    <synthetic> def copy(buyer: NewsSchema.this.P = buyer, seller: NewsSchema.this.P = seller, derivative: model.Derivative = derivative, buyerAside: model.Link[NewsSchema.this.BSA] = buyerAside, sellerAside: model.Link[NewsSchema.this.SSA] = sellerAside): NewsSchema.this.Won = new NewsSchema.this.Won(buyer, seller, derivative, buyerAside, sellerAside);
    <synthetic> def copy$default$5: model.Link[NewsSchema.this.SSA] @scala.annotation.unchecked.uncheckedVariance = Won.this.sellerAside;
    <synthetic> def copy$default$4: model.Link[NewsSchema.this.BSA] @scala.annotation.unchecked.uncheckedVariance = Won.this.buyerAside;
    <synthetic> def copy$default$3: model.Derivative @scala.annotation.unchecked.uncheckedVariance = Won.this.derivative;
    <synthetic> def copy$default$2: NewsSchema.this.P @scala.annotation.unchecked.uncheckedVariance = Won.this.seller;
    <synthetic> def copy$default$1: NewsSchema.this.P @scala.annotation.unchecked.uncheckedVariance = Won.this.buyer;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(Won.this);
    override def toString(): String = ScalaRunTime.this._toString(Won.this);
    override def equals(x$1: Any): Boolean = Won.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (buyer: NewsSchema.this.P, seller: NewsSchema.this.P, derivative: model.Derivative, buyerAside: model.Link[NewsSchema.this.BSA], sellerAside: model.Link[NewsSchema.this.SSA])NewsSchema.this.Won((buyer$2 @ _), (seller$2 @ _), (derivative$5 @ _), (buyerAside$2 @ _), (sellerAside$2 @ _)) if buyer$2.==(buyer).&&(seller$2.==(seller)).&&(derivative$5.==(derivative)).&&(buyerAside$2.==(buyerAside)).&&(sellerAside$2.==(sellerAside)) => x$1.asInstanceOf[NewsSchema.this.Won].canEqual(Won.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "Won";
    override def productArity: Int = 5;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => buyer
      case 1 => seller
      case 2 => derivative
      case 3 => buyerAside
      case 4 => sellerAside
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[NewsSchema.this.Won]()
  };
  final <synthetic> object Won extends scala.runtime.AbstractFunction5[NewsSchema.this.P,NewsSchema.this.P,model.Derivative,model.Link[NewsSchema.this.BSA],model.Link[NewsSchema.this.SSA],NewsSchema.this.Won] with ScalaObject with Serializable {
    def this(): object NewsSchema.this.Won = {
      Won.super.this();
      ()
    };
    final override def toString(): java.lang.String = "Won";
    case <synthetic> def unapply(x$0: NewsSchema.this.Won): Option[(NewsSchema.this.P, NewsSchema.this.P, model.Derivative, model.Link[NewsSchema.this.BSA], model.Link[NewsSchema.this.SSA])] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(NewsSchema.this.P, NewsSchema.this.P, model.Derivative, model.Link[NewsSchema.this.BSA], model.Link[NewsSchema.this.SSA])](new (NewsSchema.this.P, NewsSchema.this.P, model.Derivative, model.Link[NewsSchema.this.BSA], model.Link[NewsSchema.this.SSA])(x$0.buyer, x$0.seller, x$0.derivative, x$0.buyerAside, x$0.sellerAside));
    case <synthetic> def apply(buyer: NewsSchema.this.P, seller: NewsSchema.this.P, derivative: model.Derivative, buyerAside: model.Link[NewsSchema.this.BSA], sellerAside: model.Link[NewsSchema.this.SSA]): NewsSchema.this.Won = new NewsSchema.this.Won(buyer, seller, derivative, buyerAside, sellerAside)
  };
  @volatile <synthetic> private[this] var Won$module: object NewsSchema.this.Won = _;
  final <synthetic> <stable> def Won: object NewsSchema.this.Won = new object NewsSchema.this.Won();
  case class Closed extends java.lang.Object with NewsSchema.this.Action with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val offerer: NewsSchema.this.P = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def offerer: NewsSchema.this.P = Closed.this.offerer;
    <caseaccessor> <paramaccessor> private[this] val offer: NewsSchema.this.AuctionOffer = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def offer: NewsSchema.this.AuctionOffer = Closed.this.offer;
    def this(offerer: NewsSchema.this.P, offer: NewsSchema.this.AuctionOffer): NewsSchema.this.Closed = {
      Closed.super.this();
      ()
    };
    <synthetic> def copy(offerer: NewsSchema.this.P = offerer, offer: NewsSchema.this.AuctionOffer = offer): NewsSchema.this.Closed = new NewsSchema.this.Closed(offerer, offer);
    <synthetic> def copy$default$2: NewsSchema.this.AuctionOffer @scala.annotation.unchecked.uncheckedVariance = Closed.this.offer;
    <synthetic> def copy$default$1: NewsSchema.this.P @scala.annotation.unchecked.uncheckedVariance = Closed.this.offerer;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(Closed.this);
    override def toString(): String = ScalaRunTime.this._toString(Closed.this);
    override def equals(x$1: Any): Boolean = Closed.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (offerer: NewsSchema.this.P, offer: NewsSchema.this.AuctionOffer)NewsSchema.this.Closed((offerer$1 @ _), (offer$1 @ _)) if offerer$1.==(offerer).&&(offer$1.==(offer)) => x$1.asInstanceOf[NewsSchema.this.Closed].canEqual(Closed.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "Closed";
    override def productArity: Int = 2;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => offerer
      case 1 => offer
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[NewsSchema.this.Closed]()
  };
  final <synthetic> object Closed extends scala.runtime.AbstractFunction2[NewsSchema.this.P,NewsSchema.this.AuctionOffer,NewsSchema.this.Closed] with ScalaObject with Serializable {
    def this(): object NewsSchema.this.Closed = {
      Closed.super.this();
      ()
    };
    final override def toString(): java.lang.String = "Closed";
    case <synthetic> def unapply(x$0: NewsSchema.this.Closed): Option[(NewsSchema.this.P, NewsSchema.this.AuctionOffer)] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(NewsSchema.this.P, NewsSchema.this.AuctionOffer)](new (NewsSchema.this.P, NewsSchema.this.AuctionOffer)(x$0.offerer, x$0.offer));
    case <synthetic> def apply(offerer: NewsSchema.this.P, offer: NewsSchema.this.AuctionOffer): NewsSchema.this.Closed = new NewsSchema.this.Closed(offerer, offer)
  };
  @volatile <synthetic> private[this] var Closed$module: object NewsSchema.this.Closed = _;
  final <synthetic> <stable> def Closed: object NewsSchema.this.Closed = new object NewsSchema.this.Closed();
  case class Exercised extends java.lang.Object with NewsSchema.this.Action with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val user: NewsSchema.this.P = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def user: NewsSchema.this.P = Exercised.this.user;
    <caseaccessor> <paramaccessor> private[this] val derivative: model.Derivative = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def derivative: model.Derivative = Exercised.this.derivative;
    def this(user: NewsSchema.this.P, derivative: model.Derivative): NewsSchema.this.Exercised = {
      Exercised.super.this();
      ()
    };
    <synthetic> def copy(user: NewsSchema.this.P = user, derivative: model.Derivative = derivative): NewsSchema.this.Exercised = new NewsSchema.this.Exercised(user, derivative);
    <synthetic> def copy$default$2: model.Derivative @scala.annotation.unchecked.uncheckedVariance = Exercised.this.derivative;
    <synthetic> def copy$default$1: NewsSchema.this.P @scala.annotation.unchecked.uncheckedVariance = Exercised.this.user;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(Exercised.this);
    override def toString(): String = ScalaRunTime.this._toString(Exercised.this);
    override def equals(x$1: Any): Boolean = Exercised.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (user: NewsSchema.this.P, derivative: model.Derivative)NewsSchema.this.Exercised((user$1 @ _), (derivative$6 @ _)) if user$1.==(user).&&(derivative$6.==(derivative)) => x$1.asInstanceOf[NewsSchema.this.Exercised].canEqual(Exercised.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "Exercised";
    override def productArity: Int = 2;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => user
      case 1 => derivative
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[NewsSchema.this.Exercised]()
  };
  final <synthetic> object Exercised extends scala.runtime.AbstractFunction2[NewsSchema.this.P,model.Derivative,NewsSchema.this.Exercised] with ScalaObject with Serializable {
    def this(): object NewsSchema.this.Exercised = {
      Exercised.super.this();
      ()
    };
    final override def toString(): java.lang.String = "Exercised";
    case <synthetic> def unapply(x$0: NewsSchema.this.Exercised): Option[(NewsSchema.this.P, model.Derivative)] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(NewsSchema.this.P, model.Derivative)](new (NewsSchema.this.P, model.Derivative)(x$0.user, x$0.derivative));
    case <synthetic> def apply(user: NewsSchema.this.P, derivative: model.Derivative): NewsSchema.this.Exercised = new NewsSchema.this.Exercised(user, derivative)
  };
  @volatile <synthetic> private[this] var Exercised$module: object NewsSchema.this.Exercised = _;
  final <synthetic> <stable> def Exercised: object NewsSchema.this.Exercised = new object NewsSchema.this.Exercised();
  case class NewsEvent extends java.lang.Object with model.KL with NewsSchema.this.NewsEventWithComments with NewsSchema.this.NewsEventWithVotes with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val id: model.package.Key = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def id: model.package.Key = NewsEvent.this.id;
    <caseaccessor> <paramaccessor> private[this] val when: org.joda.time.DateTime = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def when: org.joda.time.DateTime = NewsEvent.this.when;
    <caseaccessor> <paramaccessor> private[this] val action: NewsSchema.this.Action = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def action: NewsSchema.this.Action = NewsEvent.this.action;
    def this(id: model.package.Key = model.this.`package`.nextID, when: org.joda.time.DateTime, action: NewsSchema.this.Action): NewsSchema.this.NewsEvent = {
      NewsEvent.super.this();
      ()
    };
    <synthetic> def copy(id: model.package.Key = id, when: org.joda.time.DateTime = when, action: NewsSchema.this.Action = action): NewsSchema.this.NewsEvent = new NewsSchema.this.NewsEvent(id, when, action);
    <synthetic> def copy$default$3: NewsSchema.this.Action @scala.annotation.unchecked.uncheckedVariance = NewsEvent.this.action;
    <synthetic> def copy$default$2: org.joda.time.DateTime @scala.annotation.unchecked.uncheckedVariance = NewsEvent.this.when;
    <synthetic> def copy$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = NewsEvent.this.id;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(NewsEvent.this);
    override def toString(): String = ScalaRunTime.this._toString(NewsEvent.this);
    override def equals(x$1: Any): Boolean = NewsEvent.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (id: model.package.Key, when: org.joda.time.DateTime, action: NewsSchema.this.Action)NewsSchema.this.NewsEvent((id$1 @ _), (when$1 @ _), (action$1 @ _)) if id$1.==(id).&&(when$1.==(when)).&&(action$1.==(action)) => x$1.asInstanceOf[NewsSchema.this.NewsEvent].canEqual(NewsEvent.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "NewsEvent";
    override def productArity: Int = 3;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => id
      case 1 => when
      case 2 => action
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[NewsSchema.this.NewsEvent]()
  };
  final object NewsEvent extends java.lang.Object with ScalaObject with Serializable {
    def this(): object NewsSchema.this.NewsEvent = {
      NewsEvent.super.this();
      ()
    };
    def byID(id: model.package.Key): NewsSchema.this.NewsEvent = NewsSchema.this.newsEvents.lookup(id).getOrElse[NewsSchema.this.NewsEvent](throw NewsSchema.this.NoSuchEvent);
    <synthetic> def init$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
    <synthetic> def apply$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
    case <synthetic> def unapply(x$0: NewsSchema.this.NewsEvent): Option[(model.package.Key, org.joda.time.DateTime, NewsSchema.this.Action)] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(model.package.Key, org.joda.time.DateTime, NewsSchema.this.Action)](new (model.package.Key, org.joda.time.DateTime, NewsSchema.this.Action)(x$0.id, x$0.when, x$0.action));
    case <synthetic> def apply(id: model.package.Key = model.this.`package`.nextID, when: org.joda.time.DateTime, action: NewsSchema.this.Action): NewsSchema.this.NewsEvent = new NewsSchema.this.NewsEvent(id, when, action)
  };
  @volatile <synthetic> private[this] var NewsEvent$module: object NewsSchema.this.NewsEvent = _;
  final <stable> def NewsEvent: object NewsSchema.this.NewsEvent = new object NewsSchema.this.NewsEvent();
  def recentEvents(n: Int): List[NewsSchema.this.NewsEvent] = NewsSchema.this.newsEvents.sortBy[Long](((x$1: NewsSchema.this.NewsEvent) => x$1.when.getMillis().unary_-))(math.this.Ordering.Long).take(n).toList;
  protected[model] def reportEvent(action: NewsSchema.this.Action): NewsSchema.this.Transaction[NewsSchema.this.NewsEvent] = NewsSchema.this.toOps[NewsSchema.this.NewsEvent]({
  val x$2: org.joda.time.DateTime = new org.joda.time.DateTime();
  val x$3: NewsSchema.this.Action = action;
  val x$4: model.package.Key = NewsSchema.this.NewsEvent.apply$default$1;
  new NewsSchema.this.NewsEvent(x$4, x$2, x$3)
}).insert(NewsSchema.this.newsEvents)
}
NewsSchema: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.333
         recentE reportE NewsEve
 Exercis                        
 Bought$                        
 Auction                        
 Accepte                        
 Offered                        
 Won$mod                        
 NewsEve                        
 Closed$                        
 Bid$mod                        
 Decline                        
 Sold$mo                        

final object Checker extends java.lang.Object with net.liftweb.common.Loggable with ScalaObject {
  def this(): object code.control.Checker = {
    Checker.super.this();
    ()
  };
  def run(): Unit = periodically.apply(liftweb.this.util.Helpers.intToTimeSpanBuilder(30).minutes)(Checker.this.runChecks());
  def runChecks(): Unit = {
    Checker.this.logger.info("Running the derivative checker...");
    model.schema.systemCheckForExercise();
    Checker.this.logger.info("Running the auction checker...");
    model.schema.systemCheckForAuctionClosings();
    Checker.this.logger.info("Updating the rankings...");
    model.schema.systemRecalculateRankings();
    Checker.this.logger.info("Checking for dividends");
    {
      model.schema.systemCheckForDividends();
      ()
    }
  }
}
Checker: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=1.000
         runChec     run

case class EventComment extends java.lang.Object with model.KL with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val id: model.package.Key = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def id: model.package.Key = EventComment.this.id;
  <caseaccessor> <paramaccessor> private[this] val event: CommentSchema.this.NewsEvent = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def event: CommentSchema.this.NewsEvent = EventComment.this.event;
  <caseaccessor> <paramaccessor> private[this] val by: CommentSchema.this.User = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def by: CommentSchema.this.User = EventComment.this.by;
  <caseaccessor> <paramaccessor> private[this] val text: String = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def text: String = EventComment.this.text;
  <caseaccessor> <paramaccessor> private[this] val when: org.joda.time.DateTime = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def when: org.joda.time.DateTime = EventComment.this.when;
  def this(id: model.package.Key = model.this.`package`.nextID, event: CommentSchema.this.NewsEvent, by: CommentSchema.this.User, text: String, when: org.joda.time.DateTime): CommentSchema.this.EventComment = {
    EventComment.super.this();
    ()
  };
  <synthetic> def copy(id: model.package.Key = id, event: CommentSchema.this.NewsEvent = event, by: CommentSchema.this.User = by, text: String = text, when: org.joda.time.DateTime = when): CommentSchema.this.EventComment = new CommentSchema.this.EventComment(id, event, by, text, when);
  <synthetic> def copy$default$5: org.joda.time.DateTime @scala.annotation.unchecked.uncheckedVariance = EventComment.this.when;
  <synthetic> def copy$default$4: String @scala.annotation.unchecked.uncheckedVariance = EventComment.this.text;
  <synthetic> def copy$default$3: CommentSchema.this.User @scala.annotation.unchecked.uncheckedVariance = EventComment.this.by;
  <synthetic> def copy$default$2: CommentSchema.this.NewsEvent @scala.annotation.unchecked.uncheckedVariance = EventComment.this.event;
  <synthetic> def copy$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = EventComment.this.id;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(EventComment.this);
  override def toString(): String = ScalaRunTime.this._toString(EventComment.this);
  override def equals(x$1: Any): Boolean = EventComment.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (id: model.package.Key, event: CommentSchema.this.NewsEvent, by: CommentSchema.this.User, text: String, when: org.joda.time.DateTime)CommentSchema.this.EventComment((id$1 @ _), (event$1 @ _), (by$1 @ _), (text$1 @ _), (when$1 @ _)) if id$1.==(id).&&(event$1.==(event)).&&(by$1.==(by)).&&(text$1.==(text)).&&(when$1.==(when)) => x$1.asInstanceOf[CommentSchema.this.EventComment].canEqual(EventComment.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "EventComment";
  override def productArity: Int = 5;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => id
    case 1 => event
    case 2 => by
    case 3 => text
    case 4 => when
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[CommentSchema.this.EventComment]()
}
EventComment: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
    when
      id
    text
      by
   event

case class Scale extends java.lang.Object with Ordered[model.Scale] with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val scale: scala.math.BigDecimal = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def scale: scala.math.BigDecimal = Scale.this.scale;
  def this(scale: scala.math.BigDecimal): model.Scale = {
    Scale.super.this();
    ()
  };
  def +(other: model.Scale): model.Scale = new model.Scale(Scale.this.scale.+(other.scale));
  def -(other: model.Scale): model.Scale = new model.Scale(Scale.this.scale.-(other.scale));
  def *(dollars: model.Dollars): model.Dollars = new model.Dollars(Scale.this.scale.*(dollars.dollars));
  def *(price: model.Price): model.Price = new model.Price(Scale.this.scale.*(price.price));
  def *(shares: model.Shares): model.Shares = new model.Shares(Scale.this.scale.*(shares.shares));
  def *(other: model.Scale): model.Scale = new model.Scale(Scale.this.scale.*(other.scale));
  def unary_-: model.Scale = Scale.this.copy(Scale.this.scale.unary_-);
  def compare(other: model.Scale): Int = Scale.this.scale.compare(other.scale);
  def %(): String = scala.this.Predef.augmentString("%.0f%%").format(Scale.this.scale.doubleValue().*(100));
  <synthetic> def copy$default$1: scala.math.BigDecimal @scala.annotation.unchecked.uncheckedVariance = Scale.this.scale;
  <synthetic> def copy(scale: scala.math.BigDecimal = scale): model.Scale = new model.this.Scale(scale);
  override def hashCode(): Int = ScalaRunTime.this._hashCode(Scale.this);
  override def toString(): String = ScalaRunTime.this._toString(Scale.this);
  override def equals(x$1: Any): Boolean = Scale.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (scale: scala.math.BigDecimal)model.Scale((scale$1 @ _)) if scale$1.==(scale) => x$1.asInstanceOf[model.Scale].canEqual(Scale.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "Scale";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => scale
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[model.Scale]()
}
Scale: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=0.194
          $times unary_$  $minus $percen  $times  $times compare   $plus  $times
   scale     X       X       X       X       X       X       X       X       X  

final object PriceField extends java.lang.Object with ScalaObject {
  def this(): object code.snippet.PriceField = {
    PriceField.super.this();
    ()
  };
  def apply(i: String = ""): code.snippet.PriceField = new PriceField(i);
  <synthetic> def apply$default$1: String @scala.annotation.unchecked.uncheckedVariance = ""
}
PriceField: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
           apply

final object EmailActor extends java.lang.Object with scala.actors.Actor with ScalaObject {
  def this(): object email.EmailActor = {
    EmailActor.super.this();
    ()
  };
  def act(): Unit = while$1(){
    EmailActor.this.receive[Unit](((x0$1: Any) => x0$1 match {
      case (_1: Any, _2: Any, _3: Any)(Any, Any, Any)((to @ (_: String)), (subject @ (_: String)), (body @ (_: String))) => Email_bg.send_email(to, subject, body)
    }));
    while$1()
  };
  protected def readResolve(): java.lang.Object = email.this.EmailActor
}
EmailActor: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=1.000
             act readRes

final object periodically extends java.lang.Object with ScalaObject {
  def this(): object code.control.periodically = {
    periodically.super.this();
    ()
  };
  def apply(delay: net.liftweb.util.Helpers.TimeSpan)(command: => Unit): Unit = {
    val actor: java.lang.Object with net.liftweb.actor.LiftActor = {
      final class $anon extends java.lang.Object with net.liftweb.actor.LiftActor {
        def this(): anonymous class $anon = {
          $anon.super.this();
          ()
        };
        def messageHandler: PartialFunction[Any,Unit] = ((x0$1: Any) => x0$1 match {
          case _ => {
            net.liftweb.util.Schedule.schedule[Symbol](this, scala.Symbol.apply("yo"), delay);
            command
          }
        })
      };
      new $anon()
    };
    {
      net.liftweb.util.Schedule.schedule[Symbol](actor, scala.Symbol.apply("yo"), delay);
      ()
    }
  }
}
periodically: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
           apply

sealed abstract trait Action extends java.lang.Object with ScalaObject {
  def /*Action*/$init$(): Unit = {
    ()
  };
  protected[model] def report(): NewsSchema.this.Transaction[NewsSchema.this.NewsEvent] = NewsSchema.this.reportEvent(this)
}
Action: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
          report

class DerivativeBuilder extends java.lang.Object with intform.Page with net.liftweb.common.Loggable with ScalaObject {
  def this(): code.snippet.DerivativeBuilder = {
    DerivativeBuilder.super.this();
    ()
  };
  private[this] val formatter: org.joda.time.format.DateTimeFormatter = org.joda.time.format.DateTimeFormat.forPattern("MM/dd/yyyy");
  private <stable> <accessor> def formatter: org.joda.time.format.DateTimeFormatter = DerivativeBuilder.this.formatter;
  private[this] var listeners: List[Option[stockdata.Quote] => net.liftweb.http.js.JsCmd] = immutable.this.Nil;
  private <accessor> def listeners: List[Option[stockdata.Quote] => net.liftweb.http.js.JsCmd] = DerivativeBuilder.this.listeners;
  private <accessor> def listeners_=(x$1: List[Option[stockdata.Quote] => net.liftweb.http.js.JsCmd]): Unit = DerivativeBuilder.this.listeners = x$1;
  private[this] var active: Boolean = false;
  private <accessor> def active: Boolean = DerivativeBuilder.this.active;
  private <accessor> def active_=(x$1: Boolean): Unit = DerivativeBuilder.this.active = x$1;
  private[this] val refreshable: intform.Refreshable.NeedRenderable with intform.Refreshable = intform.Refreshable.apply(if (DerivativeBuilder.this.active)
    DerivativeBuilder.this.form.render
  else
    xml.this.NodeSeq.seqToNodeSeq(immutable.this.Nil));
  private <stable> <accessor> def refreshable: intform.Refreshable.NeedRenderable with intform.Refreshable = DerivativeBuilder.this.refreshable;
  implicit def toDate(str: String): java.lang.Object{def toDate: org.joda.time.DateTime} = {
    final class $anon extends scala.AnyRef {
      def this(): anonymous class $anon = {
        $anon.super.this();
        ()
      };
      def toDate: org.joda.time.DateTime = DerivativeBuilder.this.formatter.parseDateTime(str)
    };
    new $anon()
  };
  implicit def toDollars(number: Option[model.Dollars]): java.lang.Object{def $: String} = {
    final class $anon extends scala.AnyRef {
      def this(): anonymous class $anon = {
        $anon.super.this();
        ()
      };
      def $: String = number.map[String](((x$1: model.Dollars) => x$1.$)).getOrElse[String]("n/a")
    };
    new $anon()
  };
  def directionToLabel(d: code.snippet.Direction): java.lang.String = d match {
    case ToBuyer => "To Buyer"
    case ToSeller => "To Seller"
  };
  lazy private[this] var form: intform.Form[code.snippet.DerivativeOrder] = _;
  <stable> <accessor> lazy def form: intform.Form[code.snippet.DerivativeOrder] = {
    DerivativeBuilder.this.form = intform.Form.apply[code.snippet.DerivativeOrder, up.HList.:+:[code.snippet.Recipient,up.HList.:+:[model.Dollars,up.HList.:+:[org.joda.time.DateTime,up.HList.:+:[model.Dollars,up.HList.:+:[code.snippet.Direction,up.HList.:+:[Seq[code.snippet.StockInDerivative],up.HList.:+:[model.Condition,up.HList.:+:[Boolean,up.HNil]]]]]]]]](intform.`package`.hlistify8[code.snippet.Recipient, model.Dollars, org.joda.time.DateTime, model.Dollars, code.snippet.Direction, Seq[code.snippet.StockInDerivative], model.Condition, Boolean, code.snippet.DerivativeOrder](((rec: code.snippet.Recipient, price: model.Dollars, exp: org.joda.time.DateTime, strike: model.Dollars, cashDir: code.snippet.Direction, stocks: Seq[code.snippet.StockInDerivative], cond: model.Condition, early: Boolean) => {
      val x$9: code.snippet.Recipient = rec;
      val x$10: model.Dollars = price;
      val x$11: Seq[code.snippet.StockInDerivative] = stocks;
      val x$12: org.joda.time.DateTime = exp;
      val x$13: model.Dollars = cashDir.sign(strike);
      val x$14: model.Condition = cond;
      val x$15: Boolean = early;
      new code.snippet.DerivativeOrder(x$9, x$11, x$12, x$10, x$13, x$14, x$15)
    })), intform.`package`.klist8[intform.Field, code.snippet.Recipient, model.Dollars, org.joda.time.DateTime, model.Dollars, code.snippet.Direction, Seq[code.snippet.StockInDerivative], model.Condition, Boolean](new (intform.CaseField[code.snippet.Recipient], intform.Field[model.Dollars], intform.Field[org.joda.time.DateTime], intform.Field[model.Dollars], code.snippet.SelectField[code.snippet.Direction], intform.Field[Seq[code.snippet.StockInDerivative]] with intform.FieldRender, intform.Field[model.Condition] with intform.FieldRender{lazy val useField: intform.BooleanField; lazy val aField: intform.TextField[model.ComparableSecurity]{def produce(): intform.OK[model.ComparableSecurity]}; lazy val bField: intform.TextField[model.ComparableSecurity]{def produce(): intform.OK[model.ComparableSecurity]}; def compSecField: intform.TextField[model.ComparableSecurity]{def produce(): intform.OK[model.ComparableSecurity]}; def produce(): Product with Serializable with intform.SubmitResult[Product with Serializable with model.Condition]; def main: scala.xml.Elem}, intform.Field[Boolean])(DerivativeBuilder.this.toField, (DerivativeBuilder.this.priceField: intform.Field[model.Dollars]), (DerivativeBuilder.this.expirationField: intform.Field[org.joda.time.DateTime]), (DerivativeBuilder.this.strikePriceField: intform.Field[model.Dollars]), DerivativeBuilder.this.cashDirField, DerivativeBuilder.this.stocksField, DerivativeBuilder.this.conditionField, (DerivativeBuilder.this.earlyField: intform.Field[Boolean]))), {
      {
        var $md: scala.xml.MetaData = scala.xml.Null;
        $md = new scala.xml.UnprefixedAttribute("id", new scala.xml.Text("search-derivative"), $md);
        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("block"), $md);
        new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
          $buf.&+(new scala.xml.Text("\012            "));
          $buf.&+({
            {
              new scala.xml.Elem(null, "h2", scala.xml.Null, scala.this.Predef.$scope, ({
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+(new scala.xml.Text("Offer Derivative"));
                $buf
              }: _*))
            }
          });
          $buf.&+(new scala.xml.Text("\012            "));
          $buf.&+({
            {
              new scala.xml.Elem(null, "p", scala.xml.Null, scala.this.Predef.$scope, ({
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+(new scala.xml.Text("Begin by selecting whether you want to sell this derivative to a\012            specific user or to a public auction. If you choose to sell the\012            derivative in a public auction you will have the opportunity to\012            close the auction at any time. If you sell the derivative to a\012            specific user they will have one day to accept or decline the\012            offer."));
                $buf
              }: _*))
            }
          });
          $buf.&+(new scala.xml.Text("\012\012            "));
          $buf.&+({
            {
              var $md: scala.xml.MetaData = scala.xml.Null;
              $md = new scala.xml.UnprefixedAttribute("id", new scala.xml.Text("derivative-recipient"), $md);
              $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("builder-block"), $md);
              new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+(new scala.xml.Text("\012                "));
                $buf.&+({
                  {
                    new scala.xml.Elem(null, "h3", scala.xml.Null, scala.this.Predef.$scope, ({
                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                      $buf.&+(new scala.xml.Text("Buyer"));
                      $buf
                    }: _*))
                  }
                });
                $buf.&+(new scala.xml.Text("\012                "));
                $buf.&+(DerivativeBuilder.this.toField.main);
                $buf.&+(new scala.xml.Text("\012                "));
                $buf.&+({
                  {
                    new scala.xml.Elem(null, "dl", scala.xml.Null, scala.this.Predef.$scope, ({
                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                      $buf.&+(new scala.xml.Text("\012                    "));
                      $buf.&+({
                        {
                          new scala.xml.Elem(null, "dt", scala.xml.Null, scala.this.Predef.$scope, ({
                            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                            $buf.&+({
                              {
                                var $md: scala.xml.MetaData = scala.xml.Null;
                                $md = new scala.xml.UnprefixedAttribute("for", new scala.xml.Text("derivative-money-now"), $md);
                                new scala.xml.Elem(null, "label", $md, scala.this.Predef.$scope, ({
                                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                                  $buf.&+(new scala.xml.Text("Price"));
                                  $buf
                                }: _*))
                              }
                            });
                            $buf
                          }: _*))
                        }
                      });
                      $buf.&+(new scala.xml.Text("\012                    "));
                      $buf.&+({
                        {
                          new scala.xml.Elem(null, "dd", scala.xml.Null, scala.this.Predef.$scope, ({
                            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                            $buf.&+(new scala.xml.Text("$"));
                            $buf.&+(intform.`package`.mergeAttr(DerivativeBuilder.this.priceField.main).&({
                              {
                                var $md: scala.xml.MetaData = scala.xml.Null;
                                $md = new scala.xml.UnprefixedAttribute("id", new scala.xml.Text("derivative-money-now"), $md);
                                $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("price blank"), $md);
                                new scala.xml.Elem(null, "input", $md, scala.this.Predef.$scope)
                              }
                            }));
                            $buf
                          }: _*))
                        }
                      });
                      $buf.&+(new scala.xml.Text("\012                "));
                      $buf
                    }: _*))
                  }
                });
                $buf.&+(new scala.xml.Text("\012            "));
                $buf
              }: _*))
            }
          });
          $buf.&+(new scala.xml.Text("\012            "));
          $buf.&+({
            {
              var $md: scala.xml.MetaData = scala.xml.Null;
              $md = new scala.xml.UnprefixedAttribute("id", new scala.xml.Text("derivative-money"), $md);
              $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("builder-block"), $md);
              new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+(new scala.xml.Text("\012                "));
                $buf.&+({
                  {
                    new scala.xml.Elem(null, "h3", scala.xml.Null, scala.this.Predef.$scope, ({
                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                      $buf.&+(new scala.xml.Text("Cash Transfers"));
                      $buf
                    }: _*))
                  }
                });
                $buf.&+(new scala.xml.Text("\012                "));
                $buf.&+({
                  {
                    new scala.xml.Elem(null, "dl", scala.xml.Null, scala.this.Predef.$scope, ({
                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                      $buf.&+(new scala.xml.Text("\012                    "));
                      $buf.&+({
                        {
                          new scala.xml.Elem(null, "dt", scala.xml.Null, scala.this.Predef.$scope, ({
                            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                            $buf.&+({
                              {
                                var $md: scala.xml.MetaData = scala.xml.Null;
                                $md = new scala.xml.UnprefixedAttribute("for", new scala.xml.Text("derivative-money-then"), $md);
                                new scala.xml.Elem(null, "label", $md, scala.this.Predef.$scope, ({
                                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                                  $buf.&+(new scala.xml.Text("Strike Price"));
                                  $buf
                                }: _*))
                              }
                            });
                            $buf
                          }: _*))
                        }
                      });
                      $buf.&+(new scala.xml.Text("\012                    "));
                      $buf.&+({
                        {
                          new scala.xml.Elem(null, "dd", scala.xml.Null, scala.this.Predef.$scope, ({
                            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                            $buf.&+(new scala.xml.Text("\012                        $"));
                            $buf.&+(intform.`package`.mergeAttr(DerivativeBuilder.this.strikePriceField.main).&({
                              {
                                var $md: scala.xml.MetaData = scala.xml.Null;
                                $md = new scala.xml.UnprefixedAttribute("id", new scala.xml.Text("derivative-money-then"), $md);
                                $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("price blank"), $md);
                                new scala.xml.Elem(null, "input", $md, scala.this.Predef.$scope)
                              }
                            }));
                            $buf.&+(new scala.xml.Text("\012                        "));
                            $buf.&+(DerivativeBuilder.this.cashDirField.main);
                            $buf.&+(new scala.xml.Text("\012                    "));
                            $buf
                          }: _*))
                        }
                      });
                      $buf.&+(new scala.xml.Text("\012                "));
                      $buf
                    }: _*))
                  }
                });
                $buf.&+(new scala.xml.Text("\012            "));
                $buf
              }: _*))
            }
          });
          $buf.&+(new scala.xml.Text("\012            "));
          $buf.&+({
            {
              var $md: scala.xml.MetaData = scala.xml.Null;
              $md = new scala.xml.UnprefixedAttribute("style", new scala.xml.Text("clear:both;"), $md);
              new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope)
            }
          });
          $buf.&+(new scala.xml.Text("\012            "));
          $buf.&+({
            {
              var $md: scala.xml.MetaData = scala.xml.Null;
              $md = new scala.xml.UnprefixedAttribute("id", new scala.xml.Text("derivative-expiration"), $md);
              $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("builder-block"), $md);
              new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+(new scala.xml.Text("\012                "));
                $buf.&+({
                  {
                    new scala.xml.Elem(null, "h3", scala.xml.Null, scala.this.Predef.$scope, ({
                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                      $buf.&+(new scala.xml.Text("Exercise Date"));
                      $buf
                    }: _*))
                  }
                });
                $buf.&+(new scala.xml.Text("\012                "));
                $buf.&+({
                  {
                    new scala.xml.Elem(null, "dl", scala.xml.Null, scala.this.Predef.$scope, ({
                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                      $buf.&+(new scala.xml.Text("\012                    "));
                      $buf.&+({
                        {
                          new scala.xml.Elem(null, "dt", scala.xml.Null, scala.this.Predef.$scope, ({
                            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                            $buf.&+({
                              {
                                var $md: scala.xml.MetaData = scala.xml.Null;
                                $md = new scala.xml.UnprefixedAttribute("for", new scala.xml.Text("derivative-expiration"), $md);
                                new scala.xml.Elem(null, "label", $md, scala.this.Predef.$scope, ({
                                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                                  $buf.&+(new scala.xml.Text("Date:"));
                                  $buf
                                }: _*))
                              }
                            });
                            $buf
                          }: _*))
                        }
                      });
                      $buf.&+(new scala.xml.Text("\012                    "));
                      $buf.&+({
                        {
                          new scala.xml.Elem(null, "dd", scala.xml.Null, scala.this.Predef.$scope, ({
                            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                            $buf.&+(intform.`package`.mergeAttr(DerivativeBuilder.this.expirationField.main).&({
                              {
                                var $md: scala.xml.MetaData = scala.xml.Null;
                                $md = new scala.xml.UnprefixedAttribute("id", new scala.xml.Text("derivative-expiraiton"), $md);
                                $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("date blank"), $md);
                                new scala.xml.Elem(null, "input", $md, scala.this.Predef.$scope)
                              }
                            }));
                            $buf
                          }: _*))
                        }
                      });
                      $buf.&+(new scala.xml.Text("\012\012                    "));
                      $buf.&+(DerivativeBuilder.this.earlyField.main);
                      $buf.&+(new scala.xml.Text("\012                "));
                      $buf
                    }: _*))
                  }
                });
                $buf.&+(new scala.xml.Text("\012            "));
                $buf
              }: _*))
            }
          });
          $buf.&+(new scala.xml.Text("\012            "));
          $buf.&+({
            {
              var $md: scala.xml.MetaData = scala.xml.Null;
              $md = new scala.xml.UnprefixedAttribute("id", new scala.xml.Text("derivative-conditions"), $md);
              $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("builder-block"), $md);
              new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+(new scala.xml.Text("\012                "));
                $buf.&+({
                  {
                    new scala.xml.Elem(null, "h3", scala.xml.Null, scala.this.Predef.$scope, ({
                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                      $buf.&+(new scala.xml.Text("Conditions"));
                      $buf
                    }: _*))
                  }
                });
                $buf.&+(new scala.xml.Text("\012                "));
                $buf.&+(DerivativeBuilder.this.conditionField.main);
                $buf.&+(new scala.xml.Text("\012            "));
                $buf
              }: _*))
            }
          });
          $buf.&+(new scala.xml.Text("\012            "));
          $buf.&+({
            {
              var $md: scala.xml.MetaData = scala.xml.Null;
              $md = new scala.xml.UnprefixedAttribute("style", new scala.xml.Text("clear:both;"), $md);
              new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope)
            }
          });
          $buf.&+(new scala.xml.Text("\012\012            "));
          $buf.&+({
            {
              new scala.xml.Elem(null, "h3", scala.xml.Null, scala.this.Predef.$scope, ({
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+(new scala.xml.Text("Stocks"));
                $buf
              }: _*))
            }
          });
          $buf.&+(new scala.xml.Text("\012            "));
          $buf.&+({
            {
              var $md: scala.xml.MetaData = scala.xml.Null;
              $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("derivative-stock-list boxy"), $md);
              new scala.xml.Elem(null, "table", $md, scala.this.Predef.$scope, ({
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+(new scala.xml.Text("\012                "));
                $buf.&+({
                  {
                    new scala.xml.Elem(null, "thead", scala.xml.Null, scala.this.Predef.$scope, ({
                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                      $buf.&+(new scala.xml.Text("\012                    "));
                      $buf.&+({
                        {
                          new scala.xml.Elem(null, "tr", scala.xml.Null, scala.this.Predef.$scope, ({
                            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                            $buf.&+(new scala.xml.Text("\012                        "));
                            $buf.&+({
                              {
                                var $md: scala.xml.MetaData = scala.xml.Null;
                                $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("search-list-ticker"), $md);
                                new scala.xml.Elem(null, "th", $md, scala.this.Predef.$scope, ({
                                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                                  $buf.&+(new scala.xml.Text("Ticker"));
                                  $buf
                                }: _*))
                              }
                            });
                            $buf.&+(new scala.xml.Text("\012                        "));
                            $buf.&+({
                              {
                                var $md: scala.xml.MetaData = scala.xml.Null;
                                $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("search-list-company"), $md);
                                new scala.xml.Elem(null, "th", $md, scala.this.Predef.$scope, ({
                                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                                  $buf.&+(new scala.xml.Text("Company"));
                                  $buf
                                }: _*))
                              }
                            });
                            $buf.&+(new scala.xml.Text("\012                        "));
                            $buf.&+({
                              {
                                var $md: scala.xml.MetaData = scala.xml.Null;
                                $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("search-list-shares"), $md);
                                new scala.xml.Elem(null, "th", $md, scala.this.Predef.$scope, ({
                                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                                  $buf.&+(new scala.xml.Text("Shares"));
                                  $buf
                                }: _*))
                              }
                            });
                            $buf.&+(new scala.xml.Text("\012                        "));
                            $buf.&+({
                              {
                                var $md: scala.xml.MetaData = scala.xml.Null;
                                $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("search-list-dir"), $md);
                                new scala.xml.Elem(null, "th", $md, scala.this.Predef.$scope)
                              }
                            });
                            $buf.&+(new scala.xml.Text("\012                        "));
                            $buf.&+({
                              {
                                var $md: scala.xml.MetaData = scala.xml.Null;
                                $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("search-list-price"), $md);
                                new scala.xml.Elem(null, "th", $md, scala.this.Predef.$scope, ({
                                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                                  $buf.&+(new scala.xml.Text("Current Price"));
                                  $buf
                                }: _*))
                              }
                            });
                            $buf.&+(new scala.xml.Text("\012                        "));
                            $buf.&+({
                              {
                                var $md: scala.xml.MetaData = scala.xml.Null;
                                $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("search-list-buttons"), $md);
                                new scala.xml.Elem(null, "th", $md, scala.this.Predef.$scope)
                              }
                            });
                            $buf.&+(new scala.xml.Text("\012                    "));
                            $buf
                          }: _*))
                        }
                      });
                      $buf.&+(new scala.xml.Text("\012                "));
                      $buf
                    }: _*))
                  }
                });
                $buf.&+(new scala.xml.Text("\012                "));
                $buf.&+({
                  {
                    new scala.xml.Elem(null, "tbody", scala.xml.Null, scala.this.Predef.$scope, ({
                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                      $buf.&+(new scala.xml.Text("\012                    "));
                      $buf.&+(DerivativeBuilder.this.stocksField.main);
                      $buf.&+(new scala.xml.Text("\012                "));
                      $buf
                    }: _*))
                  }
                });
                $buf.&+(new scala.xml.Text("\012            "));
                $buf
              }: _*))
            }
          });
          $buf.&+(new scala.xml.Text("\012\012            "));
          $buf.&+({
            {
              var $md: scala.xml.MetaData = scala.xml.Null;
              $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("buttons"), $md);
              new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+(new scala.xml.Text("\012                "));
                $buf.&+(intform.`package`.mergeAttr(DerivativeBuilder.this.offerSubmit.main).&({
                  {
                    new scala.xml.Elem(null, "input", scala.xml.Null, scala.this.Predef.$scope)
                  }
                }));
                $buf.&+(new scala.xml.Text("\012                "));
                $buf.&+(intform.`package`.mergeAttr(DerivativeBuilder.this.cancelSubmit.main).&({
                  {
                    new scala.xml.Elem(null, "input", scala.xml.Null, scala.this.Predef.$scope)
                  }
                }));
                $buf.&+(new scala.xml.Text("\012            "));
                $buf
              }: _*))
            }
          });
          $buf.&+(new scala.xml.Text("\012        "));
          $buf
        }: _*))
      }
    });
    DerivativeBuilder.this.form
  };
  lazy private[this] var toField: intform.CaseField[code.snippet.Recipient] = _;
  <stable> <accessor> lazy def toField: intform.CaseField[code.snippet.Recipient] = {
    DerivativeBuilder.this.toField = intform.CaseField.apply[code.snippet.Recipient](collection.this.Seq.apply[intform.Field[Product with Serializable with code.snippet.Recipient]](DerivativeBuilder.this.toUserField, intform.ConstField.apply[code.snippet.OpenAuction.type](OpenAuction)), ((choices: intform.CaseChoices) => {
      {
        new scala.xml.Elem(null, "ul", scala.xml.Null, scala.this.Predef.$scope, ({
          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
          $buf.&+(new scala.xml.Text("\012                "));
          $buf.&+({
            {
              new scala.xml.Elem(null, "li", scala.xml.Null, scala.this.Predef.$scope, ({
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+(new scala.xml.Text("\012                    "));
                $buf.&+(intform.`package`.mergeAttr(choices._1).&({
                  {
                    var $md: scala.xml.MetaData = scala.xml.Null;
                    $md = new scala.xml.UnprefixedAttribute("checked", new scala.xml.Text("checked"), $md);
                    $md = new scala.xml.UnprefixedAttribute("id", new scala.xml.Text("to-user"), $md);
                    new scala.xml.Elem(null, "input", $md, scala.this.Predef.$scope)
                  }
                }));
                $buf.&+(new scala.xml.Text("\012                    "));
                $buf.&+({
                  {
                    var $md: scala.xml.MetaData = scala.xml.Null;
                    $md = new scala.xml.UnprefixedAttribute("for", new scala.xml.Text("to-user"), $md);
                    new scala.xml.Elem(null, "label", $md, scala.this.Predef.$scope, ({
                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                      $buf.&+(new scala.xml.Text("User:"));
                      $buf
                    }: _*))
                  }
                });
                $buf.&+(new scala.xml.Text("\012                    "));
                $buf.&+(intform.`package`.mergeAttr(DerivativeBuilder.this.toUserField.main).&({
                  {
                    var $md: scala.xml.MetaData = scala.xml.Null;
                    $md = new scala.xml.UnprefixedAttribute("id", new scala.xml.Text("to-user-name"), $md);
                    new scala.xml.Elem(null, "input", $md, scala.this.Predef.$scope)
                  }
                }));
                $buf.&+(new scala.xml.Text("\012                "));
                $buf
              }: _*))
            }
          });
          $buf.&+(new scala.xml.Text("\012                "));
          $buf.&+({
            {
              new scala.xml.Elem(null, "li", scala.xml.Null, scala.this.Predef.$scope, ({
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+(new scala.xml.Text("\012                    "));
                $buf.&+(intform.`package`.mergeAttr(choices._2).&({
                  {
                    var $md: scala.xml.MetaData = scala.xml.Null;
                    $md = new scala.xml.UnprefixedAttribute("id", new scala.xml.Text("to-auction"), $md);
                    new scala.xml.Elem(null, "input", $md, scala.this.Predef.$scope)
                  }
                }));
                $buf.&+(new scala.xml.Text("\012                    "));
                $buf.&+({
                  {
                    var $md: scala.xml.MetaData = scala.xml.Null;
                    $md = new scala.xml.UnprefixedAttribute("for", new scala.xml.Text("to-auction"), $md);
                    new scala.xml.Elem(null, "label", $md, scala.this.Predef.$scope, ({
                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                      $buf.&+(new scala.xml.Text("Public Auction"));
                      $buf
                    }: _*))
                  }
                });
                $buf.&+(new scala.xml.Text("\012                "));
                $buf
              }: _*))
            }
          });
          $buf.&+(new scala.xml.Text("\012            "));
          $buf
        }: _*))
      }
    }));
    DerivativeBuilder.this.toField
  };
  lazy private[this] var recipientField: code.snippet.PortfolioField with intform.FieldErrorRender = _;
  <stable> <accessor> lazy def recipientField: code.snippet.PortfolioField with intform.FieldErrorRender = {
    DerivativeBuilder.this.recipientField = {
      final class $anon extends PortfolioField with intform.FieldErrorRender {
        def this(): anonymous class $anon = {
          $anon.super.this("");
          ()
        }
      };
      new $anon()
    };
    DerivativeBuilder.this.recipientField
  };
  lazy private[this] var toUserField: intform.AggregateField[code.snippet.SpecificUser,up.HList.:+:[model.schema.Portfolio,up.HNil]] = _;
  <stable> <accessor> lazy def toUserField: intform.AggregateField[code.snippet.SpecificUser,up.HList.:+:[model.schema.Portfolio,up.HNil]] = {
    DerivativeBuilder.this.toUserField = intform.AggregateField.apply[code.snippet.SpecificUser, up.HList.:+:[model.schema.Portfolio,up.HNil]](intform.`package`.hlistify1[model.schema.Portfolio, code.snippet.SpecificUser](SpecificUser), intform.`package`.klist1[intform.TextField, model.schema.Portfolio]((DerivativeBuilder.this.recipientField: code.snippet.PortfolioField)), {
      {
        new scala.xml.Elem(null, "span", scala.xml.Null, scala.this.Predef.$scope, ({
          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
          $buf.&+(intform.`package`.mergeAttr(DerivativeBuilder.this.recipientField.main).&({
            {
              var $md: scala.xml.MetaData = scala.xml.Null;
              $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("blank"), $md);
              new scala.xml.Elem(null, "input", $md, scala.this.Predef.$scope)
            }
          }));
          $buf
        }: _*))
      }
    });
    DerivativeBuilder.this.toUserField
  };
  private[this] val tomorrow: org.joda.time.DateTime = org.joda.time.DateTime.now().plusDays(7);
  <stable> <accessor> def tomorrow: org.joda.time.DateTime = DerivativeBuilder.this.tomorrow;
  lazy private[this] var expirationField: intform.DateTimeField with intform.FieldErrorRender = _;
  <stable> <accessor> lazy def expirationField: intform.DateTimeField with intform.FieldErrorRender = {
    DerivativeBuilder.this.expirationField = {
      final class $anon extends intform.DateTimeField with intform.FieldErrorRender {
        def this(): anonymous class $anon = {
          $anon.super.this(DerivativeBuilder.this.tomorrow, DerivativeBuilder.this.formatter);
          ()
        }
      };
      new $anon()
    };
    DerivativeBuilder.this.expirationField
  };
  lazy private[this] var priceField: code.snippet.DollarsField with intform.FieldErrorRender = _;
  <stable> <accessor> lazy def priceField: code.snippet.DollarsField with intform.FieldErrorRender = {
    DerivativeBuilder.this.priceField = {
      final class $anon extends DollarsField with intform.FieldErrorRender {
        def this(): anonymous class $anon = {
          $anon.super.this("");
          ()
        }
      };
      new $anon()
    };
    DerivativeBuilder.this.priceField
  };
  lazy private[this] var strikePriceField: code.snippet.DollarsField with intform.FieldErrorRender = _;
  <stable> <accessor> lazy def strikePriceField: code.snippet.DollarsField with intform.FieldErrorRender = {
    DerivativeBuilder.this.strikePriceField = {
      final class $anon extends DollarsField with intform.FieldErrorRender {
        def this(): anonymous class $anon = {
          $anon.super.this("");
          ()
        }
      };
      new $anon()
    };
    DerivativeBuilder.this.strikePriceField
  };
  lazy private[this] var cashDirField: code.snippet.SelectField[code.snippet.Direction] = _;
  <stable> <accessor> lazy def cashDirField: code.snippet.SelectField[code.snippet.Direction] = {
    DerivativeBuilder.this.cashDirField = DerivativeBuilder.this.DirectionField(ToSeller);
    DerivativeBuilder.this.cashDirField
  };
  lazy private[this] var stocksField: intform.Field[Seq[code.snippet.StockInDerivative]] with intform.FieldRender = _;
  <stable> <accessor> lazy def stocksField: intform.Field[Seq[code.snippet.StockInDerivative]] with intform.FieldRender = {
    DerivativeBuilder.this.stocksField = intform.DependentListField.apply[code.snippet.StockInDerivative](DerivativeBuilder.this.stockRowFields.values.toList, DerivativeBuilder.this.stockRowFields.map[scala.xml.NodeSeq, Iterable[scala.xml.NodeSeq]](((x$2: (String, DerivativeBuilder.this.StockRowField)) => x$2._2.main))(collection.this.Iterable.canBuildFrom[scala.xml.NodeSeq]).foldLeft[scala.xml.NodeSeq](xml.this.NodeSeq.seqToNodeSeq(immutable.this.Nil))(((x$3: scala.xml.NodeSeq, x$4: scala.xml.NodeSeq) => x$3.++[scala.xml.Node, scala.xml.NodeSeq](x$4)(xml.this.NodeSeq.canBuildFrom))));
    DerivativeBuilder.this.stocksField
  };
  type StockRowField = intform.Field[code.snippet.StockInDerivative] with intform.FieldRender;
  private[this] var stockRowFields: scala.collection.SortedMap[String,DerivativeBuilder.this.StockRowField] = scala.collection.immutable.TreeMap.apply[String, Nothing]()(math.this.Ordering.String);
  <accessor> def stockRowFields: scala.collection.SortedMap[String,DerivativeBuilder.this.StockRowField] = DerivativeBuilder.this.stockRowFields;
  <accessor> def stockRowFields_=(x$1: scala.collection.SortedMap[String,DerivativeBuilder.this.StockRowField]): Unit = DerivativeBuilder.this.stockRowFields = x$1;
  def makeStockRowField(init: code.snippet.AddToDerivative): DerivativeBuilder.this.StockRowField = {
    <synthetic> private[this] val x$5: (stockdata.Quote, model.Shares) = (init: code.snippet.AddToDerivative @unchecked) match {
      case (quote: stockdata.Quote, shares: model.Shares)code.snippet.AddToDerivative((quote @ _), (shares @ _)) => new (stockdata.Quote, model.Shares)(quote, shares)
    };
    val quote: stockdata.Quote = x$5._1;
    val shares: model.Shares = x$5._2;
    val sharesField: intform.IntField = intform.IntField.apply(shares.###());
    val dirField: code.snippet.SelectField[code.snippet.Direction] = DerivativeBuilder.this.DirectionField(ToBuyer);
    val remove: java.lang.Object with intform.SubmitRender with intform.BasicErrors with intform.ErrorRender = intform.Submit.cancel(DerivativeBuilder.this.form, "Remove")({
      DerivativeBuilder.this.stockRowFields_=(DerivativeBuilder.this.stockRowFields.-(quote.stock.symbol));
      DerivativeBuilder.this.refreshable.refresh()
    });
    intform.AggregateField.apply[code.snippet.StockInDerivative, up.HList.:+:[Int,up.HList.:+:[code.snippet.Direction,up.HNil]]](intform.`package`.hlistify2[Int, code.snippet.Direction, code.snippet.StockInDerivative](((sh: Int, dir: code.snippet.Direction) => new code.snippet.StockInDerivative(quote, sh, dir))), intform.`package`.klist2[intform.Field, Int, code.snippet.Direction](new (intform.Field[Int], code.snippet.SelectField[code.snippet.Direction])((sharesField: intform.Field[Int]), dirField)), {
      {
        new scala.xml.Elem(null, "tr", scala.xml.Null, scala.this.Predef.$scope, ({
          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
          $buf.&+(new scala.xml.Text("\012                "));
          $buf.&+({
            {
              var $md: scala.xml.MetaData = scala.xml.Null;
              $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("search-list-ticker"), $md);
              new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope, ({
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+(quote.stock.symbol);
                $buf
              }: _*))
            }
          });
          $buf.&+(new scala.xml.Text("\012                "));
          $buf.&+({
            {
              var $md: scala.xml.MetaData = scala.xml.Null;
              $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("search-list-company"), $md);
              new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope, ({
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+(quote.company);
                $buf
              }: _*))
            }
          });
          $buf.&+(new scala.xml.Text("\012                "));
          $buf.&+({
            {
              var $md: scala.xml.MetaData = scala.xml.Null;
              $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("search-list-shares"), $md);
              new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope, ({
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+(intform.`package`.mergeAttr(sharesField.main).&({
                  {
                    var $md: scala.xml.MetaData = scala.xml.Null;
                    $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("blank shares"), $md);
                    new scala.xml.Elem(null, "input", $md, scala.this.Predef.$scope)
                  }
                }));
                $buf
              }: _*))
            }
          });
          $buf.&+(new scala.xml.Text("\012                "));
          $buf.&+({
            {
              var $md: scala.xml.MetaData = scala.xml.Null;
              $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("search-list-dir"), $md);
              new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope, ({
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+(dirField.main);
                $buf
              }: _*))
            }
          });
          $buf.&+(new scala.xml.Text("\012                "));
          $buf.&+({
            {
              var $md: scala.xml.MetaData = scala.xml.Null;
              $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("search-list-price"), $md);
              new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope, ({
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+(quote.price.$);
                $buf.&+(new scala.xml.Text("/sh"));
                $buf
              }: _*))
            }
          });
          $buf.&+(new scala.xml.Text("\012                "));
          $buf.&+({
            {
              var $md: scala.xml.MetaData = scala.xml.Null;
              $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("search-list-buttons"), $md);
              new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope, ({
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+(new scala.xml.Text("\012                    "));
                $buf.&+(intform.`package`.mergeAttr(remove.main).&({
                  {
                    var $md: scala.xml.MetaData = scala.xml.Null;
                    $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("search-list-remove"), $md);
                    new scala.xml.Elem(null, "input", $md, scala.this.Predef.$scope)
                  }
                }));
                $buf.&+(new scala.xml.Text("\012                "));
                $buf
              }: _*))
            }
          });
          $buf.&+(new scala.xml.Text("\012            "));
          $buf
        }: _*))
      }
    })
  };
  lazy private[this] var conditionField: intform.Field[model.Condition] with intform.FieldRender{lazy val useField: intform.BooleanField; lazy val aField: intform.TextField[model.ComparableSecurity]{def produce(): intform.OK[model.ComparableSecurity]}; lazy val bField: intform.TextField[model.ComparableSecurity]{def produce(): intform.OK[model.ComparableSecurity]}; def compSecField: intform.TextField[model.ComparableSecurity]{def produce(): intform.OK[model.ComparableSecurity]}; def produce(): Product with Serializable with intform.SubmitResult[Product with Serializable with model.Condition]; def main: scala.xml.Elem} = _;
  <stable> <accessor> lazy def conditionField: intform.Field[model.Condition] with intform.FieldRender{lazy val useField: intform.BooleanField; lazy val aField: intform.TextField[model.ComparableSecurity]{def produce(): intform.OK[model.ComparableSecurity]}; lazy val bField: intform.TextField[model.ComparableSecurity]{def produce(): intform.OK[model.ComparableSecurity]}; def compSecField: intform.TextField[model.ComparableSecurity]{def produce(): intform.OK[model.ComparableSecurity]}; def produce(): Product with Serializable with intform.SubmitResult[Product with Serializable with model.Condition]; def main: scala.xml.Elem} = {
    DerivativeBuilder.this.conditionField = {
      final class $anon extends intform.Field[model.Condition] with intform.FieldRender {
        def this(): anonymous class $anon = {
          $anon.super.this();
          ()
        };
        lazy private[this] var useField: intform.BooleanField = _;
        <stable> <accessor> lazy def useField: intform.BooleanField = {
          $anon.this.useField = intform.BooleanField.apply(intform.BooleanField.apply$default$1);
          $anon.this.useField
        };
        lazy private[this] var aField: intform.TextField[model.ComparableSecurity]{def produce(): intform.OK[model.ComparableSecurity]} = _;
        <stable> <accessor> lazy def aField: intform.TextField[model.ComparableSecurity]{def produce(): intform.OK[model.ComparableSecurity]} = {
          $anon.this.aField = $anon.this.compSecField;
          $anon.this.aField
        };
        lazy private[this] var bField: intform.TextField[model.ComparableSecurity]{def produce(): intform.OK[model.ComparableSecurity]} = _;
        <stable> <accessor> lazy def bField: intform.TextField[model.ComparableSecurity]{def produce(): intform.OK[model.ComparableSecurity]} = {
          $anon.this.bField = $anon.this.compSecField;
          $anon.this.bField
        };
        def compSecField: intform.TextField[model.ComparableSecurity]{def produce(): intform.OK[model.ComparableSecurity]} = {
          final class $anon extends intform.TextField[model.ComparableSecurity] {
            def this(): anonymous class $anon = {
              $anon.super.this("");
              ()
            };
            def produce(): intform.OK[model.ComparableSecurity] = new intform.OK[model.ComparableSecurity](try {
              new model.CompSecDollar(model.Price.apply($anon.this.text))
            } catch {
              case (_: NumberFormatException) => new model.CompSecStock($anon.this.text)
            })
          };
          new $anon()
        };
        def produce(): Product with Serializable with intform.SubmitResult[Product with Serializable with model.Condition] = $anon.this.useField.process().flatMap[intform.OK[Product with Serializable with model.Condition]](((use: Boolean) => if (use)
  $anon.this.aField.process().flatMap[intform.OK[model.CondGreater]](((a: model.ComparableSecurity) => $anon.this.bField.process().map[intform.OK[model.CondGreater]](((b: model.ComparableSecurity) => new intform.OK[model.CondGreater](new model.CondGreater(b, a))))))
else
  new Some[intform.OK[model.CondAlways.type]](new intform.OK[model.CondAlways.type](model.CondAlways)))).getOrElse[Product with Serializable with intform.SubmitResult[Product with Serializable with model.Condition]](intform.ChildError);
        def reset(): Unit = {
          $anon.this.useField.reset();
          $anon.this.aField.reset();
          $anon.this.bField.reset()
        };
        def main: scala.xml.Elem = {
          {
            new scala.xml.Elem(null, "p", scala.xml.Null, scala.this.Predef.$scope, ({
              val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
              $buf.&+(new scala.xml.Text("\012                "));
              $buf.&+(intform.`package`.mergeAttr($anon.this.useField.main).&({
                {
                  var $md: scala.xml.MetaData = scala.xml.Null;
                  $md = new scala.xml.UnprefixedAttribute("id", new scala.xml.Text("condition-en"), $md);
                  new scala.xml.Elem(null, "input", $md, scala.this.Predef.$scope)
                }
              }));
              $buf.&+(new scala.xml.Text("\012                "));
              $buf.&+({
                {
                  var $md: scala.xml.MetaData = scala.xml.Null;
                  $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("chain"), $md);
                  new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
                    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                    $buf.&+(new scala.xml.Text("\012                    "));
                    $buf.&+({
                      {
                        var $md: scala.xml.MetaData = scala.xml.Null;
                        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("description"), $md);
                        $md = new scala.xml.UnprefixedAttribute("for", new scala.xml.Text("condition-en"), $md);
                        new scala.xml.Elem(null, "label", $md, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(new scala.xml.Text("Provided that"));
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012                "));
                    $buf
                  }: _*))
                }
              });
              $buf.&+(new scala.xml.Text("\012                "));
              $buf.&+({
                {
                  var $md: scala.xml.MetaData = scala.xml.Null;
                  $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("chain"), $md);
                  new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
                    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                    $buf.&+(new scala.xml.Text("\012                    "));
                    $buf.&+({
                      {
                        var $md: scala.xml.MetaData = scala.xml.Null;
                        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("field-annotation"), $md);
                        $md = new scala.xml.UnprefixedAttribute("for", new scala.xml.Text("condition1"), $md);
                        new scala.xml.Elem(null, "label", $md, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(new scala.xml.Text("ticker or $"));
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012                    "));
                    $buf.&+(intform.`package`.mergeAttr($anon.this.aField.main).&({
                      {
                        var $md: scala.xml.MetaData = scala.xml.Null;
                        $md = new scala.xml.UnprefixedAttribute("id", new scala.xml.Text("condition1"), $md);
                        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("blank condition"), $md);
                        new scala.xml.Elem(null, "input", $md, scala.this.Predef.$scope)
                      }
                    }));
                    $buf.&+(new scala.xml.Text("\012                "));
                    $buf
                  }: _*))
                }
              });
              $buf.&+(new scala.xml.Text("\012                "));
              $buf.&+({
                {
                  var $md: scala.xml.MetaData = scala.xml.Null;
                  $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("chain"), $md);
                  new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
                    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                    $buf.&+(new scala.xml.EntityRef("lt"));
                    $buf
                  }: _*))
                }
              });
              $buf.&+(new scala.xml.Text("\012                "));
              $buf.&+({
                {
                  var $md: scala.xml.MetaData = scala.xml.Null;
                  $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("chain"), $md);
                  new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
                    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                    $buf.&+(new scala.xml.Text("\012                    "));
                    $buf.&+({
                      {
                        var $md: scala.xml.MetaData = scala.xml.Null;
                        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("field-annotation"), $md);
                        $md = new scala.xml.UnprefixedAttribute("for", new scala.xml.Text("condition2"), $md);
                        new scala.xml.Elem(null, "label", $md, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(new scala.xml.Text("ticker or $"));
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012                    "));
                    $buf.&+(intform.`package`.mergeAttr($anon.this.bField.main).&({
                      {
                        var $md: scala.xml.MetaData = scala.xml.Null;
                        $md = new scala.xml.UnprefixedAttribute("id", new scala.xml.Text("condition2"), $md);
                        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("blank condition"), $md);
                        new scala.xml.Elem(null, "input", $md, scala.this.Predef.$scope)
                      }
                    }));
                    $buf.&+(new scala.xml.Text("\012                "));
                    $buf
                  }: _*))
                }
              });
              $buf.&+(new scala.xml.Text("\012            "));
              $buf
            }: _*))
          }
        }
      };
      new $anon()
    };
    DerivativeBuilder.this.conditionField
  };
  lazy private[this] var earlyField: intform.BooleanField = _;
  <stable> <accessor> lazy def earlyField: intform.BooleanField = {
    DerivativeBuilder.this.earlyField = {
      final class $anon extends intform.BooleanField {
        def this(): anonymous class $anon = {
          $anon.super.this(true);
          ()
        };
        override def main: scala.xml.NodeSeq = {
  {
    new scala.xml.Elem(null, "dt", scala.xml.Null, scala.this.Predef.$scope, ({
      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
      $buf.&+({
        {
          var $md: scala.xml.MetaData = scala.xml.Null;
          $md = new scala.xml.UnprefixedAttribute("for", new scala.xml.Text("derivative-early"), $md);
          new scala.xml.Elem(null, "label", $md, scala.this.Predef.$scope, ({
            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
            $buf.&+(new scala.xml.Text("Exercise Early?"));
            $buf
          }: _*))
        }
      });
      $buf
    }: _*))
  }
}.++[scala.xml.Node, scala.xml.NodeSeq]({
          {
            new scala.xml.Elem(null, "dd", scala.xml.Null, scala.this.Predef.$scope, ({
              val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
              $buf.&+(intform.`package`.mergeAttr($anon.super.main).&({
                {
                  var $md: scala.xml.MetaData = scala.xml.Null;
                  $md = new scala.xml.UnprefixedAttribute("id", new scala.xml.Text("derivative-early"), $md);
                  new scala.xml.Elem(null, "input", $md, scala.this.Predef.$scope)
                }
              }));
              $buf
            }: _*))
          }
        })(xml.this.NodeSeq.canBuildFrom)
      };
      new $anon()
    };
    DerivativeBuilder.this.earlyField
  };
  lazy private[this] var offerSubmit: intform.Submit[code.snippet.DerivativeOrder] = _;
  <stable> <accessor> lazy def offerSubmit: intform.Submit[code.snippet.DerivativeOrder] = {
    DerivativeBuilder.this.offerSubmit = intform.Submit.apply[code.snippet.DerivativeOrder](DerivativeBuilder.this.form, "Offer", intform.Submit.apply$default$3[Nothing])(((order: code.snippet.DerivativeOrder) => {
      try {
        val expires: org.joda.time.DateTime = new org.joda.time.DateTime().plusDays(3);
        val stocks: List[model.SecStock] = order.stocks.map[model.SecStock, Iterable[model.SecStock]](((x0$1: code.snippet.StockInDerivative) => x0$1 match {
  case (quote: stockdata.Quote, shares: Int, direction: code.snippet.Direction)code.snippet.StockInDerivative((quote @ _), (shares @ _), (dir @ _)) => new model.SecStock(quote.stock.symbol, dir.sign(new model.Shares(math.this.BigDecimal.int2bigDecimal(shares))))
}))(collection.this.Iterable.canBuildFrom[model.SecStock]).toList;
        val secs: List[Product with Serializable with model.Security{def *(scale: model.Scale): Product with Serializable with model.Security}] = {
          <synthetic> val x$6: model.SecDollar = new model.SecDollar(order.cash);
          stocks.::[Product with Serializable with model.Security{def *(scale: model.Scale): Product with Serializable with model.Security}](x$6)
        };
        val deriv: model.Derivative = new model.Derivative(secs, order.execDate, order.condition, order.early);
        val myPort: model.schema.Portfolio = control.PortfolioSwitcher.currentPortfolio;
        order.recipient match {
          case (portfolio: model.schema.Portfolio)code.snippet.SpecificUser((recip @ _)) => myPort.userOfferDerivativeTo(recip, deriv, order.price)
          case OpenAuction => myPort.userOfferDerivativeAtAuction(deriv, order.price, expires)
        };
        DerivativeBuilder.this.clearAll()
      } catch {
        case control.LoginManager.NotLoggedIn => throw new intform.BadFieldInput(DerivativeBuilder.this.recipientField, "You\'re not logged in")
      }
    }));
    DerivativeBuilder.this.offerSubmit
  };
  lazy private[this] var cancelSubmit: java.lang.Object with intform.SubmitRender with intform.BasicErrors with intform.ErrorRender = _;
  <stable> <accessor> lazy def cancelSubmit: java.lang.Object with intform.SubmitRender with intform.BasicErrors with intform.ErrorRender = {
    DerivativeBuilder.this.cancelSubmit = intform.Submit.cancel(DerivativeBuilder.this.form, "Cancel")(DerivativeBuilder.this.clearAll());
    DerivativeBuilder.this.cancelSubmit
  };
  def DirectionField(init: code.snippet.Direction): code.snippet.SelectField[code.snippet.Direction] = SelectField.apply[code.snippet.Direction](collection.this.Seq.apply[(Product with Serializable with code.snippet.Direction, java.lang.String)](new (code.snippet.ToBuyer.type, java.lang.String)(ToBuyer, "To Buyer"), new (code.snippet.ToSeller.type, java.lang.String)(ToSeller, "To Seller")), init);
  private def clearAll(): net.liftweb.http.js.JsCmd = {
    DerivativeBuilder.this.form.reset();
    DerivativeBuilder.this.stockRowFields_=(scala.collection.immutable.TreeMap.apply[String, Nothing]()(math.this.Ordering.String));
    DerivativeBuilder.this.active_=(false);
    DerivativeBuilder.this.refreshable.refresh()
  };
  private def notify(quote: Option[stockdata.Quote]): net.liftweb.http.js.JsCmd = DerivativeBuilder.this.listeners.map[net.liftweb.http.js.JsCmd, List[net.liftweb.http.js.JsCmd]](((callback: Option[stockdata.Quote] => net.liftweb.http.js.JsCmd) => callback.apply(quote)))(immutable.this.List.canBuildFrom[net.liftweb.http.js.JsCmd]).foldLeft[net.liftweb.http.js.JsCmd](net.liftweb.http.js.JsCmds.Noop)(((x$7: net.liftweb.http.js.JsCmd, x$8: net.liftweb.http.js.JsCmd) => x$7.&(x$8)));
  private def notifyAndRefresh(quote: Option[stockdata.Quote]): net.liftweb.http.js.JsCmd = DerivativeBuilder.this.notify(quote).&(DerivativeBuilder.this.refreshable.refresh());
  def listen(callback: Option[stockdata.Quote] => net.liftweb.http.js.JsCmd): Unit = DerivativeBuilder.this.listeners_=(DerivativeBuilder.this.listeners.::[Option[stockdata.Quote] => net.liftweb.http.js.JsCmd](callback));
  def addOrder(order: code.snippet.AddToDerivative): net.liftweb.http.js.JsCmd = {
    DerivativeBuilder.this.stockRowFields_=(DerivativeBuilder.this.stockRowFields.+[DerivativeBuilder.this.StockRowField](new (String, DerivativeBuilder.this.StockRowField)(order.quote.stock.symbol, DerivativeBuilder.this.makeStockRowField(order))));
    DerivativeBuilder.this.active_=(true);
    DerivativeBuilder.this.refreshable.refresh()
  };
  override def render: scala.xml.NodeSeq = DerivativeBuilder.this.refreshable.render
}
DerivativeBuilder: SCOM=0.055 CC=0.109 LSCC=0.055 CAMC=0.136
          render  notify makeSto toDolla addOrde directi notifyA  listen clearAl  toDate Directi
 offerSu                     X               X                               X                  
 toUserF                     X               X                               X                  
 cancelS                     X               X                               X                  
 priceFi                     X               X                               X                  
 cashDir                     X               X                               X                  
 earlyFi                     X               X                               X                  
 recipie                     X               X                               X                  
 strikeP                     X               X                               X                  
 stockRo                     X               X                               X                  
 stocksF                     X               X                               X                  
 conditi                     X               X                               X                  
  active                     X               X                               X                  
    form                     X               X                               X                  
 listene             X                                       X       X                          
 toField                     X               X                               X                  
 expirat                     X               X                               X                  

final object Quote extends java.lang.Object with ScalaObject with Serializable {
  def this(): object stockdata.Quote = {
    Quote.super.this();
    ()
  };
  implicit def quoteToStock(quote: stockdata.Quote): stockdata.Stock = quote.stock;
  case <synthetic> def unapply(x$0: stockdata.Quote): Option[(stockdata.Stock, String, String, model.Price, org.joda.time.DateTime, stockdata.QuoteInfo)] = if (x$0.==(null))
    scala.this.None
  else
    new Some[(stockdata.Stock, String, String, model.Price, org.joda.time.DateTime, stockdata.QuoteInfo)](new (stockdata.Stock, String, String, model.Price, org.joda.time.DateTime, stockdata.QuoteInfo)(x$0.stock, x$0.exchange, x$0.company, x$0.price, x$0.updateTime, x$0.info));
  case <synthetic> def apply(stock: stockdata.Stock, exchange: String, company: String, price: model.Price, updateTime: org.joda.time.DateTime, info: stockdata.QuoteInfo): stockdata.Quote = new stockdata.this.Quote(stock, exchange, company, price, updateTime, info);
  protected def readResolve(): java.lang.Object = stockdata.this.Quote
}
Quote: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.500
         readRes quoteTo

abstract trait AutoTradeOps extends java.lang.Object with ScalaObject { self: AutoTradeSchema.this.AutoTrade => 
  def /*AutoTradeOps*/$init$(): Unit = {
    ()
  };
  def userModify(title: String, code: String): Unit = AutoTradeSchema.this.editDB[Unit](AutoTradeOps.this.modify(title, code));
  def userDelete(): AutoTradeSchema.this.AutoTrade = AutoTradeSchema.this.editDB[AutoTradeSchema.this.AutoTrade](AutoTradeSchema.this.toOps[AutoTradeSchema.this.AutoTrade](this).delete(AutoTradeSchema.this.autoTrades));
  private[model] def modify(title: String, code: String): AutoTradeSchema.this.Transaction[Unit] = AutoTradeSchema.this.toOps[AutoTradeSchema.this.AutoTrade](this).update(((t: AutoTradeSchema.this.AutoTrade) => {
    val x$6: String = title;
    val x$7: String = code;
    val x$8: model.package.Key = t.copy$default$1;
    val x$9: AutoTradeSchema.this.Portfolio = t.copy$default$2;
    t.copy(x$8, x$9, x$6, x$7)
  }))(AutoTradeSchema.this.autoTrades)
}
AutoTradeOps: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.667
         userMod  modify userDel

case class Exercised extends java.lang.Object with NewsSchema.this.Action with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val user: NewsSchema.this.P = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def user: NewsSchema.this.P = Exercised.this.user;
  <caseaccessor> <paramaccessor> private[this] val derivative: model.Derivative = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def derivative: model.Derivative = Exercised.this.derivative;
  def this(user: NewsSchema.this.P, derivative: model.Derivative): NewsSchema.this.Exercised = {
    Exercised.super.this();
    ()
  };
  <synthetic> def copy(user: NewsSchema.this.P = user, derivative: model.Derivative = derivative): NewsSchema.this.Exercised = new NewsSchema.this.Exercised(user, derivative);
  <synthetic> def copy$default$2: model.Derivative @scala.annotation.unchecked.uncheckedVariance = Exercised.this.derivative;
  <synthetic> def copy$default$1: NewsSchema.this.P @scala.annotation.unchecked.uncheckedVariance = Exercised.this.user;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(Exercised.this);
  override def toString(): String = ScalaRunTime.this._toString(Exercised.this);
  override def equals(x$1: Any): Boolean = Exercised.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (user: NewsSchema.this.P, derivative: model.Derivative)NewsSchema.this.Exercised((user$1 @ _), (derivative$6 @ _)) if user$1.==(user).&&(derivative$6.==(derivative)) => x$1.asInstanceOf[NewsSchema.this.Exercised].canEqual(Exercised.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "Exercised";
  override def productArity: Int = 2;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => user
    case 1 => derivative
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[NewsSchema.this.Exercised]()
}
Exercised: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
    user
 derivat

abstract trait Frontend extends scala.AnyRef {
  def messages: Iterator[texttrading.Message]
}
Frontend: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
 message

case class WithUser extends java.lang.Object with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val user: model.schema.User = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def user: model.schema.User = WithUser.this.user;
  def this(user: model.schema.User): texttrading.WithUser = {
    WithUser.super.this();
    ()
  };
  def failed: PartialFunction[Any,texttrading.Failed] = ((x0$4: Any) => x0$4 match {
    case (e @ _) => new texttrading.Failed(e.toString())
  });
  def buy(asset: texttrading.StockAsset): Product with Serializable with texttrading.Status = try {
    scalaz.Scalaz.mkIdentity[(String, model.schema.StockPurchase)](scalaz.Scalaz.mkIdentity[texttrading.StockAsset](asset).|>[(String, model.schema.StockPurchase)](((x0$1: texttrading.StockAsset) => x0$1 match {
  case (ticker: String, shares: model.Shares)texttrading.StockShares((ticker @ _), (shares @ _)) => new (String, model.schema.StockPurchase)(ticker, model.this.Link.extract[model.schema.Portfolio](WithUser.this.user.lastPortfolio)(model.schema.portfolios).userBuyStock(ticker, shares))
  case (ticker: String, dollars: model.Dollars)texttrading.StockDollars((ticker @ _), (dollars @ _)) => new (String, model.schema.StockPurchase)(ticker, model.this.Link.extract[model.schema.Portfolio](WithUser.this.user.lastPortfolio)(model.schema.portfolios).userBuyStock(ticker, dollars))
}))).|>[texttrading.TransactionResponse](((x0$2: (String, model.schema.StockPurchase)) => x0$2 match {
      case (_1: String, _2: model.schema.StockPurchase)(String, model.schema.StockPurchase)((ticker @ _), (shares: model.Shares, dollars: model.Dollars, asset: model.package.Key)model.schema.StockPurchase((shares @ _), (dollars @ _), _)) => new texttrading.TransactionResponse(ticker, dollars, shares)
    }))
  } catch {
    case (x1 @ (_: Throwable)) => {
      val catchExpr1: PartialFunction[Any,texttrading.Failed] = WithUser.this.failed;
      if (catchExpr1.isDefinedAt(x1))
        catchExpr1.apply(x1)
      else
        throw x1
    }
  };
  def sell(asset: texttrading.StockAsset): Product with Serializable with texttrading.Status = try {
    scalaz.Scalaz.mkIdentity[Unit](scalaz.Scalaz.mkIdentity[texttrading.StockAsset](asset).|>[Unit](((x0$3: texttrading.StockAsset) => x0$3 match {
  case (ticker: String, shares: model.Shares)texttrading.StockShares((ticker @ _), (shares @ _)) => model.this.Link.extract[model.schema.Portfolio](WithUser.this.user.lastPortfolio)(model.schema.portfolios).userSellStock(ticker, shares)
  case (ticker: String, dollars: model.Dollars)texttrading.StockDollars((ticker @ _), (dollars @ _)) => model.this.Link.extract[model.schema.Portfolio](WithUser.this.user.lastPortfolio)(model.schema.portfolios).userSellStock(ticker, dollars)
}))).|>[texttrading.OK.type](((x$3: Unit) => OK))
  } catch {
    case (x2 @ (_: Throwable)) => {
      val catchExpr2: PartialFunction[Any,texttrading.Failed] = WithUser.this.failed;
      if (catchExpr2.isDefinedAt(x2))
        catchExpr2.apply(x2)
      else
        throw x2
    }
  };
  def portfolio: texttrading.StringResponse = new texttrading.StringResponse(model.this.Link.extract[model.schema.Portfolio](WithUser.this.user.lastPortfolio)(model.schema.portfolios).cash.$.+(" in cash,").+(model.this.Link.extract[model.schema.Portfolio](WithUser.this.user.lastPortfolio)(model.schema.portfolios).myStockAssets.map[String, List[String]](((x$4: model.schema.StockAsset) => x$4.ticker))(immutable.this.List.canBuildFrom[String]).mkString(", ")));
  def stockInfo(ticker: String): texttrading.StringResponse = new texttrading.StringResponse({
    val shares: model.Shares = model.this.Link.extract[model.schema.Portfolio](WithUser.this.user.lastPortfolio)(model.schema.portfolios).howManyShares(ticker);
    if (shares.==(0))
      "You don\'t have any ".+(ticker)
    else
      "You have ".+(shares.###()).+(" shares of ").+(ticker)
  });
  def sellAll(ticker: String): Product with Serializable with texttrading.Status = try {
    model.this.Link.extract[model.schema.Portfolio](WithUser.this.user.lastPortfolio)(model.schema.portfolios).userSellAll(ticker);
    OK
  } catch {
    case (x3 @ (_: Throwable)) => {
      val catchExpr3: PartialFunction[Any,texttrading.Failed] = WithUser.this.failed;
      if (catchExpr3.isDefinedAt(x3))
        catchExpr3.apply(x3)
      else
        throw x3
    }
  };
  <synthetic> def copy(user: model.schema.User = user): texttrading.WithUser = new texttrading.this.WithUser(user);
  <synthetic> def copy$default$1: model.schema.User @scala.annotation.unchecked.uncheckedVariance = WithUser.this.user;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(WithUser.this);
  override def toString(): String = ScalaRunTime.this._toString(WithUser.this);
  override def equals(x$1: Any): Boolean = WithUser.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (user: model.schema.User)texttrading.WithUser((user$1 @ _)) if user$1.==(user) => x$1.asInstanceOf[texttrading.WithUser].canEqual(WithUser.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "WithUser";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => user
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[texttrading.WithUser]()
}
WithUser: SCOM=0.667 CC=0.667 LSCC=0.667 CAMC=0.333
         stockIn  failed    sell sellAll     buy portfol
    user     X               X       X       X       X  

case class Accepted extends java.lang.Object with NewsSchema.this.Action with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val from: NewsSchema.this.P = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def from: NewsSchema.this.P = Accepted.this.from;
  <caseaccessor> <paramaccessor> private[this] val to: NewsSchema.this.P = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def to: NewsSchema.this.P = Accepted.this.to;
  <caseaccessor> <paramaccessor> private[this] val derivative: model.Derivative = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def derivative: model.Derivative = Accepted.this.derivative;
  <caseaccessor> <paramaccessor> private[this] val price: model.Dollars = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def price: model.Dollars = Accepted.this.price;
  <caseaccessor> <paramaccessor> private[this] val buyerAside: model.Link[NewsSchema.this.DerivativeBuyerSetAside] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def buyerAside: model.Link[NewsSchema.this.DerivativeBuyerSetAside] = Accepted.this.buyerAside;
  <caseaccessor> <paramaccessor> private[this] val sellerAside: model.Link[NewsSchema.this.DerivativeSellerSetAside] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def sellerAside: model.Link[NewsSchema.this.DerivativeSellerSetAside] = Accepted.this.sellerAside;
  def this(from: NewsSchema.this.P, to: NewsSchema.this.P, derivative: model.Derivative, price: model.Dollars, buyerAside: model.Link[NewsSchema.this.DerivativeBuyerSetAside], sellerAside: model.Link[NewsSchema.this.DerivativeSellerSetAside]): NewsSchema.this.Accepted = {
    Accepted.super.this();
    ()
  };
  <synthetic> def copy(from: NewsSchema.this.P = from, to: NewsSchema.this.P = to, derivative: model.Derivative = derivative, price: model.Dollars = price, buyerAside: model.Link[NewsSchema.this.DerivativeBuyerSetAside] = buyerAside, sellerAside: model.Link[NewsSchema.this.DerivativeSellerSetAside] = sellerAside): NewsSchema.this.Accepted = new NewsSchema.this.Accepted(from, to, derivative, price, buyerAside, sellerAside);
  <synthetic> def copy$default$6: model.Link[NewsSchema.this.DerivativeSellerSetAside] @scala.annotation.unchecked.uncheckedVariance = Accepted.this.sellerAside;
  <synthetic> def copy$default$5: model.Link[NewsSchema.this.DerivativeBuyerSetAside] @scala.annotation.unchecked.uncheckedVariance = Accepted.this.buyerAside;
  <synthetic> def copy$default$4: model.Dollars @scala.annotation.unchecked.uncheckedVariance = Accepted.this.price;
  <synthetic> def copy$default$3: model.Derivative @scala.annotation.unchecked.uncheckedVariance = Accepted.this.derivative;
  <synthetic> def copy$default$2: NewsSchema.this.P @scala.annotation.unchecked.uncheckedVariance = Accepted.this.to;
  <synthetic> def copy$default$1: NewsSchema.this.P @scala.annotation.unchecked.uncheckedVariance = Accepted.this.from;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(Accepted.this);
  override def toString(): String = ScalaRunTime.this._toString(Accepted.this);
  override def equals(x$1: Any): Boolean = Accepted.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (from: NewsSchema.this.P, to: NewsSchema.this.P, derivative: model.Derivative, price: model.Dollars, buyerAside: model.Link[NewsSchema.this.DerivativeBuyerSetAside], sellerAside: model.Link[NewsSchema.this.DerivativeSellerSetAside])NewsSchema.this.Accepted((from$2 @ _), (to$2 @ _), (derivative$2 @ _), (price$4 @ _), (buyerAside$1 @ _), (sellerAside$1 @ _)) if from$2.==(from).&&(to$2.==(to)).&&(derivative$2.==(derivative)).&&(price$4.==(price)).&&(buyerAside$1.==(buyerAside)).&&(sellerAside$1.==(sellerAside)) => x$1.asInstanceOf[NewsSchema.this.Accepted].canEqual(Accepted.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "Accepted";
  override def productArity: Int = 6;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => from
    case 1 => to
    case 2 => derivative
    case 3 => price
    case 4 => buyerAside
    case 5 => sellerAside
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[NewsSchema.this.Accepted]()
}
Accepted: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
    from
 buyerAs
 derivat
      to
   price
 sellerA

class PitFailBackend extends java.lang.Object with texttrading.Backend with ScalaObject {
  def this(): texttrading.PitFailBackend = {
    PitFailBackend.super.this();
    ()
  };
  def perform(request: texttrading.Request): texttrading.Response = {
    <synthetic> private[this] val x$1: (String, texttrading.Action) = (request: texttrading.Request @unchecked) match {
      case (username: String, action: texttrading.Action)texttrading.Request((username @ _), (action @ _)) => new (String, texttrading.Action)(username, action)
    };
    val username: String = x$1._1;
    val action: texttrading.Action = x$1._2;
    <synthetic> private[this] val x$2: (model.schema.User, Seq[String]) = (model.schema.User.isNew(username) match {
      case (user: model.schema.User)model.schema.NewUser((user @ _)) => new (model.schema.User, Seq[String])(user, PitFailBackend.this.welcomeGreeting(username))
      case (user: model.schema.User)model.schema.OldUser((user @ _)) => new (model.schema.User, Seq[String])(user, collection.this.Seq.apply[String]())
    }: (model.schema.User, Seq[String]) @unchecked) match {
      case (_1: model.schema.User, _2: Seq[String])(model.schema.User, Seq[String])((user @ _), (greeting @ _)) => new (model.schema.User, Seq[String])(user, greeting)
    };
    val user: model.schema.User = x$2._1;
    val greeting: Seq[String] = x$2._2;
    val status: texttrading.Status = action match {
      case (asset: texttrading.StockAsset)texttrading.Buy((asset @ _)) => new texttrading.WithUser(user).buy(asset)
      case (asset: texttrading.StockAsset)texttrading.Sell((asset @ _)) => new texttrading.WithUser(user).sell(asset)
      case (ticker: String)texttrading.SellAll((ticker @ _)) => new texttrading.WithUser(user).sellAll(ticker)
      case Portfolio => new texttrading.WithUser(user).portfolio
      case (ticker: String)texttrading.GetInfo((a @ _)) => new texttrading.WithUser(user).stockInfo(a)
    };
    new texttrading.Response(status, greeting)
  };
  def welcomeGreeting(name: String): Seq[String] = collection.this.Seq.apply[String](scala.this.Predef.augmentString(scala.this.Predef.augmentString("|Welcome to PitFail, a made-up money trader.\012           |Try it out: %s\012           |").stripMargin).format(texttrading.this.`package`.commandIntro))
}
PitFailBackend: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.500
         perform welcome

case class DerivativeSellerSetAside extends java.lang.Object with model.KL with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val id: model.package.Key = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def id: model.package.Key = DerivativeSellerSetAside.this.id;
  <caseaccessor> <paramaccessor> private[this] val buyer: model.Link[VotingSchema.this.Portfolio] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def buyer: model.Link[VotingSchema.this.Portfolio] = DerivativeSellerSetAside.this.buyer;
  <caseaccessor> <paramaccessor> private[this] val seller: model.Link[VotingSchema.this.Portfolio] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def seller: model.Link[VotingSchema.this.Portfolio] = DerivativeSellerSetAside.this.seller;
  <caseaccessor> <paramaccessor> private[this] val derivative: model.Derivative = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def derivative: model.Derivative = DerivativeSellerSetAside.this.derivative;
  <caseaccessor> <paramaccessor> private[this] val price: model.Dollars = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def price: model.Dollars = DerivativeSellerSetAside.this.price;
  <caseaccessor> <paramaccessor> private[this] val remaining: model.Scale = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def remaining: model.Scale = DerivativeSellerSetAside.this.remaining;
  def this(id: model.package.Key = model.this.`package`.nextID, buyer: model.Link[VotingSchema.this.Portfolio], seller: model.Link[VotingSchema.this.Portfolio], derivative: model.Derivative, price: model.Dollars, remaining: model.Scale): VotingSchema.this.DerivativeSellerSetAside = {
    DerivativeSellerSetAside.super.this();
    ()
  };
  <synthetic> def copy(id: model.package.Key = id, buyer: model.Link[VotingSchema.this.Portfolio] = buyer, seller: model.Link[VotingSchema.this.Portfolio] = seller, derivative: model.Derivative = derivative, price: model.Dollars = price, remaining: model.Scale = remaining): VotingSchema.this.DerivativeSellerSetAside = new VotingSchema.this.DerivativeSellerSetAside(id, buyer, seller, derivative, price, remaining);
  <synthetic> def copy$default$6: model.Scale @scala.annotation.unchecked.uncheckedVariance = DerivativeSellerSetAside.this.remaining;
  <synthetic> def copy$default$5: model.Dollars @scala.annotation.unchecked.uncheckedVariance = DerivativeSellerSetAside.this.price;
  <synthetic> def copy$default$4: model.Derivative @scala.annotation.unchecked.uncheckedVariance = DerivativeSellerSetAside.this.derivative;
  <synthetic> def copy$default$3: model.Link[VotingSchema.this.Portfolio] @scala.annotation.unchecked.uncheckedVariance = DerivativeSellerSetAside.this.seller;
  <synthetic> def copy$default$2: model.Link[VotingSchema.this.Portfolio] @scala.annotation.unchecked.uncheckedVariance = DerivativeSellerSetAside.this.buyer;
  <synthetic> def copy$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = DerivativeSellerSetAside.this.id;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(DerivativeSellerSetAside.this);
  override def toString(): String = ScalaRunTime.this._toString(DerivativeSellerSetAside.this);
  override def equals(x$1: Any): Boolean = DerivativeSellerSetAside.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (id: model.package.Key, buyer: model.Link[VotingSchema.this.Portfolio], seller: model.Link[VotingSchema.this.Portfolio], derivative: model.Derivative, price: model.Dollars, remaining: model.Scale)VotingSchema.this.DerivativeSellerSetAside((id$2 @ _), (buyer$2 @ _), (seller$2 @ _), (derivative$2 @ _), (price$2 @ _), (remaining$2 @ _)) if id$2.==(id).&&(buyer$2.==(buyer)).&&(seller$2.==(seller)).&&(derivative$2.==(derivative)).&&(price$2.==(price)).&&(remaining$2.==(remaining)) => x$1.asInstanceOf[VotingSchema.this.DerivativeSellerSetAside].canEqual(DerivativeSellerSetAside.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "DerivativeSellerSetAside";
  override def productArity: Int = 6;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => id
    case 1 => buyer
    case 2 => seller
    case 3 => derivative
    case 4 => price
    case 5 => remaining
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[VotingSchema.this.DerivativeSellerSetAside]()
}
DerivativeSellerSetAside: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
   price
 remaini
   buyer
      id
  seller
 derivat

case class NotEnoughCash extends java.lang.RuntimeException with errors.package.BadUser with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val have: model.Dollars = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def have: model.Dollars = NotEnoughCash.this.have;
  <caseaccessor> <paramaccessor> private[this] val need: model.Dollars = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def need: model.Dollars = NotEnoughCash.this.need;
  def this(have: model.Dollars, need: model.Dollars): SchemaErrors.this.NotEnoughCash = {
    NotEnoughCash.super.this();
    ()
  };
  <synthetic> def copy(have: model.Dollars = have, need: model.Dollars = need): SchemaErrors.this.NotEnoughCash = new SchemaErrors.this.NotEnoughCash(have, need);
  <synthetic> def copy$default$2: model.Dollars @scala.annotation.unchecked.uncheckedVariance = NotEnoughCash.this.need;
  <synthetic> def copy$default$1: model.Dollars @scala.annotation.unchecked.uncheckedVariance = NotEnoughCash.this.have;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(NotEnoughCash.this);
  override def equals(x$1: Any): Boolean = NotEnoughCash.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (have: model.Dollars, need: model.Dollars)SchemaErrors.this.NotEnoughCash((have$1 @ _), (need$1 @ _)) if have$1.==(have).&&(need$1.==(need)) => x$1.asInstanceOf[SchemaErrors.this.NotEnoughCash].canEqual(NotEnoughCash.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "NotEnoughCash";
  override def productArity: Int = 2;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => have
    case 1 => need
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[SchemaErrors.this.NotEnoughCash]()
}
NotEnoughCash: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
    need
    have

case class Offered extends java.lang.Object with NewsSchema.this.Action with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val from: NewsSchema.this.P = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def from: NewsSchema.this.P = Offered.this.from;
  <caseaccessor> <paramaccessor> private[this] val to: NewsSchema.this.P = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def to: NewsSchema.this.P = Offered.this.to;
  <caseaccessor> <paramaccessor> private[this] val derivative: model.Derivative = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def derivative: model.Derivative = Offered.this.derivative;
  <caseaccessor> <paramaccessor> private[this] val price: model.Dollars = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def price: model.Dollars = Offered.this.price;
  def this(from: NewsSchema.this.P, to: NewsSchema.this.P, derivative: model.Derivative, price: model.Dollars): NewsSchema.this.Offered = {
    Offered.super.this();
    ()
  };
  <synthetic> def copy(from: NewsSchema.this.P = from, to: NewsSchema.this.P = to, derivative: model.Derivative = derivative, price: model.Dollars = price): NewsSchema.this.Offered = new NewsSchema.this.Offered(from, to, derivative, price);
  <synthetic> def copy$default$4: model.Dollars @scala.annotation.unchecked.uncheckedVariance = Offered.this.price;
  <synthetic> def copy$default$3: model.Derivative @scala.annotation.unchecked.uncheckedVariance = Offered.this.derivative;
  <synthetic> def copy$default$2: NewsSchema.this.P @scala.annotation.unchecked.uncheckedVariance = Offered.this.to;
  <synthetic> def copy$default$1: NewsSchema.this.P @scala.annotation.unchecked.uncheckedVariance = Offered.this.from;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(Offered.this);
  override def toString(): String = ScalaRunTime.this._toString(Offered.this);
  override def equals(x$1: Any): Boolean = Offered.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (from: NewsSchema.this.P, to: NewsSchema.this.P, derivative: model.Derivative, price: model.Dollars)NewsSchema.this.Offered((from$1 @ _), (to$1 @ _), (derivative$1 @ _), (price$3 @ _)) if from$1.==(from).&&(to$1.==(to)).&&(derivative$1.==(derivative)).&&(price$3.==(price)) => x$1.asInstanceOf[NewsSchema.this.Offered].canEqual(Offered.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "Offered";
  override def productArity: Int = 4;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => from
    case 1 => to
    case 2 => derivative
    case 3 => price
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[NewsSchema.this.Offered]()
}
Offered: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
    from
 derivat
   price
      to

case class CompSecFormatted extends java.lang.Object with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val c: model.ComparableSecurity = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def c: model.ComparableSecurity = CompSecFormatted.this.c;
  <synthetic> def copy$default$1: model.ComparableSecurity @scala.annotation.unchecked.uncheckedVariance = CompSecFormatted.this.c;
  def this(c: model.ComparableSecurity): formats.package.CompSecFormatted = {
    CompSecFormatted.super.this();
    ()
  };
  def toHumanString: String = CompSecFormatted.this.c match {
    case (ticker: String)model.CompSecStock((ticker @ _)) => ticker
    case (amount: model.Price)model.CompSecDollar((amount @ _)) => amount.$
  };
  <synthetic> def copy(c: model.ComparableSecurity = c): formats.package.CompSecFormatted = new package.this.CompSecFormatted(c);
  override def hashCode(): Int = ScalaRunTime.this._hashCode(CompSecFormatted.this);
  override def toString(): String = ScalaRunTime.this._toString(CompSecFormatted.this);
  override def equals(x$1: Any): Boolean = CompSecFormatted.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (c: model.ComparableSecurity)formats.package.CompSecFormatted((c$1 @ _)) if c$1.==(c) => x$1.asInstanceOf[formats.package.CompSecFormatted].canEqual(CompSecFormatted.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "CompSecFormatted";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => c
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[formats.package.CompSecFormatted]()
}
CompSecFormatted: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
         toHuman
       c     X  

case class FormattedCondition extends java.lang.Object with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val condition: model.Condition = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def condition: model.Condition = FormattedCondition.this.condition;
  def this(condition: model.Condition): formats.package.FormattedCondition = {
    FormattedCondition.super.this();
    ()
  };
  def toHumanString: java.lang.String = FormattedCondition.this.condition match {
    case model.CondAlways => "-"
    case (a: model.ComparableSecurity, b: model.ComparableSecurity)model.CondGreater((a @ _), (b @ _)) => scala.this.Predef.augmentString("%s > %s").format(package.this.compSecFormatted(a).toHumanString, package.this.compSecFormatted(b).toHumanString)
  };
  <synthetic> def copy(condition: model.Condition = condition): formats.package.FormattedCondition = new package.this.FormattedCondition(condition);
  <synthetic> def copy$default$1: model.Condition @scala.annotation.unchecked.uncheckedVariance = FormattedCondition.this.condition;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(FormattedCondition.this);
  override def toString(): String = ScalaRunTime.this._toString(FormattedCondition.this);
  override def equals(x$1: Any): Boolean = FormattedCondition.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (condition: model.Condition)formats.package.FormattedCondition((condition$1 @ _)) if condition$1.==(condition) => x$1.asInstanceOf[formats.package.FormattedCondition].canEqual(FormattedCondition.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "FormattedCondition";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => condition
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[formats.package.FormattedCondition]()
}
FormattedCondition: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
         toHuman
 conditi     X  

final object League extends java.lang.Object with ScalaObject with Serializable {
  def this(): object UserSchema.this.League = {
    League.super.this();
    ()
  };
  private[this] val defaultName: java.lang.String = "default";
  <stable> <accessor> def defaultName: java.lang.String = League.this.defaultName;
  private[this] val defaultStartingCash: model.Dollars = new model.Dollars(math.this.BigDecimal.int2bigDecimal(200000));
  <stable> <accessor> def defaultStartingCash: model.Dollars = League.this.defaultStartingCash;
  def leagueEnsure(name: String): UserSchema.this.League = UserSchema.this.editDB[UserSchema.this.League](UserSchema.this.toOrCreateOpt[UserSchema.this.League](League.this.byName(name)).orCreate(UserSchema.this.toOps[UserSchema.this.League]({
  val x$54: String = name;
  val x$55: model.Dollars = League.this.defaultStartingCash;
  val x$56: model.package.Key = UserSchema.this.League.apply$default$1;
  new UserSchema.this.League(x$56, x$54, x$55)
}).insert(UserSchema.this.leagues)));
  def default(): UserSchema.this.League = League.this.leagueEnsure(League.this.defaultName);
  def byName(name: String): Option[UserSchema.this.League] = UserSchema.this.leagues.filter(((x$23: UserSchema.this.League) => x$23.name.==(name))).headOption;
  def byID(id: model.package.Key): Option[UserSchema.this.League] = UserSchema.this.leagues.lookup(id);
  <synthetic> def apply$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
  <synthetic> def init$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
  case <synthetic> def unapply(x$0: UserSchema.this.League): Option[(model.package.Key, String, model.Dollars)] = if (x$0.==(null))
    scala.this.None
  else
    new Some[(model.package.Key, String, model.Dollars)](new (model.package.Key, String, model.Dollars)(x$0.id, x$0.name, x$0.startingCash));
  case <synthetic> def apply(id: model.package.Key = model.this.`package`.nextID, name: String, startingCash: model.Dollars): UserSchema.this.League = new UserSchema.this.League(id, name, startingCash)
}
League: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.375
         default leagueE    byID  byName

final class $anon extends java.lang.Object with net.liftweb.common.Logger {
  def this(): anonymous class $anon = {
    $anon.super.this();
    ()
  };
  $anon.this.error("An internal error occurred: ".+(e))
}
$anon: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

case class Sold extends java.lang.Object with NewsSchema.this.Action with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val seller: NewsSchema.this.P = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def seller: NewsSchema.this.P = Sold.this.seller;
  <caseaccessor> <paramaccessor> private[this] val stock: String = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def stock: String = Sold.this.stock;
  <caseaccessor> <paramaccessor> private[this] val shares: model.Shares = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def shares: model.Shares = Sold.this.shares;
  <caseaccessor> <paramaccessor> private[this] val dollars: model.Dollars = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def dollars: model.Dollars = Sold.this.dollars;
  <caseaccessor> <paramaccessor> private[this] val price: model.Price = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def price: model.Price = Sold.this.price;
  def this(seller: NewsSchema.this.P, stock: String, shares: model.Shares, dollars: model.Dollars, price: model.Price): NewsSchema.this.Sold = {
    Sold.super.this();
    ()
  };
  <synthetic> def copy(seller: NewsSchema.this.P = seller, stock: String = stock, shares: model.Shares = shares, dollars: model.Dollars = dollars, price: model.Price = price): NewsSchema.this.Sold = new NewsSchema.this.Sold(seller, stock, shares, dollars, price);
  <synthetic> def copy$default$5: model.Price @scala.annotation.unchecked.uncheckedVariance = Sold.this.price;
  <synthetic> def copy$default$4: model.Dollars @scala.annotation.unchecked.uncheckedVariance = Sold.this.dollars;
  <synthetic> def copy$default$3: model.Shares @scala.annotation.unchecked.uncheckedVariance = Sold.this.shares;
  <synthetic> def copy$default$2: String @scala.annotation.unchecked.uncheckedVariance = Sold.this.stock;
  <synthetic> def copy$default$1: NewsSchema.this.P @scala.annotation.unchecked.uncheckedVariance = Sold.this.seller;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(Sold.this);
  override def toString(): String = ScalaRunTime.this._toString(Sold.this);
  override def equals(x$1: Any): Boolean = Sold.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (seller: NewsSchema.this.P, stock: String, shares: model.Shares, dollars: model.Dollars, price: model.Price)NewsSchema.this.Sold((seller$1 @ _), (stock$2 @ _), (shares$2 @ _), (dollars$2 @ _), (price$2 @ _)) if seller$1.==(seller).&&(stock$2.==(stock)).&&(shares$2.==(shares)).&&(dollars$2.==(dollars)).&&(price$2.==(price)) => x$1.asInstanceOf[NewsSchema.this.Sold].canEqual(Sold.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "Sold";
  override def productArity: Int = 5;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => seller
    case 1 => stock
    case 2 => shares
    case 3 => dollars
    case 4 => price
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[NewsSchema.this.Sold]()
}
Sold: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
  seller
 dollars
   price
   stock
  shares

class StockUpdates extends HttpServlet {
  import StockUpdates._;
  def this() = _;
  protected[servlets] def doPost(request: HttpServletRequest = _, response: HttpServletResponse = _): Unit = _
}
StockUpdates: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
          doPost

case class Quote extends java.lang.Object with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val stock: stockdata.Stock = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def stock: stockdata.Stock = Quote.this.stock;
  <caseaccessor> <paramaccessor> private[this] val exchange: String = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def exchange: String = Quote.this.exchange;
  <caseaccessor> <paramaccessor> private[this] val company: String = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def company: String = Quote.this.company;
  <caseaccessor> <paramaccessor> private[this] val price: model.Price = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def price: model.Price = Quote.this.price;
  <caseaccessor> <paramaccessor> private[this] val updateTime: org.joda.time.DateTime = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def updateTime: org.joda.time.DateTime = Quote.this.updateTime;
  <caseaccessor> <paramaccessor> private[this] val info: stockdata.QuoteInfo = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def info: stockdata.QuoteInfo = Quote.this.info;
  def this(stock: stockdata.Stock, exchange: String, company: String, price: model.Price, updateTime: org.joda.time.DateTime, info: stockdata.QuoteInfo): stockdata.Quote = {
    Quote.super.this();
    ()
  };
  private[this] val toString: String = scala.this.Predef.augmentString("%s=%s").format(Quote.this.stock.toString, Quote.this.price.toString());
  override <stable> <accessor> def toString: String = Quote.this.toString;
  override def equals(that: Any): Boolean = that match {
    case (stock: stockdata.Stock, exchange: String, company: String, price: model.Price, updateTime: org.joda.time.DateTime, info: stockdata.QuoteInfo)stockdata.Quote((thatStock @ _), (thatExchange @ _), _, (thatPrice @ _), (thatTime @ _), _) => Quote.this.stock.==(thatStock).&&(Quote.this.exchange.==(thatExchange)).&&(Quote.this.price.==(thatPrice)).&&(Quote.this.updateTime.==(thatTime))
    case _ => false
  };
  <synthetic> def copy(stock: stockdata.Stock = stock, exchange: String = exchange, company: String = company, price: model.Price = price, updateTime: org.joda.time.DateTime = updateTime, info: stockdata.QuoteInfo = info): stockdata.Quote = new stockdata.this.Quote(stock, exchange, company, price, updateTime, info);
  <synthetic> def copy$default$6: stockdata.QuoteInfo @scala.annotation.unchecked.uncheckedVariance = Quote.this.info;
  <synthetic> def copy$default$5: org.joda.time.DateTime @scala.annotation.unchecked.uncheckedVariance = Quote.this.updateTime;
  <synthetic> def copy$default$4: model.Price @scala.annotation.unchecked.uncheckedVariance = Quote.this.price;
  <synthetic> def copy$default$3: String @scala.annotation.unchecked.uncheckedVariance = Quote.this.company;
  <synthetic> def copy$default$2: String @scala.annotation.unchecked.uncheckedVariance = Quote.this.exchange;
  <synthetic> def copy$default$1: stockdata.Stock @scala.annotation.unchecked.uncheckedVariance = Quote.this.stock;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(Quote.this);
  override def productPrefix: java.lang.String = "Quote";
  override def productArity: Int = 6;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => stock
    case 1 => exchange
    case 2 => company
    case 3 => price
    case 4 => updateTime
    case 5 => info
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[stockdata.Quote]()
}
Quote: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
 company
   stock
 updateT
    info
 exchang
   price

final object HttpQueryService extends java.lang.Object with ScalaObject {
  def this(): object stockdata.HttpQueryService = {
    HttpQueryService.super.this();
    ()
  };
  def buildQuery(params: Iterable[(String, String)], encoding: String): String = params.map[java.lang.String, Iterable[java.lang.String]](((x0$1: (String, String)) => x0$1 match {
  case (_1: String, _2: String)(String, String)((key @ _), (value @ _)) => java.net.URLEncoder.encode(key, encoding).+("=").+(java.net.URLEncoder.encode(value, encoding))
}))(collection.this.Iterable.canBuildFrom[java.lang.String]).mkString("&");
  def parseQuery(query: String, encoding: String): scala.collection.immutable.ListMap[String,String] = scala.collection.immutable.ListMap.apply[java.lang.String, java.lang.String]((scala.this.Predef.refArrayOps[java.lang.String](query.split("&")).map[(java.lang.String, java.lang.String), Array[(java.lang.String, java.lang.String)]](((x$1: java.lang.String) => x$1.split("=") match {
    case scala.Array.unapplySeq[java.lang.String](<unapply-selector>) <unapply> ((encodedKey @ _), (encodedValue @ _)) => new (java.lang.String, java.lang.String)(java.net.URLDecoder.decode(encodedKey, encoding), java.net.URLDecoder.decode(encodedValue, encoding))
  }))(scala.this.Array.canBuildFrom[(java.lang.String, java.lang.String)](reflect.this.ClassManifest.classType[(java.lang.String, java.lang.String)](classOf[scala.Tuple2], reflect.this.ClassManifest.classType[java.lang.String](classOf[java.lang.String]), reflect.this.ClassManifest.classType[java.lang.String](classOf[java.lang.String])))): _*))
}
HttpQueryService: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.750
         parseQu buildQu

case class BadFieldInput extends scala.`package`.Exception with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val cause: intform.BasicErrors = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def cause: intform.BasicErrors = BadFieldInput.this.cause;
  <caseaccessor> <paramaccessor> private[this] val msg: String = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def msg: String = BadFieldInput.this.msg;
  def this(cause: intform.BasicErrors, msg: String): intform.BadFieldInput = {
    BadFieldInput.super.this();
    ()
  };
  <synthetic> def copy(cause: intform.BasicErrors = cause, msg: String = msg): intform.BadFieldInput = new intform.this.BadFieldInput(cause, msg);
  <synthetic> def copy$default$2: String @scala.annotation.unchecked.uncheckedVariance = BadFieldInput.this.msg;
  <synthetic> def copy$default$1: intform.BasicErrors @scala.annotation.unchecked.uncheckedVariance = BadFieldInput.this.cause;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(BadFieldInput.this);
  override def equals(x$1: Any): Boolean = BadFieldInput.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (cause: intform.BasicErrors, msg: String)intform.BadFieldInput((cause$1 @ _), (msg$2 @ _)) if cause$1.==(cause).&&(msg$2.==(msg)) => x$1.asInstanceOf[intform.BadFieldInput].canEqual(BadFieldInput.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "BadFieldInput";
  override def productArity: Int = 2;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => cause
    case 1 => msg
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[intform.BadFieldInput]()
}
BadFieldInput: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
   cause
     msg

class Boot extends java.lang.Object with net.liftweb.common.Loggable with ScalaObject {
  def this(): bootstrap.liftweb.Boot = {
    Boot.super.this();
    ()
  };
  def boot: Unit = {
    org.apache.log4j.PropertyConfigurator.configure("log4j.properties");
    java.this.lang.System.err.println("\033[42m--------------------------------------------------------\033[0m");
    java.this.lang.System.err.println();
    java.this.lang.System.err.println("\033[42m--------------------------------------------------------\033[0m");
    java.this.lang.System.err.println();
    val lr: net.liftweb.http.LiftRules = net.liftweb.http.LiftRules.realInstance;
    http.this.LiftRulesMocker.toLiftRules(net.liftweb.http.LiftRules).passNotFoundToChain_=(true);
    http.this.LiftRulesMocker.toLiftRules(net.liftweb.http.LiftRules).liftRequest.append(((x0$1: net.liftweb.http.Req) => x0$1 match {
      case (req @ _) if req.path.partPath match {
        case (hd: String, tl: List[String])collection.immutable.::[String]("servlet", _) => true
        case _ => false
      } => false
    }));
    http.this.LiftRulesMocker.toLiftRules(net.liftweb.http.LiftRules).addToPackages("code");
    val entries: List[net.liftweb.sitemap.Menu.Menuable with net.liftweb.sitemap.Menu.WithSlash] = immutable.this.List.apply[net.liftweb.sitemap.Menu.Menuable with net.liftweb.sitemap.Menu.WithSlash](net.liftweb.sitemap.Menu.i("Home")./(sitemap.this.LocPath.stringToLocPath("index")), net.liftweb.sitemap.Menu.i("Test")./(sitemap.this.LocPath.stringToLocPath("testform")), net.liftweb.sitemap.Menu.i("Schema")./(sitemap.this.LocPath.stringToLocPath("schema")), net.liftweb.sitemap.Menu.i("1")./(sitemap.this.LocPath.stringToLocPath("auction")), net.liftweb.sitemap.Menu.i("2")./(sitemap.this.LocPath.stringToLocPath("user")), net.liftweb.sitemap.Menu.i("3")./(sitemap.this.LocPath.stringToLocPath("event")), net.liftweb.sitemap.Menu.i("4")./(sitemap.this.LocPath.stringToLocPath("auto")), net.liftweb.sitemap.Menu.i("5")./(sitemap.this.LocPath.stringToLocPath("new-portfolio")), net.liftweb.sitemap.Menu.i("6")./(sitemap.this.LocPath.stringToLocPath("my-portfolio")), net.liftweb.sitemap.Menu.i("7")./(sitemap.this.LocPath.stringToLocPath("portfolio")));
    lr.setSiteMap(net.liftweb.sitemap.SiteMap.apply((entries: _*)));
    lr.early.append(((x$1: net.liftweb.http.provider.HTTPRequest) => x$1.setCharacterEncoding("UTF-8")));
    lr.dispatch.append(code.control.Logout.dispatchPF);
    lr.dispatch.append(code.control.OpenIDLogin.dispatchPF);
    lr.dispatch.append(code.control.TwitterLogin.dispatchPF);
    DBSetup.apply();
    code.control.Checker.run();
    insertTestData.apply()
  }
}
Boot: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
            boot

sealed abstract trait Status extends scala.AnyRef
Status: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

abstract trait DateRender extends java.lang.Object with intform.TextRender with ScalaObject {
  def /*DateRender*/$init$(): Unit = {
    ()
  };
  def format: scala.xml.NodeSeq = {
    {
      new scala.xml.Elem(null, "span", scala.xml.Null, scala.this.Predef.$scope, ({
        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
        $buf.&+(DateField.formatSpec);
        $buf
      }: _*))
    }
  }
}
DateRender: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
          format

case class SellAll extends Action with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val ticker: String = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def ticker: String = SellAll.this.ticker;
  def this(ticker: String): texttrading.SellAll = {
    SellAll.super.this();
    ()
  };
  override def toString: java.lang.String = "Sold all of ".+(SellAll.this.ticker).+(".");
  <synthetic> def copy(ticker: String = ticker): texttrading.SellAll = new texttrading.this.SellAll(ticker);
  <synthetic> def copy$default$1: String @scala.annotation.unchecked.uncheckedVariance = SellAll.this.ticker;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(SellAll.this);
  override def equals(x$1: Any): Boolean = SellAll.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (ticker: String)texttrading.SellAll((ticker$2 @ _)) if ticker$2.==(ticker) => x$1.asInstanceOf[texttrading.SellAll].canEqual(SellAll.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "SellAll";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => ticker
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[texttrading.SellAll]()
}
SellAll: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
  ticker

final case object NegativeVolume extends java.lang.RuntimeException with errors.package.BadUser with ScalaObject with Product with Serializable {
  def this(): object SchemaErrors.this.NegativeVolume = {
    NegativeVolume.super.this();
    ()
  };
  final override def hashCode(): Int = 1232007119;
  override def productPrefix: java.lang.String = "NegativeVolume";
  override def productArity: Int = 0;
  override def productElement(x$1: Int): Any = x$1 match {
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[object SchemaErrors.this.NegativeVolume]()
}
NegativeVolume: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

case class Portfolio extends java.lang.Object with model.KL with UserSchema.this.PortfolioOps with UserSchema.this.PortfolioWithStocks with UserSchema.this.PortfolioWithDerivatives with UserSchema.this.PortfolioWithAuctions with UserSchema.this.PortfolioWithVotes with UserSchema.this.PortfolioWithAutoTrades with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val id: model.package.Key = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def id: model.package.Key = Portfolio.this.id;
  <caseaccessor> <paramaccessor> private[this] val league: model.Link[UserSchema.this.League] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def league: model.Link[UserSchema.this.League] = Portfolio.this.league;
  <caseaccessor> <paramaccessor> private[this] val name: String = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def name: String = Portfolio.this.name;
  <caseaccessor> <paramaccessor> private[this] val cash: model.Dollars = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def cash: model.Dollars = Portfolio.this.cash;
  <caseaccessor> <paramaccessor> private[this] val loan: model.Dollars = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def loan: model.Dollars = Portfolio.this.loan;
  <caseaccessor> <paramaccessor> private[this] val rank: Int = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def rank: Int = Portfolio.this.rank;
  def this(id: model.package.Key = model.this.`package`.nextID, league: model.Link[UserSchema.this.League], name: String, cash: model.Dollars, loan: model.Dollars, rank: Int): UserSchema.this.Portfolio = {
    Portfolio.super.this();
    ()
  };
  <synthetic> def copy$default$6: Int @scala.annotation.unchecked.uncheckedVariance = Portfolio.this.rank;
  <synthetic> def copy$default$5: model.Dollars @scala.annotation.unchecked.uncheckedVariance = Portfolio.this.loan;
  <synthetic> def copy$default$4: model.Dollars @scala.annotation.unchecked.uncheckedVariance = Portfolio.this.cash;
  <synthetic> def copy$default$3: String @scala.annotation.unchecked.uncheckedVariance = Portfolio.this.name;
  <synthetic> def copy$default$2: model.Link[UserSchema.this.League] @scala.annotation.unchecked.uncheckedVariance = Portfolio.this.league;
  <synthetic> def copy$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = Portfolio.this.id;
  <synthetic> def copy(id: model.package.Key = id, league: model.Link[UserSchema.this.League] = league, name: String = name, cash: model.Dollars = cash, loan: model.Dollars = loan, rank: Int = rank): UserSchema.this.Portfolio = new UserSchema.this.Portfolio(id, league, name, cash, loan, rank);
  override def hashCode(): Int = ScalaRunTime.this._hashCode(Portfolio.this);
  override def toString(): String = ScalaRunTime.this._toString(Portfolio.this);
  override def equals(x$1: Any): Boolean = Portfolio.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (id: model.package.Key, league: model.Link[UserSchema.this.League], name: String, cash: model.Dollars, loan: model.Dollars, rank: Int)UserSchema.this.Portfolio((id$2 @ _), (league$1 @ _), (name$1 @ _), (cash$1 @ _), (loan$1 @ _), (rank$1 @ _)) if id$2.==(id).&&(league$1.==(league)).&&(name$1.==(name)).&&(cash$1.==(cash)).&&(loan$1.==(loan)).&&(rank$1.==(rank)) => x$1.asInstanceOf[UserSchema.this.Portfolio].canEqual(Portfolio.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "Portfolio";
  override def productArity: Int = 6;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => id
    case 1 => league
    case 2 => name
    case 3 => cash
    case 4 => loan
    case 5 => rank
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[UserSchema.this.Portfolio]()
}
Portfolio: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
    cash
  league
    rank
      id
    loan
    name

final object SharesField extends java.lang.Object with ScalaObject {
  def this(): object code.snippet.SharesField = {
    SharesField.super.this();
    ()
  };
  def apply(i: String = ""): code.snippet.SharesField = new SharesField(i);
  <synthetic> def apply$default$1: String @scala.annotation.unchecked.uncheckedVariance = ""
}
SharesField: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
           apply

abstract trait RefreshHub extends java.lang.Object with net.liftweb.actor.LiftActor with net.liftweb.http.ListenerManager with net.liftweb.common.Loggable with ScalaObject {
  def /*RefreshHub*/$init$(): Unit = {
    ()
  };
  def createUpdate: object model.Refresh = Refresh;
  override def lowPriority: PartialFunction[Any,Unit] = ((x0$1: Any) => x0$1 match {
    case Refresh => RefreshHub.this.updateListeners()
  });
  def apply(): Unit = this.!(Refresh)
}
RefreshHub: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=1.000
         createU   apply lowPrio

case class DerivativeBuyerVote extends java.lang.Object with model.KL with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val id: model.package.Key = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def id: model.package.Key = DerivativeBuyerVote.this.id;
  <caseaccessor> <paramaccessor> private[this] val caster: model.Link[VotingSchema.this.Portfolio] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def caster: model.Link[VotingSchema.this.Portfolio] = DerivativeBuyerVote.this.caster;
  <caseaccessor> <paramaccessor> private[this] val event: model.Link[VotingSchema.this.NewsEvent] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def event: model.Link[VotingSchema.this.NewsEvent] = DerivativeBuyerVote.this.event;
  def this(id: model.package.Key = model.this.`package`.nextID, caster: model.Link[VotingSchema.this.Portfolio], event: model.Link[VotingSchema.this.NewsEvent]): VotingSchema.this.DerivativeBuyerVote = {
    DerivativeBuyerVote.super.this();
    ()
  };
  <synthetic> def copy(id: model.package.Key = id, caster: model.Link[VotingSchema.this.Portfolio] = caster, event: model.Link[VotingSchema.this.NewsEvent] = event): VotingSchema.this.DerivativeBuyerVote = new VotingSchema.this.DerivativeBuyerVote(id, caster, event);
  <synthetic> def copy$default$3: model.Link[VotingSchema.this.NewsEvent] @scala.annotation.unchecked.uncheckedVariance = DerivativeBuyerVote.this.event;
  <synthetic> def copy$default$2: model.Link[VotingSchema.this.Portfolio] @scala.annotation.unchecked.uncheckedVariance = DerivativeBuyerVote.this.caster;
  <synthetic> def copy$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = DerivativeBuyerVote.this.id;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(DerivativeBuyerVote.this);
  override def toString(): String = ScalaRunTime.this._toString(DerivativeBuyerVote.this);
  override def equals(x$1: Any): Boolean = DerivativeBuyerVote.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (id: model.package.Key, caster: model.Link[VotingSchema.this.Portfolio], event: model.Link[VotingSchema.this.NewsEvent])VotingSchema.this.DerivativeBuyerVote((id$3 @ _), (caster$1 @ _), (event$1 @ _)) if id$3.==(id).&&(caster$1.==(caster)).&&(event$1.==(event)) => x$1.asInstanceOf[VotingSchema.this.DerivativeBuyerVote].canEqual(DerivativeBuyerVote.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "DerivativeBuyerVote";
  override def productArity: Int = 3;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => id
    case 1 => caster
    case 2 => event
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[VotingSchema.this.DerivativeBuyerVote]()
}
DerivativeBuyerVote: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
   event
  caster
      id

class Dashboard extends java.lang.Object with code.comet.Refreshable with net.liftweb.common.Loggable with ScalaObject {
  def this(): code.comet.Dashboard = {
    Dashboard.super.this();
    ()
  };
  def registerWith: model.Table[model.schema.StockAsset] = model.schema.stockAssets;
  def render: net.liftweb.http.RenderOut = model.schema.readDB[net.liftweb.http.RenderOut]({
    try {
      val user: model.schema.User = control.LoginManager.currentUser;
      val ports: List[model.schema.Portfolio] = user.myPortfolios;
      if (ports.length.==(0))
        {
          {
            Dashboard.this.arrayToRenderOut(new scala.xml.Elem(null, "p", scala.xml.Null, scala.this.Predef.$scope, ({
              val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
              $buf.&+(new scala.xml.Text("You have no portfolios. "));
              $buf.&+({
                {
                  var $md: scala.xml.MetaData = scala.xml.Null;
                  $md = new scala.xml.UnprefixedAttribute("href", new scala.xml.Text("/create-portfolio"), $md);
                  new scala.xml.Elem(null, "a", $md, scala.this.Predef.$scope, ({
                    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                    $buf.&+(new scala.xml.Text("Create one"));
                    $buf
                  }: _*))
                }
              });
              $buf.&+(new scala.xml.Text("."));
              $buf
            }: _*)))
          }
        }
      else
        {
          val current: model.schema.Portfolio = control.PortfolioSwitcher.currentPortfolio;
          val body: Seq[scala.xml.Node] with Serializable = if (ports.length.==(1))
            snippet.portfolio.apply(control.PortfolioSwitcher.currentPortfolio, new Some[model.schema.User](user), true)
          else
            {
              val tabs: List[scala.xml.Elem] = ports.map[scala.xml.Elem, List[scala.xml.Elem]](((port: model.schema.Portfolio) => if (port.~~(current))
                {
                  {
                    var $md: scala.xml.MetaData = scala.xml.Null;
                    $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("tab active"), $md);
                    new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                      $buf.&+(new scala.xml.Text("\012                                    "));
                      $buf.&+({
                        {
                          new scala.xml.Elem(null, "p", scala.xml.Null, scala.this.Predef.$scope, ({
                            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                            $buf.&+(port.name);
                            $buf
                          }: _*))
                        }
                      });
                      $buf.&+(new scala.xml.Text("\012                                "));
                      $buf
                    }: _*))
                  }
                }
              else
                {
                  {
                    var $md: scala.xml.MetaData = scala.xml.Null;
                    $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("tab inactive"), $md);
                    new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                      $buf.&+(new scala.xml.Text("\012                                    "));
                      $buf.&+({
                        {
                          new scala.xml.Elem(null, "p", scala.xml.Null, scala.this.Predef.$scope, ({
                            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                            $buf.&+({
                              {
                                var $md: scala.xml.MetaData = scala.xml.Null;
                                $md = new scala.xml.UnprefixedAttribute("href", "/my-portfolio?name=".+(port.name), $md);
                                new scala.xml.Elem(null, "a", $md, scala.this.Predef.$scope, ({
                                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                                  $buf.&+(port.name);
                                  $buf
                                }: _*))
                              }
                            });
                            $buf
                          }: _*))
                        }
                      });
                      $buf.&+(new scala.xml.Text("\012                                "));
                      $buf
                    }: _*))
                  }
                }))(immutable.this.List.canBuildFrom[scala.xml.Elem]);
              {
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+({
                  {
                    var $md: scala.xml.MetaData = scala.xml.Null;
                    $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("tab-bar"), $md);
                    new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                      $buf.&+(new scala.xml.Text("\012                            "));
                      $buf.&+(tabs);
                      $buf.&+(new scala.xml.Text("\012                        "));
                      $buf
                    }: _*))
                  }
                });
                $buf.&+({
                  {
                    var $md: scala.xml.MetaData = scala.xml.Null;
                    $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("tab-pane"), $md);
                    new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                      $buf.&+(new scala.xml.Text("\012                            "));
                      $buf.&+(snippet.portfolio.apply(current, new Some[model.schema.User](user), true));
                      $buf.&+(new scala.xml.Text("\012                        "));
                      $buf
                    }: _*))
                  }
                });
                $buf
              }
            };
          Dashboard.this.arrayToRenderOut(body)
        }
    } catch {
      case control.LoginManager.NotLoggedIn => {
        {
          Dashboard.this.arrayToRenderOut(new scala.xml.Elem(null, "p", scala.xml.Null, scala.this.Predef.$scope, ({
            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
            $buf.&+(new scala.xml.Text("Login to view your portfolio"));
            $buf
          }: _*)))
        }
      }
    }
  })
}
Dashboard: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=1.000
          render registe

abstract trait DividendSchema extends java.lang.Object with ScalaObject { schema: model.DividendSchema with model.DBMagic with model.UserSchema with model.StockSchema with model.SchemaErrors with model.NewsSchema => 
  def /*DividendSchema*/$init$(): Unit = {
    ()
  };
  private[this] val dividendPayments: model.Table[DividendSchema.this.DividendPayment] = DividendSchema.this.table[DividendSchema.this.DividendPayment];
  implicit <stable> <accessor> def dividendPayments: model.Table[DividendSchema.this.DividendPayment] = DividendSchema.this.dividendPayments;
  case class DividendPayment extends java.lang.Object with model.KL with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val id: model.package.Key = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def id: model.package.Key = DividendPayment.this.id;
    <caseaccessor> <paramaccessor> private[this] val owner: model.Link[DividendSchema.this.Portfolio] = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def owner: model.Link[DividendSchema.this.Portfolio] = DividendPayment.this.owner;
    <caseaccessor> <paramaccessor> private[this] val ticker: String = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def ticker: String = DividendPayment.this.ticker;
    <caseaccessor> <paramaccessor> private[this] val dollars: model.Dollars = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def dollars: model.Dollars = DividendPayment.this.dollars;
    <caseaccessor> <paramaccessor> private[this] val date: org.joda.time.DateTime = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def date: org.joda.time.DateTime = DividendPayment.this.date;
    def this(id: model.package.Key = model.this.`package`.nextID, owner: model.Link[DividendSchema.this.Portfolio], ticker: String, dollars: model.Dollars, date: org.joda.time.DateTime): DividendSchema.this.DividendPayment = {
      DividendPayment.super.this();
      ()
    };
    <synthetic> def copy(id: model.package.Key = id, owner: model.Link[DividendSchema.this.Portfolio] = owner, ticker: String = ticker, dollars: model.Dollars = dollars, date: org.joda.time.DateTime = date): DividendSchema.this.DividendPayment = new DividendSchema.this.DividendPayment(id, owner, ticker, dollars, date);
    <synthetic> def copy$default$5: org.joda.time.DateTime @scala.annotation.unchecked.uncheckedVariance = DividendPayment.this.date;
    <synthetic> def copy$default$4: model.Dollars @scala.annotation.unchecked.uncheckedVariance = DividendPayment.this.dollars;
    <synthetic> def copy$default$3: String @scala.annotation.unchecked.uncheckedVariance = DividendPayment.this.ticker;
    <synthetic> def copy$default$2: model.Link[DividendSchema.this.Portfolio] @scala.annotation.unchecked.uncheckedVariance = DividendPayment.this.owner;
    <synthetic> def copy$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = DividendPayment.this.id;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(DividendPayment.this);
    override def toString(): String = ScalaRunTime.this._toString(DividendPayment.this);
    override def equals(x$1: Any): Boolean = DividendPayment.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (id: model.package.Key, owner: model.Link[DividendSchema.this.Portfolio], ticker: String, dollars: model.Dollars, date: org.joda.time.DateTime)DividendSchema.this.DividendPayment((id$1 @ _), (owner$1 @ _), (ticker$1 @ _), (dollars$1 @ _), (date$1 @ _)) if id$1.==(id).&&(owner$1.==(owner)).&&(ticker$1.==(ticker)).&&(dollars$1.==(dollars)).&&(date$1.==(date)) => x$1.asInstanceOf[DividendSchema.this.DividendPayment].canEqual(DividendPayment.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "DividendPayment";
    override def productArity: Int = 5;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => id
      case 1 => owner
      case 2 => ticker
      case 3 => dollars
      case 4 => date
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[DividendSchema.this.DividendPayment]()
  };
  final <synthetic> object DividendPayment extends scala.runtime.AbstractFunction5[model.package.Key,model.Link[DividendSchema.this.Portfolio],String,model.Dollars,org.joda.time.DateTime,DividendSchema.this.DividendPayment] with ScalaObject with Serializable {
    def this(): object DividendSchema.this.DividendPayment = {
      DividendPayment.super.this();
      ()
    };
    final override def toString(): java.lang.String = "DividendPayment";
    <synthetic> def apply$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
    <synthetic> def init$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
    case <synthetic> def unapply(x$0: DividendSchema.this.DividendPayment): Option[(model.package.Key, model.Link[DividendSchema.this.Portfolio], String, model.Dollars, org.joda.time.DateTime)] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(model.package.Key, model.Link[DividendSchema.this.Portfolio], String, model.Dollars, org.joda.time.DateTime)](new (model.package.Key, model.Link[DividendSchema.this.Portfolio], String, model.Dollars, org.joda.time.DateTime)(x$0.id, x$0.owner, x$0.ticker, x$0.dollars, x$0.date));
    case <synthetic> def apply(id: model.package.Key = model.this.`package`.nextID, owner: model.Link[DividendSchema.this.Portfolio], ticker: String, dollars: model.Dollars, date: org.joda.time.DateTime): DividendSchema.this.DividendPayment = new DividendSchema.this.DividendPayment(id, owner, ticker, dollars, date)
  };
  @volatile <synthetic> private[this] var DividendPayment$module: object DividendSchema.this.DividendPayment = _;
  final <synthetic> <stable> def DividendPayment: object DividendSchema.this.DividendPayment = new object DividendSchema.this.DividendPayment();
  def systemCheckForDividends(): scala.collection.mutable.ArrayBuffer[Unit] = DividendSchema.this.editDB[scala.collection.mutable.ArrayBuffer[Unit]](DividendSchema.this.checkForDividends);
  private[model] def checkForDividends: DividendSchema.this.Transaction[scala.collection.mutable.ArrayBuffer[Unit]] = scalaz.Scalaz.SeqMA[scala.collection.mutable.ArrayBuffer, DividendSchema.this.Transaction[Unit]]({
  val now: org.joda.time.DateTime = new org.joda.time.DateTime();
  DividendSchema.this.stockAssets.map[DividendSchema.this.Transaction[Unit], scala.collection.mutable.ArrayBuffer[DividendSchema.this.Transaction[Unit]]](((asset: DividendSchema.this.StockAsset) => {
    val dividends: Seq[stockdata.Dividend] = Stocks.recentDividends(asset.ticker);
    val newDividends: Seq[stockdata.Dividend] = dividends.filter(((d: stockdata.Dividend) => d.date.isAfter(asset.lastDividendDate).&&(d.date.isBefore(now))));
    val totalPrice: model.Price = new model.Price(newDividends.map[scala.math.BigDecimal, Seq[scala.math.BigDecimal]](((x$1: stockdata.Dividend) => x$1.price.price))(collection.this.Seq.canBuildFrom[scala.math.BigDecimal]).sum[scala.math.BigDecimal](math.this.Numeric.BigDecimalIsFractional));
    val dollars: model.Dollars = totalPrice.*(asset.shares);
    DividendSchema.this.toOps[DividendSchema.this.StockAsset](asset).update(((a: DividendSchema.this.StockAsset) => {
  val x$2: org.joda.time.DateTime = new org.joda.time.DateTime();
  val x$3: model.Dollars = a.totalDividends.+(dollars);
  val x$4: model.package.Key = a.copy$default$1;
  val x$5: String = a.copy$default$2;
  val x$6: model.Shares = a.copy$default$3;
  val x$7: model.Link[DividendSchema.this.Portfolio] = a.copy$default$4;
  val x$8: model.Price = a.copy$default$5;
  val x$9: model.Price = a.copy$default$6;
  val x$10: org.joda.time.DateTime = a.copy$default$7;
  a.copy(x$4, x$5, x$6, x$7, x$8, x$9, x$10, x$2, x$3)
}))(DividendSchema.this.stockAssets).flatMap[Unit](((_: Unit) => DividendSchema.this.toOps[DividendSchema.this.Portfolio](asset.owner.extract(DividendSchema.this.portfolios)).update(((p: DividendSchema.this.Portfolio) => {
  val x$11: model.Dollars = p.cash.+(dollars);
  val x$12: model.package.Key = p.copy$default$1;
  val x$13: model.Link[DividendSchema.this.League] = p.copy$default$2;
  val x$14: String = p.copy$default$3;
  val x$15: model.Dollars = p.copy$default$5;
  val x$16: Int = p.copy$default$6;
  p.copy(x$12, x$13, x$14, x$11, x$15, x$16)
}))(DividendSchema.this.portfolios).flatMap[Unit](((_: Unit) => DividendSchema.this.toOps[DividendSchema.this.DividendPayment]({
  val x$17: String = asset.ticker;
  val x$18: model.Link[DividendSchema.this.Portfolio] = asset.owner;
  val x$19: model.Dollars = dollars;
  val x$20: org.joda.time.DateTime = now;
  val x$21: model.package.Key = DividendSchema.this.DividendPayment.apply$default$1;
  new DividendSchema.this.DividendPayment(x$21, x$18, x$17, x$19, x$20)
}).insert(DividendSchema.this.dividendPayments).map[Unit](((_: DividendSchema.this.DividendPayment) => ()))))))
  }))(mutable.this.ArrayBuffer.canBuildFrom[DividendSchema.this.Transaction[Unit]])
}).sequence[DividendSchema.this.Transaction, Unit](scala.this.Predef.conforms[DividendSchema.this.Transaction[Unit]], scalaz.this.Traverse.TraversableTraverse[scala.collection.mutable.ArrayBuffer](scalaz.this.CanBuildAnySelf.GenericCanBuildSelf[scala.collection.mutable.ArrayBuffer](mutable.this.ArrayBuffer.canBuildFrom[Nothing])), scalaz.this.Applicative.applicative[DividendSchema.this.Transaction](DividendSchema.this.TransactionPure, scalaz.this.Apply.FunctorBindApply[DividendSchema.this.Transaction](DividendSchema.this.TransactionFunctor, DividendSchema.this.TransactionBind)))
}
DividendSchema: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=1.000
         checkFo systemC
 Dividen                

final object AuctionOffer extends java.lang.Object with ScalaObject with Serializable {
  def this(): object AuctionSchema.this.AuctionOffer = {
    AuctionOffer.super.this();
    ()
  };
  def byID(id: model.package.Key): AuctionSchema.this.AuctionOffer = AuctionSchema.this.auctionOffers.lookup(id).getOrElse[AuctionSchema.this.AuctionOffer](throw AuctionSchema.this.NoSuchAuction);
  <synthetic> def init$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
  case <synthetic> def unapply(x$0: AuctionSchema.this.AuctionOffer): Option[(model.package.Key, model.Derivative, model.Link[AuctionSchema.this.Portfolio], model.Dollars, org.joda.time.DateTime, org.joda.time.DateTime)] = if (x$0.==(null))
    scala.this.None
  else
    new Some[(model.package.Key, model.Derivative, model.Link[AuctionSchema.this.Portfolio], model.Dollars, org.joda.time.DateTime, org.joda.time.DateTime)](new (model.package.Key, model.Derivative, model.Link[AuctionSchema.this.Portfolio], model.Dollars, org.joda.time.DateTime, org.joda.time.DateTime)(x$0.id, x$0.derivative, x$0.offerer, x$0.price, x$0.when, x$0.expires));
  case <synthetic> def apply(id: model.package.Key = model.this.`package`.nextID, derivative: model.Derivative, offerer: model.Link[AuctionSchema.this.Portfolio], price: model.Dollars, when: org.joda.time.DateTime, expires: org.joda.time.DateTime): AuctionSchema.this.AuctionOffer = new AuctionSchema.this.AuctionOffer(id, derivative, offerer, price, when, expires);
  <synthetic> def apply$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID
}
AuctionOffer: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
            byID

sealed abstract class Action extends java.lang.Object with ScalaObject {
  def this(): texttrading.Action = {
    Action.super.this();
    ()
  }
}
Action: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

case class CompSecDollar extends ComparableSecurity with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val amount: model.Price = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def amount: model.Price = CompSecDollar.this.amount;
  def this(amount: model.Price): model.CompSecDollar = {
    CompSecDollar.super.this();
    ()
  };
  def toPrice: model.Price = CompSecDollar.this.amount;
  <synthetic> def copy(amount: model.Price = amount): model.CompSecDollar = new model.this.CompSecDollar(amount);
  <synthetic> def copy$default$1: model.Price @scala.annotation.unchecked.uncheckedVariance = CompSecDollar.this.amount;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(CompSecDollar.this);
  override def toString(): String = ScalaRunTime.this._toString(CompSecDollar.this);
  override def equals(x$1: Any): Boolean = CompSecDollar.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (amount: model.Price)model.CompSecDollar((amount$2 @ _)) if amount$2.==(amount) => x$1.asInstanceOf[model.CompSecDollar].canEqual(CompSecDollar.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "CompSecDollar";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => amount
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[model.CompSecDollar]()
}
CompSecDollar: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
         toPrice
  amount     X  

abstract trait StockAssetOps extends java.lang.Object with ScalaObject { self: StockSchema.this.StockAsset => 
  def /*StockAssetOps*/$init$(): Unit = {
    ()
  };
  def price: model.Price = Stocks.stockPrice(StockAssetOps.this.ticker);
  def dollars: model.Dollars = StockAssetOps.this.shares.*(StockAssetOps.this.price)
}
StockAssetOps: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=1.000
         dollars   price

case class GroupedStockAsset extends java.lang.Object with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val ticker: String = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def ticker: String = GroupedStockAsset.this.ticker;
  <caseaccessor> <paramaccessor> private[this] val shares: model.Shares = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def shares: model.Shares = GroupedStockAsset.this.shares;
  <caseaccessor> <paramaccessor> private[this] val owner: model.Link[StockSchema.this.Portfolio] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def owner: model.Link[StockSchema.this.Portfolio] = GroupedStockAsset.this.owner;
  <caseaccessor> <paramaccessor> private[this] val purchasePrice: model.Price = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def purchasePrice: model.Price = GroupedStockAsset.this.purchasePrice;
  def this(ticker: String, shares: model.Shares, owner: model.Link[StockSchema.this.Portfolio], purchasePrice: model.Price): StockSchema.this.GroupedStockAsset = {
    GroupedStockAsset.super.this();
    ()
  };
  <synthetic> def copy(ticker: String = ticker, shares: model.Shares = shares, owner: model.Link[StockSchema.this.Portfolio] = owner, purchasePrice: model.Price = purchasePrice): StockSchema.this.GroupedStockAsset = new StockSchema.this.GroupedStockAsset(ticker, shares, owner, purchasePrice);
  <synthetic> def copy$default$4: model.Price @scala.annotation.unchecked.uncheckedVariance = GroupedStockAsset.this.purchasePrice;
  <synthetic> def copy$default$3: model.Link[StockSchema.this.Portfolio] @scala.annotation.unchecked.uncheckedVariance = GroupedStockAsset.this.owner;
  <synthetic> def copy$default$2: model.Shares @scala.annotation.unchecked.uncheckedVariance = GroupedStockAsset.this.shares;
  <synthetic> def copy$default$1: String @scala.annotation.unchecked.uncheckedVariance = GroupedStockAsset.this.ticker;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(GroupedStockAsset.this);
  override def toString(): String = ScalaRunTime.this._toString(GroupedStockAsset.this);
  override def equals(x$1: Any): Boolean = GroupedStockAsset.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (ticker: String, shares: model.Shares, owner: model.Link[StockSchema.this.Portfolio], purchasePrice: model.Price)StockSchema.this.GroupedStockAsset((ticker$2 @ _), (shares$3 @ _), (owner$2 @ _), (purchasePrice$2 @ _)) if ticker$2.==(ticker).&&(shares$3.==(shares)).&&(owner$2.==(owner)).&&(purchasePrice$2.==(purchasePrice)) => x$1.asInstanceOf[StockSchema.this.GroupedStockAsset].canEqual(GroupedStockAsset.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "GroupedStockAsset";
  override def productArity: Int = 4;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => ticker
    case 1 => shares
    case 2 => owner
    case 3 => purchasePrice
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[StockSchema.this.GroupedStockAsset]()
}
GroupedStockAsset: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
  ticker
   owner
 purchas
  shares

final class $anon extends intform.Field[model.Condition] with intform.FieldRender {
  def this(): anonymous class $anon = {
    $anon.super.this();
    ()
  };
  lazy private[this] var useField: intform.BooleanField = _;
  <stable> <accessor> lazy def useField: intform.BooleanField = {
    $anon.this.useField = intform.BooleanField.apply(intform.BooleanField.apply$default$1);
    $anon.this.useField
  };
  lazy private[this] var aField: intform.TextField[model.ComparableSecurity]{def produce(): intform.OK[model.ComparableSecurity]} = _;
  <stable> <accessor> lazy def aField: intform.TextField[model.ComparableSecurity]{def produce(): intform.OK[model.ComparableSecurity]} = {
    $anon.this.aField = $anon.this.compSecField;
    $anon.this.aField
  };
  lazy private[this] var bField: intform.TextField[model.ComparableSecurity]{def produce(): intform.OK[model.ComparableSecurity]} = _;
  <stable> <accessor> lazy def bField: intform.TextField[model.ComparableSecurity]{def produce(): intform.OK[model.ComparableSecurity]} = {
    $anon.this.bField = $anon.this.compSecField;
    $anon.this.bField
  };
  def compSecField: intform.TextField[model.ComparableSecurity]{def produce(): intform.OK[model.ComparableSecurity]} = {
    final class $anon extends intform.TextField[model.ComparableSecurity] {
      def this(): anonymous class $anon = {
        $anon.super.this("");
        ()
      };
      def produce(): intform.OK[model.ComparableSecurity] = new intform.OK[model.ComparableSecurity](try {
        new model.CompSecDollar(model.Price.apply($anon.this.text))
      } catch {
        case (_: NumberFormatException) => new model.CompSecStock($anon.this.text)
      })
    };
    new $anon()
  };
  def produce(): Product with Serializable with intform.SubmitResult[Product with Serializable with model.Condition] = $anon.this.useField.process().flatMap[intform.OK[Product with Serializable with model.Condition]](((use: Boolean) => if (use)
  $anon.this.aField.process().flatMap[intform.OK[model.CondGreater]](((a: model.ComparableSecurity) => $anon.this.bField.process().map[intform.OK[model.CondGreater]](((b: model.ComparableSecurity) => new intform.OK[model.CondGreater](new model.CondGreater(b, a))))))
else
  new Some[intform.OK[model.CondAlways.type]](new intform.OK[model.CondAlways.type](model.CondAlways)))).getOrElse[Product with Serializable with intform.SubmitResult[Product with Serializable with model.Condition]](intform.ChildError);
  def reset(): Unit = {
    $anon.this.useField.reset();
    $anon.this.aField.reset();
    $anon.this.bField.reset()
  };
  def main: scala.xml.Elem = {
    {
      new scala.xml.Elem(null, "p", scala.xml.Null, scala.this.Predef.$scope, ({
        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
        $buf.&+(new scala.xml.Text("\012                "));
        $buf.&+(intform.`package`.mergeAttr($anon.this.useField.main).&({
          {
            var $md: scala.xml.MetaData = scala.xml.Null;
            $md = new scala.xml.UnprefixedAttribute("id", new scala.xml.Text("condition-en"), $md);
            new scala.xml.Elem(null, "input", $md, scala.this.Predef.$scope)
          }
        }));
        $buf.&+(new scala.xml.Text("\012                "));
        $buf.&+({
          {
            var $md: scala.xml.MetaData = scala.xml.Null;
            $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("chain"), $md);
            new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
              val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
              $buf.&+(new scala.xml.Text("\012                    "));
              $buf.&+({
                {
                  var $md: scala.xml.MetaData = scala.xml.Null;
                  $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("description"), $md);
                  $md = new scala.xml.UnprefixedAttribute("for", new scala.xml.Text("condition-en"), $md);
                  new scala.xml.Elem(null, "label", $md, scala.this.Predef.$scope, ({
                    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                    $buf.&+(new scala.xml.Text("Provided that"));
                    $buf
                  }: _*))
                }
              });
              $buf.&+(new scala.xml.Text("\012                "));
              $buf
            }: _*))
          }
        });
        $buf.&+(new scala.xml.Text("\012                "));
        $buf.&+({
          {
            var $md: scala.xml.MetaData = scala.xml.Null;
            $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("chain"), $md);
            new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
              val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
              $buf.&+(new scala.xml.Text("\012                    "));
              $buf.&+({
                {
                  var $md: scala.xml.MetaData = scala.xml.Null;
                  $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("field-annotation"), $md);
                  $md = new scala.xml.UnprefixedAttribute("for", new scala.xml.Text("condition1"), $md);
                  new scala.xml.Elem(null, "label", $md, scala.this.Predef.$scope, ({
                    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                    $buf.&+(new scala.xml.Text("ticker or $"));
                    $buf
                  }: _*))
                }
              });
              $buf.&+(new scala.xml.Text("\012                    "));
              $buf.&+(intform.`package`.mergeAttr($anon.this.aField.main).&({
                {
                  var $md: scala.xml.MetaData = scala.xml.Null;
                  $md = new scala.xml.UnprefixedAttribute("id", new scala.xml.Text("condition1"), $md);
                  $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("blank condition"), $md);
                  new scala.xml.Elem(null, "input", $md, scala.this.Predef.$scope)
                }
              }));
              $buf.&+(new scala.xml.Text("\012                "));
              $buf
            }: _*))
          }
        });
        $buf.&+(new scala.xml.Text("\012                "));
        $buf.&+({
          {
            var $md: scala.xml.MetaData = scala.xml.Null;
            $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("chain"), $md);
            new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
              val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
              $buf.&+(new scala.xml.EntityRef("lt"));
              $buf
            }: _*))
          }
        });
        $buf.&+(new scala.xml.Text("\012                "));
        $buf.&+({
          {
            var $md: scala.xml.MetaData = scala.xml.Null;
            $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("chain"), $md);
            new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
              val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
              $buf.&+(new scala.xml.Text("\012                    "));
              $buf.&+({
                {
                  var $md: scala.xml.MetaData = scala.xml.Null;
                  $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("field-annotation"), $md);
                  $md = new scala.xml.UnprefixedAttribute("for", new scala.xml.Text("condition2"), $md);
                  new scala.xml.Elem(null, "label", $md, scala.this.Predef.$scope, ({
                    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                    $buf.&+(new scala.xml.Text("ticker or $"));
                    $buf
                  }: _*))
                }
              });
              $buf.&+(new scala.xml.Text("\012                    "));
              $buf.&+(intform.`package`.mergeAttr($anon.this.bField.main).&({
                {
                  var $md: scala.xml.MetaData = scala.xml.Null;
                  $md = new scala.xml.UnprefixedAttribute("id", new scala.xml.Text("condition2"), $md);
                  $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("blank condition"), $md);
                  new scala.xml.Elem(null, "input", $md, scala.this.Predef.$scope)
                }
              }));
              $buf.&+(new scala.xml.Text("\012                "));
              $buf
            }: _*))
          }
        });
        $buf.&+(new scala.xml.Text("\012            "));
        $buf
      }: _*))
    }
  }
}
$anon: SCOM=0.500 CC=0.500 LSCC=0.500 CAMC=1.000
           reset produce    main compSec
  aField     X       X       X          
  bField     X       X       X          
 useFiel     X       X       X          

final case object ToSeller extends Direction with ScalaObject with Product with Serializable {
  def this(): object code.snippet.ToSeller = {
    ToSeller.super.this();
    ()
  };
  def sign(x: model.Dollars): model.Dollars = x.unary_-;
  def sign(x: model.Shares): model.Shares = x.*(model.Scale.apply("-1"));
  def sign(x: Int): Int = x.unary_-;
  final override def hashCode(): Int = -1726306822;
  final override def toString(): java.lang.String = "ToSeller";
  override def productPrefix: java.lang.String = "ToSeller";
  override def productArity: Int = 0;
  override def productElement(x$1: Int): Any = x$1 match {
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[object code.snippet.ToSeller]();
  protected def readResolve(): java.lang.Object = snippet.this.ToSeller
}
ToSeller: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.250
            sign readRes    sign    sign

abstract class TextField[A >: Nothing <: Any] extends intform.Field[A] with intform.TextRender with intform.ErrorRender with ScalaObject {
  <paramaccessor> private[this] val initText: String = _;
  def this(initText: String): intform.TextField[A] = {
    TextField.super.this();
    ()
  };
  private[this] var text: String = TextField.this.initText;
  <accessor> def text: String = TextField.this.text;
  <accessor> def text_=(x$1: String): Unit = TextField.this.text = x$1;
  def reset(): Unit = TextField.this.text_=(TextField.this.initText)
}
TextField: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
           reset
 initTex     X  
    text     X  

class AutoTrades extends java.lang.Object with intform.Page with net.liftweb.common.Loggable with ScalaObject {
  def this(): code.snippet.AutoTrades = {
    AutoTrades.super.this();
    ()
  };
  def render: scala.xml.NodeSeq = jsapi.`package`.jsFuncDefs.++[scala.xml.Node, scala.xml.NodeSeq](AutoTrades.this.refreshable.render)(xml.this.NodeSeq.canBuildFrom);
  private[this] val refreshable: intform.Refreshable.NeedRenderable with intform.Refreshable = intform.Refreshable.apply(AutoTrades.this.doRender);
  <stable> <accessor> def refreshable: intform.Refreshable.NeedRenderable with intform.Refreshable = AutoTrades.this.refreshable;
  def doRender: scala.xml.NodeSeq = {
    try {
      AutoTrades.this.main(control.PortfolioSwitcher.currentPortfolio)
    } catch {
      case control.LoginManager.NotLoggedIn => {
        {
          new scala.xml.Elem(null, "p", scala.xml.Null, scala.this.Predef.$scope, ({
            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
            $buf.&+(new scala.xml.Text("Login to use auto trades"));
            $buf
          }: _*))
        }
      }
    }
  };
  def main(port: model.schema.Portfolio): scala.xml.Elem = {
    lazy var content$lzy: scala.xml.Elem = _;
    <stable> <accessor> lazy def content: scala.xml.Elem = {
      content$lzy = {
        {
          var $md: scala.xml.MetaData = scala.xml.Null;
          $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("block"), $md);
          new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
            $buf.&+(new scala.xml.Text("\012                "));
            $buf.&+({
              {
                new scala.xml.Elem(null, "p", scala.xml.Null, scala.this.Predef.$scope, ({
                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                  $buf.&+(newAutoTrade);
                  $buf
                }: _*))
              }
            });
            $buf.&+(new scala.xml.Text("\012                "));
            $buf.&+(autoTradeList);
            $buf.&+(new scala.xml.Text("\012            "));
            $buf
          }: _*))
        }
      };
      content$lzy
    };
    lazy var newAutoTrade$lzy: scala.xml.NodeSeq = _;
    <stable> <accessor> lazy def newAutoTrade: scala.xml.NodeSeq = {
      newAutoTrade$lzy = intform.FormSubmit.rendered("Make new AutoTrade")({
        port.userMakeNewAutoTrade();
        AutoTrades.this.refreshable.refresh()
      });
      newAutoTrade$lzy
    };
    lazy var autoTradeList$lzy: List[scala.xml.Elem] = _;
    <stable> <accessor> lazy def autoTradeList: List[scala.xml.Elem] = {
      autoTradeList$lzy = port.myAutoTrades.map[scala.xml.Elem, List[scala.xml.Elem]]({
        ((trade: model.schema.AutoTrade) => AutoTrades.this.renderAutoTrade(trade))
      })(immutable.this.List.canBuildFrom[scala.xml.Elem]);
      autoTradeList$lzy
    };
    content
  };
  def renderAutoTrade(trade: model.schema.AutoTrade): scala.xml.Elem = {
    val key: java.lang.String = java.util.UUID.randomUUID().toString();
    val title: String = trade.title;
    val code: String = trade.code;
    lazy var form$lzy: intform.Form[AutoTrades.this.AutoTradeSubmit] = _;
    <stable> <accessor> lazy def form: intform.Form[AutoTrades.this.AutoTradeSubmit] = {
      form$lzy = intform.Form.apply[AutoTrades.this.AutoTradeSubmit, up.HList.:+:[String,up.HList.:+:[String,up.HNil]]](intform.`package`.hlistify2[String, String, AutoTrades.this.AutoTradeSubmit](AutoTrades.this.AutoTradeSubmit), intform.`package`.klist2[intform.Field, String, String](new (intform.StringField, intform.TextAreaField)(titleField, bodyField)), {
        {
          var $md: scala.xml.MetaData = scala.xml.Null;
          $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("auto-trade-form"), $md);
          new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
            $buf.&+(new scala.xml.Text("\012                "));
            $buf.&+({
              {
                var $md: scala.xml.MetaData = scala.xml.Null;
                $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("auto-trade-title"), $md);
                new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                  $buf.&+(titleField.main);
                  $buf.&+(new scala.xml.Text(" "));
                  $buf.&+(titleField.errors);
                  $buf
                }: _*))
              }
            });
            $buf.&+(new scala.xml.Text("\012                "));
            $buf.&+({
              {
                var $md: scala.xml.MetaData = scala.xml.Null;
                $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("auto-trade-body"), $md);
                new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                  $buf.&+(intform.`package`.mergeAttr(bodyField.main).&({
                    {
                      var $md: scala.xml.MetaData = scala.xml.Null;
                      $md = new scala.xml.UnprefixedAttribute("id", "code-".+(key), $md);
                      new scala.xml.Elem(null, "textarea", $md, scala.this.Predef.$scope)
                    }
                  }));
                  $buf
                }: _*))
              }
            });
            $buf.&+(new scala.xml.Text("\012                "));
            $buf.&+({
              {
                var $md: scala.xml.MetaData = scala.xml.Null;
                $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("auto-trade-controls"), $md);
                new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                  $buf.&+(new scala.xml.Text("\012                    "));
                  $buf.&+(saveButton.main);
                  $buf.&+(new scala.xml.Text(" "));
                  $buf.&+(saveButton.errors);
                  $buf.&+(new scala.xml.Text("\012                    "));
                  $buf.&+(executeButton.main);
                  $buf.&+(new scala.xml.Text(" "));
                  $buf.&+(executeButton.errors);
                  $buf.&+(new scala.xml.Text("\012                "));
                  $buf
                }: _*))
              }
            });
            $buf.&+(new scala.xml.Text("\012            "));
            $buf
          }: _*))
        }
      });
      form$lzy
    };
    lazy var titleField$lzy: intform.StringField = _;
    <stable> <accessor> lazy def titleField: intform.StringField = {
      titleField$lzy = intform.StringField.apply(title);
      titleField$lzy
    };
    lazy var bodyField$lzy: intform.TextAreaField = _;
    <stable> <accessor> lazy def bodyField: intform.TextAreaField = {
      bodyField$lzy = intform.TextAreaField.apply(code);
      bodyField$lzy
    };
    lazy var saveButton$lzy: intform.Submit[AutoTrades.this.AutoTradeSubmit] = _;
    <stable> <accessor> lazy def saveButton: intform.Submit[AutoTrades.this.AutoTradeSubmit] = {
      saveButton$lzy = intform.Submit.apply[AutoTrades.this.AutoTradeSubmit](form, "Save", false)(((result: AutoTrades.this.AutoTradeSubmit) => js.this.JsCmd.unitToJsCmd(trade.userModify(result.title, result.code))));
      saveButton$lzy
    };
    lazy var executeButton$lzy: intform.Submit[AutoTrades.this.AutoTradeSubmit] = _;
    <stable> <accessor> lazy def executeButton: intform.Submit[AutoTrades.this.AutoTradeSubmit] = {
      executeButton$lzy = intform.Submit.apply[AutoTrades.this.AutoTradeSubmit](form, "Run", false)(((result: AutoTrades.this.AutoTradeSubmit) => {
        trade.userModify(result.title, result.code);
        AutoTrades.this.logger.info("Executing ".+(result.code));
        js.this.JsCmds.jsExpToJsCmd(new net.liftweb.http.js.JE.Call("runAutoTrade", new net.liftweb.http.js.JE.Str(key)))
      }));
      executeButton$lzy
    };
    lazy var outputPane$lzy: scala.xml.Elem = _;
    <stable> <accessor> lazy def outputPane: scala.xml.Elem = {
      outputPane$lzy = {
        {
          var $md: scala.xml.MetaData = scala.xml.Null;
          $md = new scala.xml.UnprefixedAttribute("id", "pane-".+(key), $md);
          $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("auto-trade-output"), $md);
          new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
            $buf.&+(new scala.xml.Text("\012                "));
            $buf.&+({
              {
                var $md: scala.xml.MetaData = scala.xml.Null;
                $md = new scala.xml.UnprefixedAttribute("id", "output-".+(key), $md);
                $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("auto-trade-output"), $md);
                new scala.xml.Elem(null, "pre", $md, scala.this.Predef.$scope, ({
                  val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                  $buf.&+(new scala.xml.Text("Stuff goes here"));
                  $buf
                }: _*))
              }
            });
            $buf.&+(new scala.xml.Text("\012            "));
            $buf
          }: _*))
        }
      };
      outputPane$lzy
    };
    {
      {
        var $md: scala.xml.MetaData = scala.xml.Null;
        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("auto-trade"), $md);
        new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
          $buf.&+(new scala.xml.Text("\012            "));
          $buf.&+({
            {
              var $md: scala.xml.MetaData = scala.xml.Null;
              $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("auto-trade-table"), $md);
              new scala.xml.Elem(null, "table", $md, scala.this.Predef.$scope, ({
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+(new scala.xml.Text("\012                "));
                $buf.&+({
                  {
                    var $md: scala.xml.MetaData = scala.xml.Null;
                    $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("auto-trade-left-col"), $md);
                    new scala.xml.Elem(null, "col", $md, scala.this.Predef.$scope)
                  }
                });
                $buf.&+(new scala.xml.Text("\012                "));
                $buf.&+({
                  {
                    var $md: scala.xml.MetaData = scala.xml.Null;
                    $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("auto-trade-right-col"), $md);
                    new scala.xml.Elem(null, "col", $md, scala.this.Predef.$scope)
                  }
                });
                $buf.&+(new scala.xml.Text("\012                "));
                $buf.&+({
                  {
                    new scala.xml.Elem(null, "tr", scala.xml.Null, scala.this.Predef.$scope, ({
                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                      $buf.&+(new scala.xml.Text("\012                    "));
                      $buf.&+({
                        {
                          new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                            $buf.&+(new scala.xml.Text("Code:"));
                            $buf
                          }: _*))
                        }
                      });
                      $buf.&+(new scala.xml.Text("\012                    "));
                      $buf.&+({
                        {
                          new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                            $buf.&+(new scala.xml.Text("Output:"));
                            $buf
                          }: _*))
                        }
                      });
                      $buf.&+(new scala.xml.Text("\012                "));
                      $buf
                    }: _*))
                  }
                });
                $buf.&+(new scala.xml.Text("\012                "));
                $buf.&+({
                  {
                    new scala.xml.Elem(null, "tr", scala.xml.Null, scala.this.Predef.$scope, ({
                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                      $buf.&+(new scala.xml.Text("\012                    "));
                      $buf.&+({
                        {
                          var $md: scala.xml.MetaData = scala.xml.Null;
                          $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("auto-trade-left"), $md);
                          new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope, ({
                            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                            $buf.&+(form.render);
                            $buf
                          }: _*))
                        }
                      });
                      $buf.&+(new scala.xml.Text("\012                    "));
                      $buf.&+({
                        {
                          var $md: scala.xml.MetaData = scala.xml.Null;
                          $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("auto-trade-right"), $md);
                          new scala.xml.Elem(null, "td", $md, scala.this.Predef.$scope, ({
                            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                            $buf.&+(outputPane);
                            $buf
                          }: _*))
                        }
                      });
                      $buf.&+(new scala.xml.Text("\012                "));
                      $buf
                    }: _*))
                  }
                });
                $buf.&+(new scala.xml.Text("\012            "));
                $buf
              }: _*))
            }
          });
          $buf.&+(new scala.xml.Text("\012        "));
          $buf
        }: _*))
      }
    }
  };
  case class AutoTradeSubmit extends java.lang.Object with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val title: String = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def title: String = AutoTradeSubmit.this.title;
    <caseaccessor> <paramaccessor> private[this] val code: String = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def code: String = AutoTradeSubmit.this.code;
    def this(title: String, code: String): AutoTrades.this.AutoTradeSubmit = {
      AutoTradeSubmit.super.this();
      ()
    };
    <synthetic> def copy(title: String = title, code: String = code): AutoTrades.this.AutoTradeSubmit = new AutoTrades.this.AutoTradeSubmit(title, code);
    <synthetic> def copy$default$2: String @scala.annotation.unchecked.uncheckedVariance = AutoTradeSubmit.this.code;
    <synthetic> def copy$default$1: String @scala.annotation.unchecked.uncheckedVariance = AutoTradeSubmit.this.title;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(AutoTradeSubmit.this);
    override def toString(): String = ScalaRunTime.this._toString(AutoTradeSubmit.this);
    override def equals(x$1: Any): Boolean = AutoTradeSubmit.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (title: String, code: String)AutoTrades.this.AutoTradeSubmit((title$1 @ _), (code$1 @ _)) if title$1.==(title).&&(code$1.==(code)) => x$1.asInstanceOf[AutoTrades.this.AutoTradeSubmit].canEqual(AutoTradeSubmit.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "AutoTradeSubmit";
    override def productArity: Int = 2;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => title
      case 1 => code
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[AutoTrades.this.AutoTradeSubmit]()
  };
  final <synthetic> object AutoTradeSubmit extends scala.runtime.AbstractFunction2[String,String,AutoTrades.this.AutoTradeSubmit] with ScalaObject with Serializable {
    def this(): object AutoTrades.this.AutoTradeSubmit = {
      AutoTradeSubmit.super.this();
      ()
    };
    final override def toString(): java.lang.String = "AutoTradeSubmit";
    case <synthetic> def unapply(x$0: AutoTrades.this.AutoTradeSubmit): Option[(String, String)] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(String, String)](new (String, String)(x$0.title, x$0.code));
    case <synthetic> def apply(title: String, code: String): AutoTrades.this.AutoTradeSubmit = new AutoTrades.this.AutoTradeSubmit(title, code)
  };
  @volatile <synthetic> private[this] var AutoTradeSubmit$module: object AutoTrades.this.AutoTradeSubmit = _;
  final <synthetic> <stable> def AutoTradeSubmit: object AutoTrades.this.AutoTradeSubmit = {
    AutoTrades.this.AutoTradeSubmit$module = new object AutoTrades.this.AutoTradeSubmit();
    AutoTrades.this.AutoTradeSubmit$module
  }
}
AutoTrades: SCOM=0.500 CC=0.500 LSCC=0.500 CAMC=0.250
            main  render renderA doRende
 AutoTra     X               X       X  

final case object OK extends Status with ScalaObject with Product with Serializable {
  def this(): object texttrading.OK = {
    OK.super.this();
    ()
  };
  final override def hashCode(): Int = 2524;
  final override def toString(): java.lang.String = "OK";
  override def productPrefix: java.lang.String = "OK";
  override def productArity: Int = 0;
  override def productElement(x$1: Int): Any = x$1 match {
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[object texttrading.OK]();
  protected def readResolve(): java.lang.Object = texttrading.this.OK
}
OK: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
         readRes

class ColonEq[A >: Nothing <: Any] extends java.lang.Object with ScalaObject {
  <paramaccessor> private[this] val c: net.liftweb.http.SessionVar[A] = _;
  def this(c: net.liftweb.http.SessionVar[A]): sessions.package.ColonEq[A] = {
    ColonEq.super.this();
    ()
  };
  def :=(a: A): A = ColonEq.this.c.apply(a)
}
ColonEq: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
         $colon$
       c     X  

final object package extends java.lang.Object with ScalaObject {
  def this(): object formats.package = {
    package.super.this();
    ()
  };
  def standardMessage(error: Any): java.lang.String = error match {
    case model.schema.NegativeVolume => "You must buy more than $0.00"
    case (have: model.Dollars, need: model.Dollars)model.schema.NotEnoughCash((have @ _), (need @ _)) => scala.this.Predef.augmentString("You need %s you have %s").format(have.$, need.$)
    case (ticker: String)model.schema.DontOwnStock((ticker @ _)) => scala.this.Predef.augmentString("You don\'t own %s").format(ticker)
    case (have: model.Shares, need: model.Shares)model.schema.NotEnoughShares((have @ _), (need @ _)) => scala.this.Predef.augmentString("You have %s shares you need %s").format(have.###(), need.###())
    case model.schema.NoSuchOffer => "This offer doesn\'t exist"
    case model.schema.NotExecutable => "You can\'t exercise this derivative early"
    case (e @ _) => {
      {
        final class $anon extends java.lang.Object with net.liftweb.common.Logger {
          def this(): anonymous class $anon = {
            $anon.super.this();
            ()
          };
          $anon.this.error("An internal error occurred: ".+(e))
        };
        new $anon()
      };
      "An internal error occurred. Check the logs."
    }
  };
  case class DateTimeFormatted extends java.lang.Object with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val d: org.joda.time.DateTime = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def d: org.joda.time.DateTime = DateTimeFormatted.this.d;
    def this(d: org.joda.time.DateTime): formats.package.DateTimeFormatted = {
      DateTimeFormatted.super.this();
      ()
    };
    def toNearbyString: String = DateTimeFormatted.this.d.toString("M/d");
    <synthetic> def copy(d: org.joda.time.DateTime = d): formats.package.DateTimeFormatted = new package.this.DateTimeFormatted(d);
    <synthetic> def copy$default$1: org.joda.time.DateTime @scala.annotation.unchecked.uncheckedVariance = DateTimeFormatted.this.d;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(DateTimeFormatted.this);
    override def toString(): String = ScalaRunTime.this._toString(DateTimeFormatted.this);
    override def equals(x$1: Any): Boolean = DateTimeFormatted.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (d: org.joda.time.DateTime)formats.package.DateTimeFormatted((d$1 @ _)) if d$1.==(d) => x$1.asInstanceOf[formats.package.DateTimeFormatted].canEqual(DateTimeFormatted.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "DateTimeFormatted";
    override def productArity: Int = 1;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => d
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[formats.package.DateTimeFormatted]()
  };
  final <synthetic> object DateTimeFormatted extends scala.runtime.AbstractFunction1[org.joda.time.DateTime,formats.package.DateTimeFormatted] with ScalaObject with Serializable {
    def this(): object formats.package.DateTimeFormatted = {
      DateTimeFormatted.super.this();
      ()
    };
    final override def toString(): java.lang.String = "DateTimeFormatted";
    case <synthetic> def unapply(x$0: formats.package.DateTimeFormatted): Option[org.joda.time.DateTime] = if (x$0.==(null))
      scala.this.None
    else
      new Some[org.joda.time.DateTime](x$0.d);
    case <synthetic> def apply(d: org.joda.time.DateTime): formats.package.DateTimeFormatted = new package.this.DateTimeFormatted(d);
    protected def readResolve(): java.lang.Object = package.this.DateTimeFormatted
  };
  implicit def dateTimeFormatted(d: org.joda.time.DateTime): formats.package.DateTimeFormatted = new formats.package.DateTimeFormatted(d);
  implicit def timestampFormatted(t: java.sql.Timestamp): formats.package.DateTimeFormatted = new formats.package.DateTimeFormatted(new org.joda.time.DateTime(t.getTime()));
  case class BigDecimalFormatted extends java.lang.Object with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val b: scala.math.BigDecimal = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def b: scala.math.BigDecimal = BigDecimalFormatted.this.b;
    def this(b: scala.math.BigDecimal): formats.package.BigDecimalFormatted = {
      BigDecimalFormatted.super.this();
      ()
    };
    def $: String = scala.this.Predef.augmentString("$%.2f").format(BigDecimalFormatted.this.b.doubleValue());
    def %(): String = scala.this.Predef.augmentString("%.0f%%").format(BigDecimalFormatted.this.b.doubleValue().*(100));
    def ###(): String = scala.this.Predef.augmentString("%.0f").format(BigDecimalFormatted.this.b.doubleValue());
    <synthetic> def copy(b: scala.math.BigDecimal = b): formats.package.BigDecimalFormatted = new package.this.BigDecimalFormatted(b);
    <synthetic> def copy$default$1: scala.math.BigDecimal @scala.annotation.unchecked.uncheckedVariance = BigDecimalFormatted.this.b;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(BigDecimalFormatted.this);
    override def toString(): String = ScalaRunTime.this._toString(BigDecimalFormatted.this);
    override def equals(x$1: Any): Boolean = BigDecimalFormatted.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (b: scala.math.BigDecimal)formats.package.BigDecimalFormatted((b$1 @ _)) if b$1.==(b) => x$1.asInstanceOf[formats.package.BigDecimalFormatted].canEqual(BigDecimalFormatted.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "BigDecimalFormatted";
    override def productArity: Int = 1;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => b
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[formats.package.BigDecimalFormatted]()
  };
  final <synthetic> object BigDecimalFormatted extends scala.runtime.AbstractFunction1[scala.math.BigDecimal,formats.package.BigDecimalFormatted] with ScalaObject with Serializable {
    def this(): object formats.package.BigDecimalFormatted = {
      BigDecimalFormatted.super.this();
      ()
    };
    final override def toString(): java.lang.String = "BigDecimalFormatted";
    case <synthetic> def unapply(x$0: formats.package.BigDecimalFormatted): Option[scala.math.BigDecimal] = if (x$0.==(null))
      scala.this.None
    else
      new Some[scala.math.BigDecimal](x$0.b);
    case <synthetic> def apply(b: scala.math.BigDecimal): formats.package.BigDecimalFormatted = new package.this.BigDecimalFormatted(b);
    protected def readResolve(): java.lang.Object = package.this.BigDecimalFormatted
  };
  implicit def bigDecimalFormatted(b: scala.math.BigDecimal): formats.package.BigDecimalFormatted = new formats.package.BigDecimalFormatted(b);
  case class BigDecimalOptionFormatted extends java.lang.Object with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val b: Option[scala.math.BigDecimal] = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def b: Option[scala.math.BigDecimal] = BigDecimalOptionFormatted.this.b;
    def this(b: Option[scala.math.BigDecimal]): formats.package.BigDecimalOptionFormatted = {
      BigDecimalOptionFormatted.super.this();
      ()
    };
    def $: String = BigDecimalOptionFormatted.this.b.map[String](((x$1: scala.math.BigDecimal) => package.this.bigDecimalFormatted(x$1).$)).getOrElse[String]("n/a");
    def %(): String = BigDecimalOptionFormatted.this.b.map[java.lang.String](((x$2: scala.math.BigDecimal) => x$2.toString().+("%"))).getOrElse[java.lang.String]("n/a");
    <synthetic> def copy(b: Option[scala.math.BigDecimal] = b): formats.package.BigDecimalOptionFormatted = new package.this.BigDecimalOptionFormatted(b);
    <synthetic> def copy$default$1: Option[scala.math.BigDecimal] @scala.annotation.unchecked.uncheckedVariance = BigDecimalOptionFormatted.this.b;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(BigDecimalOptionFormatted.this);
    override def toString(): String = ScalaRunTime.this._toString(BigDecimalOptionFormatted.this);
    override def equals(x$1: Any): Boolean = BigDecimalOptionFormatted.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (b: Option[scala.math.BigDecimal])formats.package.BigDecimalOptionFormatted((b$2 @ _)) if b$2.==(b) => x$1.asInstanceOf[formats.package.BigDecimalOptionFormatted].canEqual(BigDecimalOptionFormatted.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "BigDecimalOptionFormatted";
    override def productArity: Int = 1;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => b
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[formats.package.BigDecimalOptionFormatted]()
  };
  final <synthetic> object BigDecimalOptionFormatted extends scala.runtime.AbstractFunction1[Option[scala.math.BigDecimal],formats.package.BigDecimalOptionFormatted] with ScalaObject with Serializable {
    def this(): object formats.package.BigDecimalOptionFormatted = {
      BigDecimalOptionFormatted.super.this();
      ()
    };
    final override def toString(): java.lang.String = "BigDecimalOptionFormatted";
    case <synthetic> def unapply(x$0: formats.package.BigDecimalOptionFormatted): Option[Option[scala.math.BigDecimal]] = if (x$0.==(null))
      scala.this.None
    else
      new Some[Option[scala.math.BigDecimal]](x$0.b);
    case <synthetic> def apply(b: Option[scala.math.BigDecimal]): formats.package.BigDecimalOptionFormatted = new package.this.BigDecimalOptionFormatted(b);
    protected def readResolve(): java.lang.Object = package.this.BigDecimalOptionFormatted
  };
  implicit def bigDecimalOptionFormatted(b: Option[scala.math.BigDecimal]): formats.package.BigDecimalOptionFormatted = new formats.package.BigDecimalOptionFormatted(b);
  case class FormattedSecurities extends java.lang.Object with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val securities: Seq[model.Security] = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def securities: Seq[model.Security] = FormattedSecurities.this.securities;
    def this(securities: Seq[model.Security]): formats.package.FormattedSecurities = {
      FormattedSecurities.super.this();
      ()
    };
    def toHumanString: String = FormattedSecurities.this.securities.map[String, Seq[String]](((x$3: model.Security) => package.this.securityFormatted(x$3).toHumanString))(collection.this.Seq.canBuildFrom[String]).mkString(" + ");
    <synthetic> def copy(securities: Seq[model.Security] = securities): formats.package.FormattedSecurities = new package.this.FormattedSecurities(securities);
    <synthetic> def copy$default$1: Seq[model.Security] @scala.annotation.unchecked.uncheckedVariance = FormattedSecurities.this.securities;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(FormattedSecurities.this);
    override def toString(): String = ScalaRunTime.this._toString(FormattedSecurities.this);
    override def equals(x$1: Any): Boolean = FormattedSecurities.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (securities: Seq[model.Security])formats.package.FormattedSecurities((securities$1 @ _)) if securities$1.==(securities) => x$1.asInstanceOf[formats.package.FormattedSecurities].canEqual(FormattedSecurities.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "FormattedSecurities";
    override def productArity: Int = 1;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => securities
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[formats.package.FormattedSecurities]()
  };
  final <synthetic> object FormattedSecurities extends scala.runtime.AbstractFunction1[Seq[model.Security],formats.package.FormattedSecurities] with ScalaObject with Serializable {
    def this(): object formats.package.FormattedSecurities = {
      FormattedSecurities.super.this();
      ()
    };
    final override def toString(): java.lang.String = "FormattedSecurities";
    case <synthetic> def unapply(x$0: formats.package.FormattedSecurities): Option[Seq[model.Security]] = if (x$0.==(null))
      scala.this.None
    else
      new Some[Seq[model.Security]](x$0.securities);
    case <synthetic> def apply(securities: Seq[model.Security]): formats.package.FormattedSecurities = new package.this.FormattedSecurities(securities);
    protected def readResolve(): java.lang.Object = package.this.FormattedSecurities
  };
  implicit def securitiesFormatted(ss: Seq[model.Security]): formats.package.FormattedSecurities = new formats.package.FormattedSecurities(ss);
  case class FormattedSecurity extends java.lang.Object with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val security: model.Security = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def security: model.Security = FormattedSecurity.this.security;
    def this(security: model.Security): formats.package.FormattedSecurity = {
      FormattedSecurity.super.this();
      ()
    };
    def toHumanString: String = FormattedSecurity.this.security match {
      case (amount: model.Dollars)model.SecDollar((amount @ _)) => amount.$
      case (ticker: String, shares: model.Shares)model.SecStock((ticker @ _), (shares @ _)) => scala.this.Predef.augmentString("%s shrs %s").format(shares.###(), ticker)
      case (name: String, scale: model.Scale)model.SecDerivative((name @ _), (scale @ _)) => scala.this.Predef.augmentString("[%s %s]").format(scale.%(), name)
    };
    <synthetic> def copy(security: model.Security = security): formats.package.FormattedSecurity = new package.this.FormattedSecurity(security);
    <synthetic> def copy$default$1: model.Security @scala.annotation.unchecked.uncheckedVariance = FormattedSecurity.this.security;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(FormattedSecurity.this);
    override def toString(): String = ScalaRunTime.this._toString(FormattedSecurity.this);
    override def equals(x$1: Any): Boolean = FormattedSecurity.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (security: model.Security)formats.package.FormattedSecurity((security$1 @ _)) if security$1.==(security) => x$1.asInstanceOf[formats.package.FormattedSecurity].canEqual(FormattedSecurity.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "FormattedSecurity";
    override def productArity: Int = 1;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => security
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[formats.package.FormattedSecurity]()
  };
  final <synthetic> object FormattedSecurity extends scala.runtime.AbstractFunction1[model.Security,formats.package.FormattedSecurity] with ScalaObject with Serializable {
    def this(): object formats.package.FormattedSecurity = {
      FormattedSecurity.super.this();
      ()
    };
    final override def toString(): java.lang.String = "FormattedSecurity";
    case <synthetic> def unapply(x$0: formats.package.FormattedSecurity): Option[model.Security] = if (x$0.==(null))
      scala.this.None
    else
      new Some[model.Security](x$0.security);
    case <synthetic> def apply(security: model.Security): formats.package.FormattedSecurity = new package.this.FormattedSecurity(security);
    protected def readResolve(): java.lang.Object = package.this.FormattedSecurity
  };
  implicit def securityFormatted(s: model.Security): formats.package.FormattedSecurity = new formats.package.FormattedSecurity(s);
  case class FormattedCondition extends java.lang.Object with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val condition: model.Condition = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def condition: model.Condition = FormattedCondition.this.condition;
    def this(condition: model.Condition): formats.package.FormattedCondition = {
      FormattedCondition.super.this();
      ()
    };
    def toHumanString: java.lang.String = FormattedCondition.this.condition match {
      case model.CondAlways => "-"
      case (a: model.ComparableSecurity, b: model.ComparableSecurity)model.CondGreater((a @ _), (b @ _)) => scala.this.Predef.augmentString("%s > %s").format(package.this.compSecFormatted(a).toHumanString, package.this.compSecFormatted(b).toHumanString)
    };
    <synthetic> def copy(condition: model.Condition = condition): formats.package.FormattedCondition = new package.this.FormattedCondition(condition);
    <synthetic> def copy$default$1: model.Condition @scala.annotation.unchecked.uncheckedVariance = FormattedCondition.this.condition;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(FormattedCondition.this);
    override def toString(): String = ScalaRunTime.this._toString(FormattedCondition.this);
    override def equals(x$1: Any): Boolean = FormattedCondition.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (condition: model.Condition)formats.package.FormattedCondition((condition$1 @ _)) if condition$1.==(condition) => x$1.asInstanceOf[formats.package.FormattedCondition].canEqual(FormattedCondition.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "FormattedCondition";
    override def productArity: Int = 1;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => condition
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[formats.package.FormattedCondition]()
  };
  final <synthetic> object FormattedCondition extends scala.runtime.AbstractFunction1[model.Condition,formats.package.FormattedCondition] with ScalaObject with Serializable {
    def this(): object formats.package.FormattedCondition = {
      FormattedCondition.super.this();
      ()
    };
    final override def toString(): java.lang.String = "FormattedCondition";
    case <synthetic> def unapply(x$0: formats.package.FormattedCondition): Option[model.Condition] = if (x$0.==(null))
      scala.this.None
    else
      new Some[model.Condition](x$0.condition);
    case <synthetic> def apply(condition: model.Condition): formats.package.FormattedCondition = new package.this.FormattedCondition(condition);
    protected def readResolve(): java.lang.Object = package.this.FormattedCondition
  };
  implicit def conditionFormatted(c: model.Condition): formats.package.FormattedCondition = new formats.package.FormattedCondition(c);
  case class CompSecFormatted extends java.lang.Object with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val c: model.ComparableSecurity = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def c: model.ComparableSecurity = CompSecFormatted.this.c;
    <synthetic> def copy$default$1: model.ComparableSecurity @scala.annotation.unchecked.uncheckedVariance = CompSecFormatted.this.c;
    def this(c: model.ComparableSecurity): formats.package.CompSecFormatted = {
      CompSecFormatted.super.this();
      ()
    };
    def toHumanString: String = CompSecFormatted.this.c match {
      case (ticker: String)model.CompSecStock((ticker @ _)) => ticker
      case (amount: model.Price)model.CompSecDollar((amount @ _)) => amount.$
    };
    <synthetic> def copy(c: model.ComparableSecurity = c): formats.package.CompSecFormatted = new package.this.CompSecFormatted(c);
    override def hashCode(): Int = ScalaRunTime.this._hashCode(CompSecFormatted.this);
    override def toString(): String = ScalaRunTime.this._toString(CompSecFormatted.this);
    override def equals(x$1: Any): Boolean = CompSecFormatted.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (c: model.ComparableSecurity)formats.package.CompSecFormatted((c$1 @ _)) if c$1.==(c) => x$1.asInstanceOf[formats.package.CompSecFormatted].canEqual(CompSecFormatted.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "CompSecFormatted";
    override def productArity: Int = 1;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => c
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[formats.package.CompSecFormatted]()
  };
  final <synthetic> object CompSecFormatted extends scala.runtime.AbstractFunction1[model.ComparableSecurity,formats.package.CompSecFormatted] with ScalaObject with Serializable {
    def this(): object formats.package.CompSecFormatted = {
      CompSecFormatted.super.this();
      ()
    };
    final override def toString(): java.lang.String = "CompSecFormatted";
    case <synthetic> def unapply(x$0: formats.package.CompSecFormatted): Option[model.ComparableSecurity] = if (x$0.==(null))
      scala.this.None
    else
      new Some[model.ComparableSecurity](x$0.c);
    case <synthetic> def apply(c: model.ComparableSecurity): formats.package.CompSecFormatted = new package.this.CompSecFormatted(c);
    protected def readResolve(): java.lang.Object = package.this.CompSecFormatted
  };
  implicit def compSecFormatted(c: model.ComparableSecurity): formats.package.CompSecFormatted = new formats.package.CompSecFormatted(c);
  case class FormattedDerivative extends java.lang.Object with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val deriv: model.Derivative = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def deriv: model.Derivative = FormattedDerivative.this.deriv;
    def this(deriv: model.Derivative): formats.package.FormattedDerivative = {
      FormattedDerivative.super.this();
      ()
    };
    def toHumanString: String = scala.this.Predef.augmentString("%s on %s if %s").format(package.this.securitiesFormatted(FormattedDerivative.this.deriv.securities).toHumanString, package.this.dateTimeFormatted(FormattedDerivative.this.deriv.exec).toNearbyString, package.this.conditionFormatted(FormattedDerivative.this.deriv.condition).toHumanString);
    <synthetic> def copy(deriv: model.Derivative = deriv): formats.package.FormattedDerivative = new package.this.FormattedDerivative(deriv);
    <synthetic> def copy$default$1: model.Derivative @scala.annotation.unchecked.uncheckedVariance = FormattedDerivative.this.deriv;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(FormattedDerivative.this);
    override def toString(): String = ScalaRunTime.this._toString(FormattedDerivative.this);
    override def equals(x$1: Any): Boolean = FormattedDerivative.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (deriv: model.Derivative)formats.package.FormattedDerivative((deriv$1 @ _)) if deriv$1.==(deriv) => x$1.asInstanceOf[formats.package.FormattedDerivative].canEqual(FormattedDerivative.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "FormattedDerivative";
    override def productArity: Int = 1;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => deriv
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[formats.package.FormattedDerivative]()
  };
  final <synthetic> object FormattedDerivative extends scala.runtime.AbstractFunction1[model.Derivative,formats.package.FormattedDerivative] with ScalaObject with Serializable {
    def this(): object formats.package.FormattedDerivative = {
      FormattedDerivative.super.this();
      ()
    };
    final override def toString(): java.lang.String = "FormattedDerivative";
    case <synthetic> def unapply(x$0: formats.package.FormattedDerivative): Option[model.Derivative] = if (x$0.==(null))
      scala.this.None
    else
      new Some[model.Derivative](x$0.deriv);
    case <synthetic> def apply(deriv: model.Derivative): formats.package.FormattedDerivative = new package.this.FormattedDerivative(deriv);
    protected def readResolve(): java.lang.Object = package.this.FormattedDerivative
  };
  implicit def derivativeFormatted(d: model.Derivative): formats.package.FormattedDerivative = new formats.package.FormattedDerivative(d)
}
package: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.100
         timesta securit dateTim compSec derivat standar bigDeci conditi bigDeci securit

final object RWTwitter extends java.lang.Object with ScalaObject {
  def this(): object code.keys.RWTwitter = {
    RWTwitter.super.this();
    ()
  };
  private[this] val consumerKey: java.lang.String = "JNLv3DtNcVMHekOdv0rBDg";
  <stable> <accessor> def consumerKey: java.lang.String = RWTwitter.this.consumerKey;
  private[this] val consumerSecret: java.lang.String = "U1gdVqWhVGqne1w6am0LKjv2E9aaupV6bLLaLsPgU";
  <stable> <accessor> def consumerSecret: java.lang.String = RWTwitter.this.consumerSecret;
  private[this] val accessToken: java.lang.String = "371457808-CYnhk5C1Ownzx054VRSuq0NXwYk2XDYSydMejfjI";
  <stable> <accessor> def accessToken: java.lang.String = RWTwitter.this.accessToken;
  private[this] val accessTokenSecret: java.lang.String = "U622G3rXHjmhyYxoa23XIprfeFcc1rIilmY4DSlvd4";
  <stable> <accessor> def accessTokenSecret: java.lang.String = RWTwitter.this.accessTokenSecret;
  private[this] val accessUser: java.lang.String = "pitfail";
  <stable> <accessor> def accessUser: java.lang.String = RWTwitter.this.accessUser
}
RWTwitter: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

case class Stuff extends java.lang.Object with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val name: String = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def name: String = Stuff.this.name;
  <caseaccessor> <paramaccessor> private[this] val invitees: Seq[model.schema.User] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def invitees: Seq[model.schema.User] = Stuff.this.invitees;
  def this(name: String, invitees: Seq[model.schema.User]): NewPortfolio.this.Stuff = {
    Stuff.super.this();
    ()
  };
  <synthetic> def copy(name: String = name, invitees: Seq[model.schema.User] = invitees): NewPortfolio.this.Stuff = new NewPortfolio.this.Stuff(name, invitees);
  <synthetic> def copy$default$2: Seq[model.schema.User] @scala.annotation.unchecked.uncheckedVariance = Stuff.this.invitees;
  <synthetic> def copy$default$1: String @scala.annotation.unchecked.uncheckedVariance = Stuff.this.name;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(Stuff.this);
  override def toString(): String = ScalaRunTime.this._toString(Stuff.this);
  override def equals(x$1: Any): Boolean = Stuff.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (name: String, invitees: Seq[model.schema.User])NewPortfolio.this.Stuff((name$1 @ _), (invitees$1 @ _)) if name$1.==(name).&&(invitees$1.==(invitees)) => x$1.asInstanceOf[NewPortfolio.this.Stuff].canEqual(Stuff.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "Stuff";
  override def productArity: Int = 2;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => name
    case 1 => invitees
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[NewPortfolio.this.Stuff]()
}
Stuff: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
 invitee
    name

final case object NoSuchPortfolio extends java.lang.RuntimeException with errors.package.BadUser with ScalaObject with Product with Serializable {
  def this(): object SchemaErrors.this.NoSuchPortfolio = {
    NoSuchPortfolio.super.this();
    ()
  };
  final override def hashCode(): Int = -1253656992;
  override def productPrefix: java.lang.String = "NoSuchPortfolio";
  override def productArity: Int = 0;
  override def productElement(x$1: Int): Any = x$1 match {
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[object SchemaErrors.this.NoSuchPortfolio]()
}
NoSuchPortfolio: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

case class NewUser extends java.lang.Object with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val user: UserSchema.this.User = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def user: UserSchema.this.User = NewUser.this.user;
  def this(user: UserSchema.this.User): UserSchema.this.NewUser = {
    NewUser.super.this();
    ()
  };
  <synthetic> def copy(user: UserSchema.this.User = user): UserSchema.this.NewUser = new UserSchema.this.NewUser(user);
  <synthetic> def copy$default$1: UserSchema.this.User @scala.annotation.unchecked.uncheckedVariance = NewUser.this.user;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(NewUser.this);
  override def toString(): String = ScalaRunTime.this._toString(NewUser.this);
  override def equals(x$1: Any): Boolean = NewUser.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (user: UserSchema.this.User)UserSchema.this.NewUser((user$2 @ _)) if user$2.==(user) => x$1.asInstanceOf[UserSchema.this.NewUser].canEqual(NewUser.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "NewUser";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => user
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[UserSchema.this.NewUser]()
}
NewUser: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
    user

class NumberField extends intform.TextField[scala.math.BigDecimal] with ScalaObject {
  <paramaccessor> private[this] val initText: String = _;
  def this(initText: String): intform.NumberField = {
    NumberField.super.this(initText);
    ()
  };
  def produce(): intform.SubmitResult[scala.math.BigDecimal] = try {
    new intform.OK[scala.math.BigDecimal](scala.math.BigDecimal.apply(NumberField.this.text))
  } catch {
    case (_: NumberFormatException) => new intform.Error("Should be a number")
  }
}
NumberField: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
         produce
 initTex        

final object ShortThrowableRenderer extends  {
  def this() = _
}
ShortThrowableRenderer: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

final object UnitProcessable extends java.lang.Object with intform.Processable[Unit] with ScalaObject {
  def this(): object intform.UnitProcessable = {
    UnitProcessable.super.this();
    ()
  };
  def process(): Some[Unit] = new Some[Unit](())
}
UnitProcessable: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
         process

case class AddToDerivative extends StockOrder with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val quote: stockdata.Quote = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def quote: stockdata.Quote = AddToDerivative.this.quote;
  <caseaccessor> <paramaccessor> private[this] val shares: model.Shares = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def shares: model.Shares = AddToDerivative.this.shares;
  def this(quote: stockdata.Quote, shares: model.Shares): code.snippet.AddToDerivative = {
    AddToDerivative.super.this();
    ()
  };
  <synthetic> def copy(quote: stockdata.Quote = quote, shares: model.Shares = shares): code.snippet.AddToDerivative = new snippet.this.AddToDerivative(quote, shares);
  <synthetic> def copy$default$2: model.Shares @scala.annotation.unchecked.uncheckedVariance = AddToDerivative.this.shares;
  <synthetic> def copy$default$1: stockdata.Quote @scala.annotation.unchecked.uncheckedVariance = AddToDerivative.this.quote;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(AddToDerivative.this);
  override def toString(): String = ScalaRunTime.this._toString(AddToDerivative.this);
  override def equals(x$1: Any): Boolean = AddToDerivative.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (quote: stockdata.Quote, shares: model.Shares)code.snippet.AddToDerivative((quote$2 @ _), (shares$1 @ _)) if quote$2.==(quote).&&(shares$1.==(shares)) => x$1.asInstanceOf[code.snippet.AddToDerivative].canEqual(AddToDerivative.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "AddToDerivative";
  override def productArity: Int = 2;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => quote
    case 1 => shares
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[code.snippet.AddToDerivative]()
}
AddToDerivative: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
   quote
  shares

class Submit[A >: Nothing <: Any] extends java.lang.Object with intform.SubmitRender with net.liftweb.common.Loggable with intform.FieldRender with intform.BasicErrors with intform.ErrorRender with ScalaObject {
  <paramaccessor> private[this] val form: () => intform.Processable[A] with intform.Refreshable = _;
  <paramaccessor> private[this] val callback: A => net.liftweb.http.js.JsCmd = _;
  <paramaccessor> private[this] val value: String = _;
  <stable> <accessor> <paramaccessor> def value: String = Submit.this.value;
  <paramaccessor> private[this] val refresh: Boolean = _;
  def this(form: () => intform.Processable[A] with intform.Refreshable, callback: A => net.liftweb.http.js.JsCmd, value: String, refresh: Boolean): intform.Submit[A] = {
    Submit.super.this();
    ()
  };
  def submitAjax(): net.liftweb.http.js.JsCmd = {
    Submit.this.logger.info("Submitting!");
    val cmd: net.liftweb.http.js.JsCmd = Submit.this.runWithErrors({
      val result: Option[A] = Submit.this.form.apply().process();
      result match {
        case (x: A)Some[A]((r @ _)) => Submit.this.logger.info("Resulted in ".+(r))
        case scala.None => Submit.this.logger.info("Failed do to input errors")
      };
      result.map[net.liftweb.http.js.JsCmd](Submit.this.callback).getOrElse[net.liftweb.http.js.JsCmd](net.liftweb.http.js.JsCmds.Noop)
    });
    if (Submit.this.refresh)
      Submit.this.form.apply().refresh().&(cmd)
    else
      cmd
  }
}
Submit: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
         submitA
 refresh     X  
   value        
    form     X  
 callbac     X  

case class AuctionOffer extends java.lang.Object with model.KL with AuctionSchema.this.AuctionOfferOps with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val id: model.package.Key = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def id: model.package.Key = AuctionOffer.this.id;
  <caseaccessor> <paramaccessor> private[this] val derivative: model.Derivative = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def derivative: model.Derivative = AuctionOffer.this.derivative;
  <caseaccessor> <paramaccessor> private[this] val offerer: model.Link[AuctionSchema.this.Portfolio] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def offerer: model.Link[AuctionSchema.this.Portfolio] = AuctionOffer.this.offerer;
  <caseaccessor> <paramaccessor> private[this] val price: model.Dollars = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def price: model.Dollars = AuctionOffer.this.price;
  <caseaccessor> <paramaccessor> private[this] val when: org.joda.time.DateTime = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def when: org.joda.time.DateTime = AuctionOffer.this.when;
  <caseaccessor> <paramaccessor> private[this] val expires: org.joda.time.DateTime = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def expires: org.joda.time.DateTime = AuctionOffer.this.expires;
  def this(id: model.package.Key = model.this.`package`.nextID, derivative: model.Derivative, offerer: model.Link[AuctionSchema.this.Portfolio], price: model.Dollars, when: org.joda.time.DateTime, expires: org.joda.time.DateTime): AuctionSchema.this.AuctionOffer = {
    AuctionOffer.super.this();
    ()
  };
  <synthetic> def copy(id: model.package.Key = id, derivative: model.Derivative = derivative, offerer: model.Link[AuctionSchema.this.Portfolio] = offerer, price: model.Dollars = price, when: org.joda.time.DateTime = when, expires: org.joda.time.DateTime = expires): AuctionSchema.this.AuctionOffer = new AuctionSchema.this.AuctionOffer(id, derivative, offerer, price, when, expires);
  <synthetic> def copy$default$6: org.joda.time.DateTime @scala.annotation.unchecked.uncheckedVariance = AuctionOffer.this.expires;
  <synthetic> def copy$default$5: org.joda.time.DateTime @scala.annotation.unchecked.uncheckedVariance = AuctionOffer.this.when;
  <synthetic> def copy$default$4: model.Dollars @scala.annotation.unchecked.uncheckedVariance = AuctionOffer.this.price;
  <synthetic> def copy$default$3: model.Link[AuctionSchema.this.Portfolio] @scala.annotation.unchecked.uncheckedVariance = AuctionOffer.this.offerer;
  <synthetic> def copy$default$2: model.Derivative @scala.annotation.unchecked.uncheckedVariance = AuctionOffer.this.derivative;
  <synthetic> def copy$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = AuctionOffer.this.id;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(AuctionOffer.this);
  override def toString(): String = ScalaRunTime.this._toString(AuctionOffer.this);
  override def equals(x$1: Any): Boolean = AuctionOffer.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (id: model.package.Key, derivative: model.Derivative, offerer: model.Link[AuctionSchema.this.Portfolio], price: model.Dollars, when: org.joda.time.DateTime, expires: org.joda.time.DateTime)AuctionSchema.this.AuctionOffer((id$1 @ _), (derivative$1 @ _), (offerer$1 @ _), (price$1 @ _), (when$1 @ _), (expires$1 @ _)) if id$1.==(id).&&(derivative$1.==(derivative)).&&(offerer$1.==(offerer)).&&(price$1.==(price)).&&(when$1.==(when)).&&(expires$1.==(expires)) => x$1.asInstanceOf[AuctionSchema.this.AuctionOffer].canEqual(AuctionOffer.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "AuctionOffer";
  override def productArity: Int = 6;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => id
    case 1 => derivative
    case 2 => offerer
    case 3 => price
    case 4 => when
    case 5 => expires
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[AuctionSchema.this.AuctionOffer]()
}
AuctionOffer: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
 expires
   price
      id
 derivat
 offerer
    when

final object GetPortfolio extends  {
  def this() = _;
  private <static> val serialVersionUID: Long = _
}
GetPortfolio: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

case class Dividend extends java.lang.Object with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val ticker: String = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def ticker: String = Dividend.this.ticker;
  <caseaccessor> <paramaccessor> private[this] val date: org.joda.time.DateTime = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def date: org.joda.time.DateTime = Dividend.this.date;
  <caseaccessor> <paramaccessor> private[this] val price: model.Price = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def price: model.Price = Dividend.this.price;
  def this(ticker: String, date: org.joda.time.DateTime, price: model.Price): stockdata.Dividend = {
    Dividend.super.this();
    ()
  };
  <synthetic> def copy(ticker: String = ticker, date: org.joda.time.DateTime = date, price: model.Price = price): stockdata.Dividend = new stockdata.this.Dividend(ticker, date, price);
  <synthetic> def copy$default$3: model.Price @scala.annotation.unchecked.uncheckedVariance = Dividend.this.price;
  <synthetic> def copy$default$2: org.joda.time.DateTime @scala.annotation.unchecked.uncheckedVariance = Dividend.this.date;
  <synthetic> def copy$default$1: String @scala.annotation.unchecked.uncheckedVariance = Dividend.this.ticker;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(Dividend.this);
  override def toString(): String = ScalaRunTime.this._toString(Dividend.this);
  override def equals(x$1: Any): Boolean = Dividend.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (ticker: String, date: org.joda.time.DateTime, price: model.Price)stockdata.Dividend((ticker$1 @ _), (date$1 @ _), (price$1 @ _)) if ticker$1.==(ticker).&&(date$1.==(date)).&&(price$1.==(price)) => x$1.asInstanceOf[stockdata.Dividend].canEqual(Dividend.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "Dividend";
  override def productArity: Int = 3;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => ticker
    case 1 => date
    case 2 => price
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[stockdata.Dividend]()
}
Dividend: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
   price
    date
  ticker

case class Bid extends java.lang.Object with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val amount: model.Dollars = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def amount: model.Dollars = Bid.this.amount;
  def this(amount: model.Dollars): AuctionPage.this.Bid = {
    Bid.super.this();
    ()
  };
  <synthetic> def copy(amount: model.Dollars = amount): AuctionPage.this.Bid = new AuctionPage.this.Bid(amount);
  <synthetic> def copy$default$1: model.Dollars @scala.annotation.unchecked.uncheckedVariance = Bid.this.amount;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(Bid.this);
  override def toString(): String = ScalaRunTime.this._toString(Bid.this);
  override def equals(x$1: Any): Boolean = Bid.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (amount: model.Dollars)AuctionPage.this.Bid((amount$1 @ _)) if amount$1.==(amount) => x$1.asInstanceOf[AuctionPage.this.Bid].canEqual(Bid.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "Bid";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => amount
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[AuctionPage.this.Bid]()
}
Bid: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
  amount

final object PortfolioSwitcher extends java.lang.Object with net.liftweb.common.Loggable with ScalaObject {
  def this(): object code.control.PortfolioSwitcher = {
    PortfolioSwitcher.super.this();
    ()
  };
  def currentPortfolio: model.schema.Portfolio = PortfolioSwitcher.this.savedPortfolio.is match {
    case (x: model.package.Key)Some[model.package.Key]((key @ _)) => model.schema.Portfolio.byID(key)
    case scala.None => {
      val port: model.Link[model.schema.Portfolio] = LoginManager.currentUser.lastPortfolio;
      sessions.`package`.toColon[Option[model.package.Key]](PortfolioSwitcher.this.savedPortfolio).:=(new Some[model.package.Key](port.id));
      model.this.Link.extract[model.schema.Portfolio](port)(model.schema.portfolios)
    }
  };
  def switchPortfolio(name: String): Unit = {
    val user: model.schema.User = LoginManager.currentUser;
    val port: model.schema.Portfolio = user.portfolioByName(name);
    sessions.`package`.toColon[Option[model.package.Key]](PortfolioSwitcher.this.savedPortfolio).:=(new Some[model.package.Key](port.id));
    user.userSwitchPortfolio(port)
  };
  def clearOnLogin(): Unit = {
    sessions.`package`.toColon[Option[model.package.Key]](PortfolioSwitcher.this.savedPortfolio).:=(scala.None);
    ()
  };
  final object savedPortfolio extends net.liftweb.http.SessionVar[Option[model.package.Key]] with ScalaObject {
    def this(): object code.control.PortfolioSwitcher.savedPortfolio = {
      savedPortfolio.super.this(scala.None);
      ()
    }
  }
}
PortfolioSwitcher: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.333
         clearOn current switchP

final object Twitter extends java.lang.Object with ScalaObject {
  def this(): object code.keys.Twitter = {
    Twitter.super.this();
    ()
  };
  private[this] val consumerKey: java.lang.String = "JZeuZEErkTC1IknbWAfOYw";
  <stable> <accessor> def consumerKey: java.lang.String = Twitter.this.consumerKey;
  private[this] val consumerSecret: java.lang.String = "QRXHtGTLRrBcKu9q9Vi5vYiJVd92NZLFmh7nUevnQyg";
  <stable> <accessor> def consumerSecret: java.lang.String = Twitter.this.consumerSecret;
  private[this] val accessToken: java.lang.String = "371457808-uWoKV07rIcptEmHie4n4hCQQ7sGVS2Abtl5djb0V";
  <stable> <accessor> def accessToken: java.lang.String = Twitter.this.accessToken;
  private[this] val accessTokenSecret: java.lang.String = "9Fa4PqfzDkUXp4xG5xiSMz4yKjDlSv3FmpedXh3nNQ4";
  <stable> <accessor> def accessTokenSecret: java.lang.String = Twitter.this.accessTokenSecret;
  private[this] val accessUser: java.lang.String = "pitfail";
  <stable> <accessor> def accessUser: java.lang.String = Twitter.this.accessUser
}
Twitter: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

final object Link extends java.lang.Object with ScalaObject {
  def this(): object model.Link = {
    Link.super.this();
    ()
  };
  implicit def extract[R >: Nothing <: model.KL](link: model.Link[R])(implicit table: model.Table[R]): R = link.extract(table)
}
Link: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
         extract

case class Failed extends Status with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val msg: String = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def msg: String = Failed.this.msg;
  def this(msg: String): texttrading.Failed = {
    Failed.super.this();
    ()
  };
  <synthetic> def copy(msg: String = msg): texttrading.Failed = new texttrading.this.Failed(msg);
  <synthetic> def copy$default$1: String @scala.annotation.unchecked.uncheckedVariance = Failed.this.msg;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(Failed.this);
  override def toString(): String = ScalaRunTime.this._toString(Failed.this);
  override def equals(x$1: Any): Boolean = Failed.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (msg: String)texttrading.Failed((msg$2 @ _)) if msg$2.==(msg) => x$1.asInstanceOf[texttrading.Failed].canEqual(Failed.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "Failed";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => msg
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[texttrading.Failed]()
}
Failed: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
     msg

final case object NoSuchAuction extends java.lang.RuntimeException with errors.package.BadUser with ScalaObject with Product with Serializable {
  def this(): object SchemaErrors.this.NoSuchAuction = {
    NoSuchAuction.super.this();
    ()
  };
  final override def hashCode(): Int = -1285556901;
  override def productPrefix: java.lang.String = "NoSuchAuction";
  override def productArity: Int = 0;
  override def productElement(x$1: Int): Any = x$1 match {
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[object SchemaErrors.this.NoSuchAuction]()
}
NoSuchAuction: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

case class FormattedSecurities extends java.lang.Object with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val securities: Seq[model.Security] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def securities: Seq[model.Security] = FormattedSecurities.this.securities;
  def this(securities: Seq[model.Security]): formats.package.FormattedSecurities = {
    FormattedSecurities.super.this();
    ()
  };
  def toHumanString: String = FormattedSecurities.this.securities.map[String, Seq[String]](((x$3: model.Security) => package.this.securityFormatted(x$3).toHumanString))(collection.this.Seq.canBuildFrom[String]).mkString(" + ");
  <synthetic> def copy(securities: Seq[model.Security] = securities): formats.package.FormattedSecurities = new package.this.FormattedSecurities(securities);
  <synthetic> def copy$default$1: Seq[model.Security] @scala.annotation.unchecked.uncheckedVariance = FormattedSecurities.this.securities;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(FormattedSecurities.this);
  override def toString(): String = ScalaRunTime.this._toString(FormattedSecurities.this);
  override def equals(x$1: Any): Boolean = FormattedSecurities.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (securities: Seq[model.Security])formats.package.FormattedSecurities((securities$1 @ _)) if securities$1.==(securities) => x$1.asInstanceOf[formats.package.FormattedSecurities].canEqual(FormattedSecurities.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "FormattedSecurities";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => securities
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[formats.package.FormattedSecurities]()
}
FormattedSecurities: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
         toHuman
 securit     X  

final class $anon extends UserField with intform.FieldErrorRender {
  def this(): anonymous class $anon = {
    $anon.super.this("");
    ()
  }
}
$anon: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

abstract trait CaseRender extends java.lang.Object with intform.FieldRender with intform.ErrorRender with ScalaObject {
  def /*CaseRender*/$init$(): Unit = {
    ()
  };
  <stable> <accessor> def table: Map[String,intform.Field[Any]];
  <accessor> def selected: Option[String];
  <accessor> def selected_=(x$1: Option[String]): Unit;
  <stable> <accessor> def renderer: intform.CaseChoices => scala.xml.NodeSeq;
  def main: scala.xml.NodeSeq = CaseRender.this.renderer.apply(new CaseChoices({
    val holder: net.liftweb.http.SHtml.ChoiceHolder[String] = net.liftweb.http.SHtml.radio(CaseRender.this.table.keys.toList, common.this.Box.option2Box[String](CaseRender.this.selected), ((s: String) => CaseRender.this.selected_=(new Some[String](s))));
    scala.this.Predef.intWrapper(0).to(intform.`package`.tuplist1[Iterable[String]](CaseRender.this.table.keys).length).map[scala.xml.NodeSeq, Seq[scala.xml.NodeSeq]](((x$2: Int) => holder.apply(x$2)))(immutable.this.IndexedSeq.canBuildFrom[scala.xml.NodeSeq])
  }))
}
CaseRender: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
            main
 rendere     X  
 selecte     X  
 selecte     X  
   table     X  

class UserField extends intform.TextField[model.schema.User] with ScalaObject {
  <paramaccessor> private[this] val initText: String = _;
  def this(initText: String): code.snippet.UserField = {
    UserField.super.this(initText);
    ()
  };
  def produce(): intform.SubmitResult[model.schema.User] = try {
    model.schema.readDB[intform.OK[model.schema.User]](new intform.OK[model.schema.User](model.schema.User.byName(UserField.this.text)))
  } catch {
    case model.schema.NoSuchUser => new intform.Error("No user named ".+(UserField.this.text))
  }
}
UserField: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
         produce
 initTex        

final class $anon extends scala.AnyRef {
  def this(): anonymous class $anon = {
    $anon.super.this();
    ()
  };
  def orCreate(trans: => Transactions.this.Transaction[R]): Transactions.this.Transaction[R] = already match {
    case (x: R)Some[R]((r @ _)) => new Transactions.this.Transaction[R](r, immutable.this.Nil)
    case scala.None => trans
  }
}
$anon: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
         orCreat

case class NotEnoughShares extends java.lang.RuntimeException with errors.package.BadUser with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val have: model.Shares = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def have: model.Shares = NotEnoughShares.this.have;
  <caseaccessor> <paramaccessor> private[this] val need: model.Shares = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def need: model.Shares = NotEnoughShares.this.need;
  def this(have: model.Shares, need: model.Shares): SchemaErrors.this.NotEnoughShares = {
    NotEnoughShares.super.this();
    ()
  };
  <synthetic> def copy(have: model.Shares = have, need: model.Shares = need): SchemaErrors.this.NotEnoughShares = new SchemaErrors.this.NotEnoughShares(have, need);
  <synthetic> def copy$default$2: model.Shares @scala.annotation.unchecked.uncheckedVariance = NotEnoughShares.this.need;
  <synthetic> def copy$default$1: model.Shares @scala.annotation.unchecked.uncheckedVariance = NotEnoughShares.this.have;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(NotEnoughShares.this);
  override def equals(x$1: Any): Boolean = NotEnoughShares.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (have: model.Shares, need: model.Shares)SchemaErrors.this.NotEnoughShares((have$2 @ _), (need$2 @ _)) if have$2.==(have).&&(need$2.==(need)) => x$1.asInstanceOf[SchemaErrors.this.NotEnoughShares].canEqual(NotEnoughShares.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "NotEnoughShares";
  override def productArity: Int = 2;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => have
    case 1 => need
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[SchemaErrors.this.NotEnoughShares]()
}
NotEnoughShares: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
    have
    need

case class Bought extends java.lang.Object with NewsSchema.this.Action with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val buyer: NewsSchema.this.P = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def buyer: NewsSchema.this.P = Bought.this.buyer;
  <caseaccessor> <paramaccessor> private[this] val stock: String = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def stock: String = Bought.this.stock;
  <caseaccessor> <paramaccessor> private[this] val shares: model.Shares = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def shares: model.Shares = Bought.this.shares;
  <caseaccessor> <paramaccessor> private[this] val dollars: model.Dollars = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def dollars: model.Dollars = Bought.this.dollars;
  <caseaccessor> <paramaccessor> private[this] val price: model.Price = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def price: model.Price = Bought.this.price;
  def this(buyer: NewsSchema.this.P, stock: String, shares: model.Shares, dollars: model.Dollars, price: model.Price): NewsSchema.this.Bought = {
    Bought.super.this();
    ()
  };
  <synthetic> def copy(buyer: NewsSchema.this.P = buyer, stock: String = stock, shares: model.Shares = shares, dollars: model.Dollars = dollars, price: model.Price = price): NewsSchema.this.Bought = new NewsSchema.this.Bought(buyer, stock, shares, dollars, price);
  <synthetic> def copy$default$5: model.Price @scala.annotation.unchecked.uncheckedVariance = Bought.this.price;
  <synthetic> def copy$default$4: model.Dollars @scala.annotation.unchecked.uncheckedVariance = Bought.this.dollars;
  <synthetic> def copy$default$3: model.Shares @scala.annotation.unchecked.uncheckedVariance = Bought.this.shares;
  <synthetic> def copy$default$2: String @scala.annotation.unchecked.uncheckedVariance = Bought.this.stock;
  <synthetic> def copy$default$1: NewsSchema.this.P @scala.annotation.unchecked.uncheckedVariance = Bought.this.buyer;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(Bought.this);
  override def toString(): String = ScalaRunTime.this._toString(Bought.this);
  override def equals(x$1: Any): Boolean = Bought.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (buyer: NewsSchema.this.P, stock: String, shares: model.Shares, dollars: model.Dollars, price: model.Price)NewsSchema.this.Bought((buyer$1 @ _), (stock$1 @ _), (shares$1 @ _), (dollars$1 @ _), (price$1 @ _)) if buyer$1.==(buyer).&&(stock$1.==(stock)).&&(shares$1.==(shares)).&&(dollars$1.==(dollars)).&&(price$1.==(price)) => x$1.asInstanceOf[NewsSchema.this.Bought].canEqual(Bought.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "Bought";
  override def productArity: Int = 5;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => buyer
    case 1 => stock
    case 2 => shares
    case 3 => dollars
    case 4 => price
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[NewsSchema.this.Bought]()
}
Bought: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
  shares
   price
   buyer
 dollars
   stock

class ListField[A >: Nothing <: Any] extends intform.Field[Seq[A]] with intform.ListRender with ScalaObject {
  <paramaccessor> private[this] val generator: () => intform.Field[A] with intform.Renderable = _;
  <stable> <accessor> <paramaccessor> def generator: () => intform.Field[A] with intform.Renderable = ListField.this.generator;
  <paramaccessor> private[this] val renderer: (Seq[intform.ItemRender], scala.xml.NodeSeq) => scala.xml.NodeSeq = _;
  <stable> <accessor> <paramaccessor> def renderer: (Seq[intform.ItemRender], scala.xml.NodeSeq) => scala.xml.NodeSeq = ListField.this.renderer;
  def this(generator: () => intform.Field[A] with intform.Renderable, renderer: (Seq[intform.ItemRender], scala.xml.NodeSeq) => scala.xml.NodeSeq): intform.ListField[A] = {
    ListField.super.this();
    ()
  };
  private[this] val items: scala.collection.mutable.ArrayBuffer[intform.Field[A] with intform.Renderable] = scala.collection.mutable.ArrayBuffer.apply[intform.Field[A] with intform.Renderable]();
  <stable> <accessor> def items: scala.collection.mutable.ArrayBuffer[intform.Field[A] with intform.Renderable] = ListField.this.items;
  def addOne(): Unit = ListField.this.items.append(ListField.this.generator.apply());
  def deleteOne(n: Int): Unit = {
    ListField.this.items.remove(n);
    ()
  };
  def reset(): Unit = ListField.this.items.clear();
  def produce(): intform.SubmitResult[Seq[A]] = scalaz.Scalaz.SeqMA[scala.collection.mutable.ArrayBuffer, Option[A]](ListField.this.items.map[Option[A], scala.collection.mutable.ArrayBuffer[Option[A]]](((x$4: intform.Field[A] with intform.Renderable) => x$4.process()))(mutable.this.ArrayBuffer.canBuildFrom[Option[A]])).sequence[Option, A](scala.this.Predef.conforms[Option[A]], scalaz.this.Traverse.TraversableTraverse[scala.collection.mutable.ArrayBuffer](scalaz.this.CanBuildAnySelf.GenericCanBuildSelf[scala.collection.mutable.ArrayBuffer](mutable.this.ArrayBuffer.canBuildFrom[Nothing])), scalaz.this.Applicative.applicative[Option](scalaz.this.Pure.OptionPure, scalaz.this.Apply.FunctorBindApply[Option](scalaz.this.Functor.OptionFunctor, scalaz.this.Bind.OptionBind))) match {
    case (x: scala.collection.mutable.ArrayBuffer[A])Some[scala.collection.mutable.ArrayBuffer[A]]((a @ _)) => new intform.OK[scala.collection.mutable.ArrayBuffer[A]](a)
    case scala.None => ChildError
  }
}
ListField: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.250
          addOne produce   reset deleteO
 rendere                                
 generat     X                          

class SearchBar extends java.lang.Object with intform.Page with net.liftweb.common.Loggable with ScalaObject {
  def this(): code.snippet.SearchBar = {
    SearchBar.super.this();
    ()
  };
  sealed abstract trait Status extends scala.AnyRef;
  final case object Idle extends java.lang.Object with SearchBar.this.Status with ScalaObject with Product with Serializable {
    def this(): object SearchBar.this.Idle = {
      Idle.super.this();
      ()
    };
    final override def hashCode(): Int = 2274292;
    final override def toString(): java.lang.String = "Idle";
    override def productPrefix: java.lang.String = "Idle";
    override def productArity: Int = 0;
    override def productElement(x$1: Int): Any = x$1 match {
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[object SearchBar.this.Idle]()
  };
  @volatile <synthetic> private[this] var Idle$module: object SearchBar.this.Idle = _;
  final case <stable> def Idle: object SearchBar.this.Idle = {
    SearchBar.this.Idle$module = new object SearchBar.this.Idle();
    SearchBar.this.Idle$module
  };
  case class HaveQuote extends java.lang.Object with SearchBar.this.Status with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val quote: stockdata.Quote = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def quote: stockdata.Quote = HaveQuote.this.quote;
    def this(quote: stockdata.Quote): SearchBar.this.HaveQuote = {
      HaveQuote.super.this();
      ()
    };
    <synthetic> def copy(quote: stockdata.Quote = quote): SearchBar.this.HaveQuote = new SearchBar.this.HaveQuote(quote);
    <synthetic> def copy$default$1: stockdata.Quote @scala.annotation.unchecked.uncheckedVariance = HaveQuote.this.quote;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(HaveQuote.this);
    override def toString(): String = ScalaRunTime.this._toString(HaveQuote.this);
    override def equals(x$1: Any): Boolean = HaveQuote.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (quote: stockdata.Quote)SearchBar.this.HaveQuote((quote$1 @ _)) if quote$1.==(quote) => x$1.asInstanceOf[SearchBar.this.HaveQuote].canEqual(HaveQuote.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "HaveQuote";
    override def productArity: Int = 1;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => quote
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[SearchBar.this.HaveQuote]()
  };
  final <synthetic> object HaveQuote extends scala.runtime.AbstractFunction1[stockdata.Quote,SearchBar.this.HaveQuote] with ScalaObject with Serializable {
    def this(): object SearchBar.this.HaveQuote = {
      HaveQuote.super.this();
      ()
    };
    final override def toString(): java.lang.String = "HaveQuote";
    case <synthetic> def unapply(x$0: SearchBar.this.HaveQuote): Option[stockdata.Quote] = if (x$0.==(null))
      scala.this.None
    else
      new Some[stockdata.Quote](x$0.quote);
    case <synthetic> def apply(quote: stockdata.Quote): SearchBar.this.HaveQuote = new SearchBar.this.HaveQuote(quote)
  };
  @volatile <synthetic> private[this] var HaveQuote$module: object SearchBar.this.HaveQuote = _;
  final <synthetic> <stable> def HaveQuote: object SearchBar.this.HaveQuote = {
    SearchBar.this.HaveQuote$module = new object SearchBar.this.HaveQuote();
    SearchBar.this.HaveQuote$module
  };
  case class HaveCommand extends java.lang.Object with SearchBar.this.Status with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val command: String = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def command: String = HaveCommand.this.command;
    <caseaccessor> <paramaccessor> private[this] val response: Seq[String] = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def response: Seq[String] = HaveCommand.this.response;
    def this(command: String, response: Seq[String]): SearchBar.this.HaveCommand = {
      HaveCommand.super.this();
      ()
    };
    <synthetic> def copy(command: String = command, response: Seq[String] = response): SearchBar.this.HaveCommand = new SearchBar.this.HaveCommand(command, response);
    <synthetic> def copy$default$2: Seq[String] @scala.annotation.unchecked.uncheckedVariance = HaveCommand.this.response;
    <synthetic> def copy$default$1: String @scala.annotation.unchecked.uncheckedVariance = HaveCommand.this.command;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(HaveCommand.this);
    override def toString(): String = ScalaRunTime.this._toString(HaveCommand.this);
    override def equals(x$1: Any): Boolean = HaveCommand.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (command: String, response: Seq[String])SearchBar.this.HaveCommand((command$1 @ _), (response$1 @ _)) if command$1.==(command).&&(response$1.==(response)) => x$1.asInstanceOf[SearchBar.this.HaveCommand].canEqual(HaveCommand.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "HaveCommand";
    override def productArity: Int = 2;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => command
      case 1 => response
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[SearchBar.this.HaveCommand]()
  };
  final <synthetic> object HaveCommand extends scala.runtime.AbstractFunction2[String,Seq[String],SearchBar.this.HaveCommand] with ScalaObject with Serializable {
    def this(): object SearchBar.this.HaveCommand = {
      HaveCommand.super.this();
      ()
    };
    final override def toString(): java.lang.String = "HaveCommand";
    case <synthetic> def unapply(x$0: SearchBar.this.HaveCommand): Option[(String, Seq[String])] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(String, Seq[String])](new (String, Seq[String])(x$0.command, x$0.response));
    case <synthetic> def apply(command: String, response: Seq[String]): SearchBar.this.HaveCommand = new SearchBar.this.HaveCommand(command, response)
  };
  @volatile <synthetic> private[this] var HaveCommand$module: object SearchBar.this.HaveCommand = _;
  final <synthetic> <stable> def HaveCommand: object SearchBar.this.HaveCommand = {
    SearchBar.this.HaveCommand$module = new object SearchBar.this.HaveCommand();
    SearchBar.this.HaveCommand$module
  };
  private[this] var status: SearchBar.this.Status = SearchBar.this.Idle;
  private <accessor> def status: SearchBar.this.Status = SearchBar.this.status;
  private <accessor> def status_=(x$1: SearchBar.this.Status): Unit = SearchBar.this.status = x$1;
  private[this] val refreshable: intform.Refreshable.NeedRenderable with intform.Refreshable = intform.Refreshable.apply({
    {
      var $md: scala.xml.MetaData = scala.xml.Null;
      $md = new scala.xml.UnprefixedAttribute("id", new scala.xml.Text("search"), $md);
      $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("container"), $md);
      new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
        $buf.&+(new scala.xml.Text("\012            "));
        $buf.&+(SearchBar.this.queryForm.render);
        $buf.&+(new scala.xml.Text("\012            "));
        $buf.&+(SearchBar.this.feedback);
        $buf.&+(new scala.xml.Text("\012        "));
        $buf
      }: _*))
    }
  });
  private <stable> <accessor> def refreshable: intform.Refreshable.NeedRenderable with intform.Refreshable = SearchBar.this.refreshable;
  private[this] var listeners: List[SearchBar.this.Status => net.liftweb.http.js.JsCmd] = immutable.this.Nil;
  private <accessor> def listeners: List[SearchBar.this.Status => net.liftweb.http.js.JsCmd] = SearchBar.this.listeners;
  private <accessor> def listeners_=(x$1: List[SearchBar.this.Status => net.liftweb.http.js.JsCmd]): Unit = SearchBar.this.listeners = x$1;
  private def notify(status: SearchBar.this.Status, cmd: net.liftweb.http.js.JsCmd = net.liftweb.http.js.JsCmds.Noop): net.liftweb.http.js.JsCmd = SearchBar.this.listeners.map[net.liftweb.http.js.JsCmd, List[net.liftweb.http.js.JsCmd]](((callback: SearchBar.this.Status => net.liftweb.http.js.JsCmd) => callback.apply(status)))(immutable.this.List.canBuildFrom[net.liftweb.http.js.JsCmd]).foldLeft[net.liftweb.http.js.JsCmd](net.liftweb.http.js.JsCmds.Noop)(((x$1: net.liftweb.http.js.JsCmd, x$2: net.liftweb.http.js.JsCmd) => x$1.&(x$2)));
  private <synthetic> def notify$default$2: net.liftweb.http.js.JsCmd @scala.annotation.unchecked.uncheckedVariance = net.liftweb.http.js.JsCmds.Noop;
  private def notifyAndRefresh(status: SearchBar.this.Status, cmd: net.liftweb.http.js.JsCmd = net.liftweb.http.js.JsCmds.Noop): net.liftweb.http.js.JsCmd = SearchBar.this.notify(status, net.liftweb.http.js.JsCmds.Noop).&(SearchBar.this.refreshable.refresh()).&(cmd);
  private <synthetic> def notifyAndRefresh$default$2: net.liftweb.http.js.JsCmd @scala.annotation.unchecked.uncheckedVariance = net.liftweb.http.js.JsCmds.Noop;
  def listen(callback: SearchBar.this.Status => net.liftweb.http.js.JsCmd): Unit = SearchBar.this.listeners_=(SearchBar.this.listeners.::[SearchBar.this.Status => net.liftweb.http.js.JsCmd](callback));
  def changeQuote(stock: stockdata.Stock): net.liftweb.http.js.JsCmd = {
    SearchBar.this.status_=(new SearchBar.this.HaveQuote(model.StockPriceSource.getQuotes(scala.`package`.Iterable.apply[stockdata.Stock](stock)).head));
    SearchBar.this.notifyAndRefresh(SearchBar.this.status, new net.liftweb.http.js.JsCmds.Focus("search-quantity"))
  };
  def runCommand(command: String): net.liftweb.http.js.JsCmd = {
    val username: String = try {
      control.LoginManager.currentUser.username
    } catch {
      case control.LoginManager.NotLoggedIn => "Anonymous"
    };
    SearchBar.this.status_=(new SearchBar.this.HaveCommand(command, texttrading.TextTrader.runCommand(username, command, SearchBar.this.backend)));
    SearchBar.this.notifyAndRefresh(SearchBar.this.status, new net.liftweb.http.js.JsCmds.Focus("search-query-field"))
  };
  def clear: net.liftweb.http.js.JsCmd = {
    SearchBar.this.status_=(SearchBar.this.Idle);
    SearchBar.this.notifyAndRefresh(SearchBar.this.status, new net.liftweb.http.js.JsCmds.Focus("search-query-field"))
  };
  override def render: scala.xml.NodeSeq = SearchBar.this.refreshable.render;
  lazy private[this] var queryForm: intform.Form[String] = _;
  <stable> <accessor> lazy def queryForm: intform.Form[String] = {
    SearchBar.this.queryForm = intform.Form.apply[String, up.HList.:+:[String,up.HNil]](intform.`package`.hlistify1[String, String]({
      ((x: String) => scala.this.Predef.identity[String](x))
    }), intform.`package`.klist1[intform.Field, String]((SearchBar.this.tickerField: intform.Field[String])), {
  {
    var $md: scala.xml.MetaData = scala.xml.Null;
    $md = new scala.xml.UnprefixedAttribute("id", new scala.xml.Text("search-query"), $md);
    new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
      $buf.&+(new scala.xml.Text("\012            "));
      $buf.&+({
        {
          var $md: scala.xml.MetaData = scala.xml.Null;
          $md = new scala.xml.UnprefixedAttribute("id", new scala.xml.Text("search-query-field-hack"), $md);
          new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
            val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
            $buf.&+(new scala.xml.Text("\012                "));
            $buf.&+(intform.`package`.mergeAttr(SearchBar.this.tickerField.main).&({
              {
                var $md: scala.xml.MetaData = scala.xml.Null;
                $md = new scala.xml.UnprefixedAttribute("id", new scala.xml.Text("search-query-field"), $md);
                new scala.xml.Elem(null, "input", $md, scala.this.Predef.$scope)
              }
            }));
            $buf.&+(new scala.xml.Text("\012            "));
            $buf
          }: _*))
        }
      });
      $buf.&+(new scala.xml.Text("\012            "));
      $buf.&+(intform.`package`.mergeAttr(SearchBar.this.submit.main).&({
        {
          var $md: scala.xml.MetaData = scala.xml.Null;
          $md = new scala.xml.UnprefixedAttribute("id", new scala.xml.Text("search-query-button"), $md);
          new scala.xml.Elem(null, "input", $md, scala.this.Predef.$scope)
        }
      }));
      $buf.&+(new scala.xml.Text("\012            "));
      $buf.&+(SearchBar.this.submit.errors);
      $buf.&+(new scala.xml.Text("\012        "));
      $buf
    }: _*))
  }
}.++[scala.xml.Node, scala.xml.NodeSeq]({
      {
        new scala.xml.Elem(null, "p", scala.xml.Null, scala.this.Predef.$scope, ({
          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
          $buf.&+(SearchBar.this.tickerField.errors);
          $buf
        }: _*))
      }
    })(xml.this.NodeSeq.canBuildFrom));
    SearchBar.this.queryForm
  };
  lazy private[this] var tickerField: intform.StringField = _;
  <stable> <accessor> lazy def tickerField: intform.StringField = {
    SearchBar.this.tickerField = new intform.StringField("");
    SearchBar.this.tickerField
  };
  lazy private[this] var submit: intform.Submit[String] = _;
  <stable> <accessor> lazy def submit: intform.Submit[String] = {
    SearchBar.this.submit = intform.Submit.apply[String](SearchBar.this.queryForm, "Go", intform.Submit.apply$default$3[Nothing])(((fullText: String) => {
      val text: java.lang.String = fullText.trim();
      if (text.indexOf(32).!=(-1).||(texttrading.TextTrader.looksLikeCommand(text)))
        {
          SearchBar.this.queryForm.reset();
          SearchBar.this.runCommand(text)
        }
      else
        try {
          SearchBar.this.changeQuote(new stockdata.Stock(text))
        } catch {
          case (_: stockdata.NoSuchStockException) => {
            SearchBar.this.logger.info("Failed to find ".+(text));
            throw new intform.BadFieldInput(SearchBar.this.tickerField, "There is no stock with symbol ".+(text).+("."))
          }
        }
    }));
    SearchBar.this.submit
  };
  private[this] val backend: texttrading.PitFailBackend = new texttrading.PitFailBackend();
  private <stable> <accessor> def backend: texttrading.PitFailBackend = SearchBar.this.backend;
  def feedback: scala.xml.NodeSeq = SearchBar.this.status match {
    case (quote: stockdata.Quote)SearchBar.this.HaveQuote((quote @ _)) => quoteReport.apply(quote)
    case (command: String, response: Seq[String])SearchBar.this.HaveCommand((command @ _), (response @ _)) => SearchBar.this.commandReport(command, response)
    case SearchBar.this.Idle => SearchBar.this.instructions
  };
  def instructions: scala.xml.Elem = {
    {
      var $md: scala.xml.MetaData = scala.xml.Null;
      $md = new scala.xml.UnprefixedAttribute("id", new scala.xml.Text("search-instructions"), $md);
      $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("block"), $md);
      new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
        $buf.&+(new scala.xml.Text("\012            "));
        $buf.&+({
          {
            new scala.xml.Elem(null, "ol", scala.xml.Null, scala.this.Predef.$scope, ({
              val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
              $buf.&+(new scala.xml.Text("\012                "));
              $buf.&+(if (control.LoginManager.loggedIn_$qmark.unary_!)
                {
                  {
                    new scala.xml.Elem(null, "li", scala.xml.Null, scala.this.Predef.$scope, ({
                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                      $buf.&+(new scala.xml.Text("Click \"Login\" on the top right to login via Twitter"));
                      $buf
                    }: _*))
                  }
                }
              else
                ());
              $buf.&+(new scala.xml.Text("\012                "));
              $buf.&+({
                {
                  new scala.xml.Elem(null, "li", scala.xml.Null, scala.this.Predef.$scope, ({
                    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                    $buf.&+(new scala.xml.Text("Enter a ticker symbol into the search field above (Example: \"MSFT\")"));
                    $buf
                  }: _*))
                }
              });
              $buf.&+(new scala.xml.Text("\012                "));
              $buf.&+({
                {
                  new scala.xml.Elem(null, "li", scala.xml.Null, scala.this.Predef.$scope, ({
                    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                    $buf.&+(new scala.xml.Text("Choose an amount to buy (simple) or add to a derivative (more advanced)."));
                    $buf
                  }: _*))
                }
              });
              $buf.&+(new scala.xml.Text("\012                "));
              $buf.&+({
                {
                  new scala.xml.Elem(null, "li", scala.xml.Null, scala.this.Predef.$scope, ({
                    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                    $buf.&+(new scala.xml.Text("Manage your portfolio!"));
                    $buf
                  }: _*))
                }
              });
              $buf.&+(new scala.xml.Text("\012            "));
              $buf
            }: _*))
          }
        });
        $buf.&+(new scala.xml.Text("\012        "));
        $buf
      }: _*))
    }
  };
  def commandReport(command: String, response: Seq[String]): scala.xml.Elem = {
    val lines: Seq[scala.xml.Elem] = response.map[scala.xml.Elem, Seq[scala.xml.Elem]](((l: String) => {
      {
        new scala.xml.Elem(null, "p", scala.xml.Null, scala.this.Predef.$scope, ({
          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
          $buf.&+(l);
          $buf
        }: _*))
      }
    }))(collection.this.Seq.canBuildFrom[scala.xml.Elem]);
    {
      {
        var $md: scala.xml.MetaData = scala.xml.Null;
        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("block"), $md);
        new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
          $buf.&+(new scala.xml.Text("\012            "));
          $buf.&+({
            {
              new scala.xml.Elem(null, "p", scala.xml.Null, scala.this.Predef.$scope, ({
                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                $buf.&+(new scala.xml.EntityRef("gt"));
                $buf.&+(new scala.xml.Text(" "));
                $buf.&+(command);
                $buf
              }: _*))
            }
          });
          $buf.&+(new scala.xml.Text("\012            "));
          $buf.&+(lines);
          $buf.&+(new scala.xml.Text("\012        "));
          $buf
        }: _*))
      }
    }
  }
}
SearchBar: SCOM=0.087 CC=0.209 LSCC=0.048 CAMC=0.136
         runComm    Idle changeQ   clear  notify feedbac notifyA  listen  render instruc command
 queryFo                                                                                        
  submit                                                                                        
     $md                                                                                        
 HaveCom                                                                                        
 tickerF                                                                                        
 Idle$mo             X               X               X                                          
 listene     X               X       X       X               X       X                          
  status     X               X       X               X                                          
 HaveQuo                                                                                        

final class $anon extends java.lang.Object with up.~>[intform.Field,Option] {
  def this(): anonymous class $anon = {
    $anon.super.this();
    ()
  };
  def apply[T >: Nothing <: Any](field: intform.Field[T]): Option[T] = field.process()
}
$anon: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
           apply

final object OpenIDLogin extends java.lang.Object with net.liftweb.openid.SimpleOpenIDVendor with net.liftweb.common.Loggable with ScalaObject {
  def this(): object code.control.OpenIDLogin = {
    OpenIDLogin.super.this();
    ()
  };
  override def dispatchPF: net.liftweb.http.LiftRules.DispatchPF = net.liftweb.util.NamedPF.apply[net.liftweb.http.Req, () => net.liftweb.common.Box[net.liftweb.http.LiftResponse]]("Login callback")(((x0$1: net.liftweb.http.Req) => x0$1 match {
    case (req @ net.liftweb.http.Req.unapply(<unapply-selector>) <unapply> ((hd: String, tl: List[String])collection.immutable.::[String]("openid", (hd: String, tl: List[String])collection.immutable.::[String]("login", immutable.this.Nil)), "", net.liftweb.http.GetRequest)) => {
      (() => OpenIDLogin.this.sendToProvider())
    }
    case (req @ net.liftweb.http.Req.unapply(<unapply-selector>) <unapply> ((hd: String, tl: List[String])collection.immutable.::[String]("openid", immutable.this.Nil), "", _)) => {
      (() => OpenIDLogin.this.receiveFromProvider())
    }
  }));
  def sendToProvider(): net.liftweb.common.Full[net.liftweb.http.LiftResponse] = try {
    OpenIDLogin.this.redirectBackTo.apply(net.liftweb.http.S.referer.openOr[String]("/"));
    new net.liftweb.common.Full[net.liftweb.http.LiftResponse](OpenIDLogin.this.OpenIDObject.is.authRequest("https://www.google.com/accounts/o8/id", "/openid"))
  } catch {
    case (err @ _) => {
      net.liftweb.http.S.error("Open ID failed: ".+(err.getMessage()));
      OpenIDLogin.this.logger.error(err.getMessage());
      OpenIDLogin.this.logger.error(err);
      new net.liftweb.common.Full[net.liftweb.http.RedirectResponse](net.liftweb.http.RedirectResponse.apply("/"))
    }
  };
  def receiveFromProvider(): net.liftweb.common.Box[net.liftweb.http.LiftResponse] = {
    def makeResponse(req: net.liftweb.http.Req): net.liftweb.common.Full[net.liftweb.http.LiftResponse] = {
      <synthetic> private[this] val x$1: (net.liftweb.common.Box[org.openid4java.discovery.Identifier], org.openid4java.consumer.VerificationResult) = (OpenIDLogin.this.OpenIDObject.is.verifyResponse(req.request): (net.liftweb.common.Box[org.openid4java.discovery.Identifier], org.openid4java.consumer.VerificationResult) @unchecked) match {
        case (_1: net.liftweb.common.Box[org.openid4java.discovery.Identifier], _2: org.openid4java.consumer.VerificationResult)(net.liftweb.common.Box[org.openid4java.discovery.Identifier], org.openid4java.consumer.VerificationResult)((uid @ _), (verif @ _)) => new (net.liftweb.common.Box[org.openid4java.discovery.Identifier], org.openid4java.consumer.VerificationResult)(uid, verif)
      };
      val uid: net.liftweb.common.Box[org.openid4java.discovery.Identifier] = x$1._1;
      val verif: org.openid4java.consumer.VerificationResult = x$1._2;
      util.this.AnyVar.whatVarIs[code.control.OpenIDLogin.ConsumerType](OpenIDLogin.this.OpenIDObject).onComplete match {
        case (value: (net.liftweb.common.Box[org.openid4java.discovery.Identifier], net.liftweb.common.Box[org.openid4java.consumer.VerificationResult], net.liftweb.common.Box[Exception]) => net.liftweb.http.LiftResponse)net.liftweb.common.Full[(net.liftweb.common.Box[org.openid4java.discovery.Identifier], net.liftweb.common.Box[org.openid4java.consumer.VerificationResult], net.liftweb.common.Box[Exception]) => net.liftweb.http.LiftResponse]((f @ _)) => new net.liftweb.common.Full[net.liftweb.http.LiftResponse](f.apply(uid, new net.liftweb.common.Full[org.openid4java.consumer.VerificationResult](verif), net.liftweb.common.Empty))
        case _ => {
          OpenIDLogin.this.postLogin(uid, verif);
          val returnURL: String = OpenIDLogin.this.redirectBackTo.is;
          new net.liftweb.common.Full[net.liftweb.http.RedirectResponse](net.liftweb.http.RedirectResponse.apply(returnURL, (net.liftweb.http.S.responseCookies: _*)))
        }
      }
    };
    net.liftweb.http.S.request.flatMap[net.liftweb.http.LiftResponse](((req: net.liftweb.http.Req) => makeResponse(req).map[net.liftweb.http.LiftResponse](((response: net.liftweb.http.LiftResponse) => response))))
  };
  override def postLogin(uid: net.liftweb.common.Box[org.openid4java.discovery.Identifier], ver: org.openid4java.consumer.VerificationResult): Unit = uid match {
    case (value: org.openid4java.discovery.Identifier)net.liftweb.common.Full[org.openid4java.discovery.Identifier]((uid @ _)) => LoginManager.loginAsOpenID(uid.getIdentifier())
    case _ => LoginManager.logout()
  };
  final private object redirectBackTo extends net.liftweb.http.SessionVar[String] with ScalaObject {
    def this(): object code.control.OpenIDLogin.redirectBackTo = {
      redirectBackTo.super.this("/");
      ()
    }
  }
}
OpenIDLogin: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.250
         receive sendToP postLog dispatc

sealed abstract trait IsNewUser extends scala.AnyRef
IsNewUser: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

class CaseChoices extends java.lang.Object with ScalaObject {
  <paramaccessor> private[this] val radios: Seq[scala.xml.NodeSeq] = _;
  def this(radios: Seq[scala.xml.NodeSeq]): intform.CaseChoices = {
    CaseChoices.super.this();
    ()
  };
  def _1: scala.xml.NodeSeq = CaseChoices.this.radios.apply(0);
  def _2: scala.xml.NodeSeq = CaseChoices.this.radios.apply(1);
  def _3: scala.xml.NodeSeq = CaseChoices.this.radios.apply(2);
  def _4: scala.xml.NodeSeq = CaseChoices.this.radios.apply(3);
  def _5: scala.xml.NodeSeq = CaseChoices.this.radios.apply(4);
  def _6: scala.xml.NodeSeq = CaseChoices.this.radios.apply(5)
}
CaseChoices: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
              _5      _3      _1      _2      _6      _4
  radios     X       X       X       X       X       X  

final case object NoSuchComment extends java.lang.RuntimeException with errors.package.BadUser with ScalaObject with Product with Serializable {
  def this(): object SchemaErrors.this.NoSuchComment = {
    NoSuchComment.super.this();
    ()
  };
  final override def hashCode(): Int = 326698359;
  override def productPrefix: java.lang.String = "NoSuchComment";
  override def productArity: Int = 0;
  override def productElement(x$1: Int): Any = x$1 match {
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[object SchemaErrors.this.NoSuchComment]()
}
NoSuchComment: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

class DateField extends intform.TextField[org.joda.time.DateTime] with intform.DateRender with ScalaObject {
  <paramaccessor> private[this] val initText: String = _;
  def this(initText: String): intform.DateField = {
    DateField.super.this(initText);
    ()
  };
  def produce(): intform.SubmitResult[org.joda.time.DateTime] = try {
    var date: org.joda.time.DateTime = DateField.format.parseDateTime(DateField.this.text);
    val now: org.joda.time.DateTime = new org.joda.time.DateTime();
    date = date.withYear(now.year().get());
    if (date.isBefore(now))
      date = date.plusYears(1)
    else
      ();
    new intform.OK[org.joda.time.DateTime](date)
  } catch {
    case (_: IllegalArgumentException) => new intform.Error(DateField.formatSpec)
  }
}
DateField: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
         produce
 initTex        

case class Auth extends java.lang.Object with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val accessToken: org.scribe.model.Token = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def accessToken: org.scribe.model.Token = Auth.this.accessToken;
  def this(accessToken: org.scribe.model.Token): code.control.TwitterLogin.Auth = {
    Auth.super.this();
    ()
  };
  def sign: (String, String) = new (java.lang.String, java.lang.String)(Auth.this.accessToken.getToken(), Auth.this.accessToken.getSecret());
  <synthetic> def copy(accessToken: org.scribe.model.Token = accessToken): code.control.TwitterLogin.Auth = new TwitterLogin.this.Auth(accessToken);
  <synthetic> def copy$default$1: org.scribe.model.Token @scala.annotation.unchecked.uncheckedVariance = Auth.this.accessToken;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(Auth.this);
  override def toString(): String = ScalaRunTime.this._toString(Auth.this);
  override def equals(x$1: Any): Boolean = Auth.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (accessToken: org.scribe.model.Token)code.control.TwitterLogin.Auth((accessToken$1 @ _)) if accessToken$1.==(accessToken) => x$1.asInstanceOf[code.control.TwitterLogin.Auth].canEqual(Auth.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "Auth";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => accessToken
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[code.control.TwitterLogin.Auth]()
}
Auth: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
            sign
 accessT     X  

final protected object serviceInProgress extends net.liftweb.http.SessionVar[Option[org.scribe.oauth.OAuthService]] with ScalaObject {
  def this(): object code.control.TwitterLogin.serviceInProgress = {
    serviceInProgress.super.this(scala.None);
    ()
  }
}
serviceInProgress: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

case class Closed extends java.lang.Object with NewsSchema.this.Action with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val offerer: NewsSchema.this.P = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def offerer: NewsSchema.this.P = Closed.this.offerer;
  <caseaccessor> <paramaccessor> private[this] val offer: NewsSchema.this.AuctionOffer = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def offer: NewsSchema.this.AuctionOffer = Closed.this.offer;
  def this(offerer: NewsSchema.this.P, offer: NewsSchema.this.AuctionOffer): NewsSchema.this.Closed = {
    Closed.super.this();
    ()
  };
  <synthetic> def copy(offerer: NewsSchema.this.P = offerer, offer: NewsSchema.this.AuctionOffer = offer): NewsSchema.this.Closed = new NewsSchema.this.Closed(offerer, offer);
  <synthetic> def copy$default$2: NewsSchema.this.AuctionOffer @scala.annotation.unchecked.uncheckedVariance = Closed.this.offer;
  <synthetic> def copy$default$1: NewsSchema.this.P @scala.annotation.unchecked.uncheckedVariance = Closed.this.offerer;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(Closed.this);
  override def toString(): String = ScalaRunTime.this._toString(Closed.this);
  override def equals(x$1: Any): Boolean = Closed.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (offerer: NewsSchema.this.P, offer: NewsSchema.this.AuctionOffer)NewsSchema.this.Closed((offerer$1 @ _), (offer$1 @ _)) if offerer$1.==(offerer).&&(offer$1.==(offer)) => x$1.asInstanceOf[NewsSchema.this.Closed].canEqual(Closed.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "Closed";
  override def productArity: Int = 2;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => offerer
    case 1 => offer
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[NewsSchema.this.Closed]()
}
Closed: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
   offer
 offerer

case class DividendPayment extends java.lang.Object with model.KL with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val id: model.package.Key = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def id: model.package.Key = DividendPayment.this.id;
  <caseaccessor> <paramaccessor> private[this] val owner: model.Link[DividendSchema.this.Portfolio] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def owner: model.Link[DividendSchema.this.Portfolio] = DividendPayment.this.owner;
  <caseaccessor> <paramaccessor> private[this] val ticker: String = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def ticker: String = DividendPayment.this.ticker;
  <caseaccessor> <paramaccessor> private[this] val dollars: model.Dollars = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def dollars: model.Dollars = DividendPayment.this.dollars;
  <caseaccessor> <paramaccessor> private[this] val date: org.joda.time.DateTime = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def date: org.joda.time.DateTime = DividendPayment.this.date;
  def this(id: model.package.Key = model.this.`package`.nextID, owner: model.Link[DividendSchema.this.Portfolio], ticker: String, dollars: model.Dollars, date: org.joda.time.DateTime): DividendSchema.this.DividendPayment = {
    DividendPayment.super.this();
    ()
  };
  <synthetic> def copy(id: model.package.Key = id, owner: model.Link[DividendSchema.this.Portfolio] = owner, ticker: String = ticker, dollars: model.Dollars = dollars, date: org.joda.time.DateTime = date): DividendSchema.this.DividendPayment = new DividendSchema.this.DividendPayment(id, owner, ticker, dollars, date);
  <synthetic> def copy$default$5: org.joda.time.DateTime @scala.annotation.unchecked.uncheckedVariance = DividendPayment.this.date;
  <synthetic> def copy$default$4: model.Dollars @scala.annotation.unchecked.uncheckedVariance = DividendPayment.this.dollars;
  <synthetic> def copy$default$3: String @scala.annotation.unchecked.uncheckedVariance = DividendPayment.this.ticker;
  <synthetic> def copy$default$2: model.Link[DividendSchema.this.Portfolio] @scala.annotation.unchecked.uncheckedVariance = DividendPayment.this.owner;
  <synthetic> def copy$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = DividendPayment.this.id;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(DividendPayment.this);
  override def toString(): String = ScalaRunTime.this._toString(DividendPayment.this);
  override def equals(x$1: Any): Boolean = DividendPayment.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (id: model.package.Key, owner: model.Link[DividendSchema.this.Portfolio], ticker: String, dollars: model.Dollars, date: org.joda.time.DateTime)DividendSchema.this.DividendPayment((id$1 @ _), (owner$1 @ _), (ticker$1 @ _), (dollars$1 @ _), (date$1 @ _)) if id$1.==(id).&&(owner$1.==(owner)).&&(ticker$1.==(ticker)).&&(dollars$1.==(dollars)).&&(date$1.==(date)) => x$1.asInstanceOf[DividendSchema.this.DividendPayment].canEqual(DividendPayment.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "DividendPayment";
  override def productArity: Int = 5;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => id
    case 1 => owner
    case 2 => ticker
    case 3 => dollars
    case 4 => date
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[DividendSchema.this.DividendPayment]()
}
DividendPayment: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
    date
   owner
      id
 dollars
  ticker

final object voteControls extends java.lang.Object with ScalaObject {
  def this(): object code.snippet.voteControls = {
    voteControls.super.this();
    ()
  };
  def apply(ref: intform.Refreshable, ev: model.schema.NewsEvent): scala.xml.NodeSeq = ev.asVotable match {
    case (x: (model.schema.DerivativeBuyerSetAside, model.schema.DerivativeSellerSetAside))Some[(model.schema.DerivativeBuyerSetAside, model.schema.DerivativeSellerSetAside)]((_1: model.schema.DerivativeBuyerSetAside, _2: model.schema.DerivativeSellerSetAside)(model.schema.DerivativeBuyerSetAside, model.schema.DerivativeSellerSetAside)((buyerAside @ _), (sellerAside @ _))) => voteControls.this.controls(ref, ev, buyerAside, sellerAside)
    case _ => xml.this.NodeSeq.seqToNodeSeq(immutable.this.Nil)
  };
  def controls(ref: intform.Refreshable, ev: model.schema.NewsEvent, buyerAside: model.schema.DerivativeBuyerSetAside, sellerAside: model.schema.DerivativeSellerSetAside): scala.xml.Elem = {
    val up: scala.xml.NodeSeq = intform.FormSubmit.rendered("Up")({
      try {
        control.PortfolioSwitcher.currentPortfolio.userVoteUp(ev, buyerAside)
      } catch {
        case control.LoginManager.NotLoggedIn => throw new intform.BadInput("You must be logged in to vote")
      };
      ref.refresh()
    });
    val down: scala.xml.NodeSeq = intform.FormSubmit.rendered("Down")({
      try {
        control.PortfolioSwitcher.currentPortfolio.userVoteDown(ev, sellerAside)
      } catch {
        case control.LoginManager.NotLoggedIn => throw new intform.BadInput("You must be logged in to vote")
      };
      ref.refresh()
    });
    {
      {
        new scala.xml.Elem(null, "span", scala.xml.Null, scala.this.Predef.$scope, ({
          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
          $buf.&+(new scala.xml.Text("\012        "));
          $buf.&+(up);
          $buf.&+(new scala.xml.Text(" ("));
          $buf.&+(voteControls.this.priceSpec(buyerAside.price.unary_$minus.*(buyerAside.remaining)));
          $buf.&+(new scala.xml.Text(")\012        "));
          $buf.&+(down);
          $buf.&+(new scala.xml.Text(" ("));
          $buf.&+(voteControls.this.priceSpec(sellerAside.price.*(sellerAside.remaining)));
          $buf.&+(new scala.xml.Text(")\012    "));
          $buf
        }: _*))
      }
    }
  };
  def priceSpec(price: model.Dollars): scala.xml.Elem = if (price.<(new model.Dollars(math.this.BigDecimal.int2bigDecimal(0))))
    {
      {
        new scala.xml.Elem(null, "span", scala.xml.Null, scala.this.Predef.$scope, ({
          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
          $buf.&+(new scala.xml.Text("pay "));
          $buf.&+(price.unary_$minus.$);
          $buf
        }: _*))
      }
    }
  else
    {
      {
        new scala.xml.Elem(null, "span", scala.xml.Null, scala.this.Predef.$scope, ({
          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
          $buf.&+(new scala.xml.Text("receive "));
          $buf.&+(price.$);
          $buf
        }: _*))
      }
    }
}
voteControls: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.467
         priceSp   apply control

final class $anon extends java.lang.Object with up.~>[Option,up.~>.Id] {
  def this(): anonymous class $anon = {
    $anon.super.this();
    ()
  };
  def apply[T >: Nothing <: Any](o: Option[T]): T = o match {
    case (x: T)Some[T]((t @ _)) => t
    case _ => throw new java.this.lang.IllegalStateException("Owen doesn\'t know how to use types!")
  }
}
$anon: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
           apply

abstract trait SchemaErrors extends java.lang.Object with ScalaObject {
  def /*SchemaErrors*/$init$(): Unit = {
    ()
  };
  final case object NegativeVolume extends java.lang.RuntimeException with errors.package.BadUser with ScalaObject with Product with Serializable {
    def this(): object SchemaErrors.this.NegativeVolume = {
      NegativeVolume.super.this();
      ()
    };
    final override def hashCode(): Int = 1232007119;
    override def productPrefix: java.lang.String = "NegativeVolume";
    override def productArity: Int = 0;
    override def productElement(x$1: Int): Any = x$1 match {
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[object SchemaErrors.this.NegativeVolume]()
  };
  @volatile <synthetic> private[this] var NegativeVolume$module: object SchemaErrors.this.NegativeVolume = _;
  final case <stable> def NegativeVolume: object SchemaErrors.this.NegativeVolume = new object SchemaErrors.this.NegativeVolume();
  case class NotEnoughCash extends java.lang.RuntimeException with errors.package.BadUser with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val have: model.Dollars = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def have: model.Dollars = NotEnoughCash.this.have;
    <caseaccessor> <paramaccessor> private[this] val need: model.Dollars = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def need: model.Dollars = NotEnoughCash.this.need;
    def this(have: model.Dollars, need: model.Dollars): SchemaErrors.this.NotEnoughCash = {
      NotEnoughCash.super.this();
      ()
    };
    <synthetic> def copy(have: model.Dollars = have, need: model.Dollars = need): SchemaErrors.this.NotEnoughCash = new SchemaErrors.this.NotEnoughCash(have, need);
    <synthetic> def copy$default$2: model.Dollars @scala.annotation.unchecked.uncheckedVariance = NotEnoughCash.this.need;
    <synthetic> def copy$default$1: model.Dollars @scala.annotation.unchecked.uncheckedVariance = NotEnoughCash.this.have;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(NotEnoughCash.this);
    override def equals(x$1: Any): Boolean = NotEnoughCash.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (have: model.Dollars, need: model.Dollars)SchemaErrors.this.NotEnoughCash((have$1 @ _), (need$1 @ _)) if have$1.==(have).&&(need$1.==(need)) => x$1.asInstanceOf[SchemaErrors.this.NotEnoughCash].canEqual(NotEnoughCash.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "NotEnoughCash";
    override def productArity: Int = 2;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => have
      case 1 => need
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[SchemaErrors.this.NotEnoughCash]()
  };
  final <synthetic> object NotEnoughCash extends scala.runtime.AbstractFunction2[model.Dollars,model.Dollars,SchemaErrors.this.NotEnoughCash] with ScalaObject with Serializable {
    def this(): object SchemaErrors.this.NotEnoughCash = {
      NotEnoughCash.super.this();
      ()
    };
    final override def toString(): java.lang.String = "NotEnoughCash";
    case <synthetic> def unapply(x$0: SchemaErrors.this.NotEnoughCash): Option[(model.Dollars, model.Dollars)] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(model.Dollars, model.Dollars)](new (model.Dollars, model.Dollars)(x$0.have, x$0.need));
    case <synthetic> def apply(have: model.Dollars, need: model.Dollars): SchemaErrors.this.NotEnoughCash = new SchemaErrors.this.NotEnoughCash(have, need)
  };
  @volatile <synthetic> private[this] var NotEnoughCash$module: object SchemaErrors.this.NotEnoughCash = _;
  final <synthetic> <stable> def NotEnoughCash: object SchemaErrors.this.NotEnoughCash = new object SchemaErrors.this.NotEnoughCash();
  case class DontOwnStock extends java.lang.RuntimeException with errors.package.BadUser with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val ticker: String = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def ticker: String = DontOwnStock.this.ticker;
    def this(ticker: String): SchemaErrors.this.DontOwnStock = {
      DontOwnStock.super.this();
      ()
    };
    <synthetic> def copy(ticker: String = ticker): SchemaErrors.this.DontOwnStock = new SchemaErrors.this.DontOwnStock(ticker);
    <synthetic> def copy$default$1: String @scala.annotation.unchecked.uncheckedVariance = DontOwnStock.this.ticker;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(DontOwnStock.this);
    override def equals(x$1: Any): Boolean = DontOwnStock.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (ticker: String)SchemaErrors.this.DontOwnStock((ticker$1 @ _)) if ticker$1.==(ticker) => x$1.asInstanceOf[SchemaErrors.this.DontOwnStock].canEqual(DontOwnStock.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "DontOwnStock";
    override def productArity: Int = 1;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => ticker
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[SchemaErrors.this.DontOwnStock]()
  };
  final <synthetic> object DontOwnStock extends scala.runtime.AbstractFunction1[String,SchemaErrors.this.DontOwnStock] with ScalaObject with Serializable {
    def this(): object SchemaErrors.this.DontOwnStock = {
      DontOwnStock.super.this();
      ()
    };
    final override def toString(): java.lang.String = "DontOwnStock";
    case <synthetic> def unapply(x$0: SchemaErrors.this.DontOwnStock): Option[String] = if (x$0.==(null))
      scala.this.None
    else
      new Some[String](x$0.ticker);
    case <synthetic> def apply(ticker: String): SchemaErrors.this.DontOwnStock = new SchemaErrors.this.DontOwnStock(ticker)
  };
  @volatile <synthetic> private[this] var DontOwnStock$module: object SchemaErrors.this.DontOwnStock = _;
  final <synthetic> <stable> def DontOwnStock: object SchemaErrors.this.DontOwnStock = new object SchemaErrors.this.DontOwnStock();
  case class NotEnoughShares extends java.lang.RuntimeException with errors.package.BadUser with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val have: model.Shares = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def have: model.Shares = NotEnoughShares.this.have;
    <caseaccessor> <paramaccessor> private[this] val need: model.Shares = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def need: model.Shares = NotEnoughShares.this.need;
    def this(have: model.Shares, need: model.Shares): SchemaErrors.this.NotEnoughShares = {
      NotEnoughShares.super.this();
      ()
    };
    <synthetic> def copy(have: model.Shares = have, need: model.Shares = need): SchemaErrors.this.NotEnoughShares = new SchemaErrors.this.NotEnoughShares(have, need);
    <synthetic> def copy$default$2: model.Shares @scala.annotation.unchecked.uncheckedVariance = NotEnoughShares.this.need;
    <synthetic> def copy$default$1: model.Shares @scala.annotation.unchecked.uncheckedVariance = NotEnoughShares.this.have;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(NotEnoughShares.this);
    override def equals(x$1: Any): Boolean = NotEnoughShares.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (have: model.Shares, need: model.Shares)SchemaErrors.this.NotEnoughShares((have$2 @ _), (need$2 @ _)) if have$2.==(have).&&(need$2.==(need)) => x$1.asInstanceOf[SchemaErrors.this.NotEnoughShares].canEqual(NotEnoughShares.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "NotEnoughShares";
    override def productArity: Int = 2;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => have
      case 1 => need
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[SchemaErrors.this.NotEnoughShares]()
  };
  final <synthetic> object NotEnoughShares extends scala.runtime.AbstractFunction2[model.Shares,model.Shares,SchemaErrors.this.NotEnoughShares] with ScalaObject with Serializable {
    def this(): object SchemaErrors.this.NotEnoughShares = {
      NotEnoughShares.super.this();
      ()
    };
    final override def toString(): java.lang.String = "NotEnoughShares";
    case <synthetic> def unapply(x$0: SchemaErrors.this.NotEnoughShares): Option[(model.Shares, model.Shares)] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(model.Shares, model.Shares)](new (model.Shares, model.Shares)(x$0.have, x$0.need));
    case <synthetic> def apply(have: model.Shares, need: model.Shares): SchemaErrors.this.NotEnoughShares = new SchemaErrors.this.NotEnoughShares(have, need)
  };
  @volatile <synthetic> private[this] var NotEnoughShares$module: object SchemaErrors.this.NotEnoughShares = _;
  final <synthetic> <stable> def NotEnoughShares: object SchemaErrors.this.NotEnoughShares = new object SchemaErrors.this.NotEnoughShares();
  final case object NoSuchOffer extends java.lang.RuntimeException with errors.package.BadUser with ScalaObject with Product with Serializable {
    def this(): object SchemaErrors.this.NoSuchOffer = {
      NoSuchOffer.super.this();
      ()
    };
    final override def hashCode(): Int = 11147124;
    override def productPrefix: java.lang.String = "NoSuchOffer";
    override def productArity: Int = 0;
    override def productElement(x$1: Int): Any = x$1 match {
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[object SchemaErrors.this.NoSuchOffer]()
  };
  @volatile <synthetic> private[this] var NoSuchOffer$module: object SchemaErrors.this.NoSuchOffer = _;
  final case <stable> def NoSuchOffer: object SchemaErrors.this.NoSuchOffer = new object SchemaErrors.this.NoSuchOffer();
  final case object NotExecutable extends java.lang.RuntimeException with errors.package.BadUser with ScalaObject with Product with Serializable {
    def this(): object SchemaErrors.this.NotExecutable = {
      NotExecutable.super.this();
      ()
    };
    final override def hashCode(): Int = 277483357;
    override def productPrefix: java.lang.String = "NotExecutable";
    override def productArity: Int = 0;
    override def productElement(x$1: Int): Any = x$1 match {
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[object SchemaErrors.this.NotExecutable]()
  };
  @volatile <synthetic> private[this] var NotExecutable$module: object SchemaErrors.this.NotExecutable = _;
  final case <stable> def NotExecutable: object SchemaErrors.this.NotExecutable = new object SchemaErrors.this.NotExecutable();
  final case object NoSuchAuction extends java.lang.RuntimeException with errors.package.BadUser with ScalaObject with Product with Serializable {
    def this(): object SchemaErrors.this.NoSuchAuction = {
      NoSuchAuction.super.this();
      ()
    };
    final override def hashCode(): Int = -1285556901;
    override def productPrefix: java.lang.String = "NoSuchAuction";
    override def productArity: Int = 0;
    override def productElement(x$1: Int): Any = x$1 match {
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[object SchemaErrors.this.NoSuchAuction]()
  };
  @volatile <synthetic> private[this] var NoSuchAuction$module: object SchemaErrors.this.NoSuchAuction = _;
  final case <stable> def NoSuchAuction: object SchemaErrors.this.NoSuchAuction = new object SchemaErrors.this.NoSuchAuction();
  case class BidTooSmall extends java.lang.RuntimeException with errors.package.BadUser with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val going: model.Dollars = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def going: model.Dollars = BidTooSmall.this.going;
    def this(going: model.Dollars): SchemaErrors.this.BidTooSmall = {
      BidTooSmall.super.this();
      ()
    };
    <synthetic> def copy(going: model.Dollars = going): SchemaErrors.this.BidTooSmall = new SchemaErrors.this.BidTooSmall(going);
    <synthetic> def copy$default$1: model.Dollars @scala.annotation.unchecked.uncheckedVariance = BidTooSmall.this.going;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(BidTooSmall.this);
    override def equals(x$1: Any): Boolean = BidTooSmall.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (going: model.Dollars)SchemaErrors.this.BidTooSmall((going$1 @ _)) if going$1.==(going) => x$1.asInstanceOf[SchemaErrors.this.BidTooSmall].canEqual(BidTooSmall.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "BidTooSmall";
    override def productArity: Int = 1;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => going
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[SchemaErrors.this.BidTooSmall]()
  };
  final <synthetic> object BidTooSmall extends scala.runtime.AbstractFunction1[model.Dollars,SchemaErrors.this.BidTooSmall] with ScalaObject with Serializable {
    def this(): object SchemaErrors.this.BidTooSmall = {
      BidTooSmall.super.this();
      ()
    };
    final override def toString(): java.lang.String = "BidTooSmall";
    case <synthetic> def unapply(x$0: SchemaErrors.this.BidTooSmall): Option[model.Dollars] = if (x$0.==(null))
      scala.this.None
    else
      new Some[model.Dollars](x$0.going);
    case <synthetic> def apply(going: model.Dollars): SchemaErrors.this.BidTooSmall = new SchemaErrors.this.BidTooSmall(going)
  };
  @volatile <synthetic> private[this] var BidTooSmall$module: object SchemaErrors.this.BidTooSmall = _;
  final <synthetic> <stable> def BidTooSmall: object SchemaErrors.this.BidTooSmall = new object SchemaErrors.this.BidTooSmall();
  final case object NoSuchUser extends java.lang.RuntimeException with errors.package.BadUser with ScalaObject with Product with Serializable {
    def this(): object SchemaErrors.this.NoSuchUser = {
      NoSuchUser.super.this();
      ()
    };
    final override def hashCode(): Int = 1108929459;
    override def productPrefix: java.lang.String = "NoSuchUser";
    override def productArity: Int = 0;
    override def productElement(x$1: Int): Any = x$1 match {
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[object SchemaErrors.this.NoSuchUser]()
  };
  @volatile <synthetic> private[this] var NoSuchUser$module: object SchemaErrors.this.NoSuchUser = _;
  final case <stable> def NoSuchUser: object SchemaErrors.this.NoSuchUser = new object SchemaErrors.this.NoSuchUser();
  final case object NoSuchPortfolio extends java.lang.RuntimeException with errors.package.BadUser with ScalaObject with Product with Serializable {
    def this(): object SchemaErrors.this.NoSuchPortfolio = {
      NoSuchPortfolio.super.this();
      ()
    };
    final override def hashCode(): Int = -1253656992;
    override def productPrefix: java.lang.String = "NoSuchPortfolio";
    override def productArity: Int = 0;
    override def productElement(x$1: Int): Any = x$1 match {
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[object SchemaErrors.this.NoSuchPortfolio]()
  };
  @volatile <synthetic> private[this] var NoSuchPortfolio$module: object SchemaErrors.this.NoSuchPortfolio = _;
  final case <stable> def NoSuchPortfolio: object SchemaErrors.this.NoSuchPortfolio = new object SchemaErrors.this.NoSuchPortfolio();
  final case object NoSuchDerivativeAsset extends java.lang.RuntimeException with errors.package.BadUser with ScalaObject with Product with Serializable {
    def this(): object SchemaErrors.this.NoSuchDerivativeAsset = {
      NoSuchDerivativeAsset.super.this();
      ()
    };
    final override def hashCode(): Int = 109116609;
    override def productPrefix: java.lang.String = "NoSuchDerivativeAsset";
    override def productArity: Int = 0;
    override def productElement(x$1: Int): Any = x$1 match {
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[object SchemaErrors.this.NoSuchDerivativeAsset]()
  };
  @volatile <synthetic> private[this] var NoSuchDerivativeAsset$module: object SchemaErrors.this.NoSuchDerivativeAsset = _;
  final case <stable> def NoSuchDerivativeAsset: object SchemaErrors.this.NoSuchDerivativeAsset = new object SchemaErrors.this.NoSuchDerivativeAsset();
  final case object NoSuchDerivativeLiability extends java.lang.RuntimeException with errors.package.BadUser with ScalaObject with Product with Serializable {
    def this(): object SchemaErrors.this.NoSuchDerivativeLiability = {
      NoSuchDerivativeLiability.super.this();
      ()
    };
    final override def hashCode(): Int = 1118876254;
    override def productPrefix: java.lang.String = "NoSuchDerivativeLiability";
    override def productArity: Int = 0;
    override def productElement(x$1: Int): Any = x$1 match {
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[object SchemaErrors.this.NoSuchDerivativeLiability]()
  };
  @volatile <synthetic> private[this] var NoSuchDerivativeLiability$module: object SchemaErrors.this.NoSuchDerivativeLiability = _;
  final case <stable> def NoSuchDerivativeLiability: object SchemaErrors.this.NoSuchDerivativeLiability = new object SchemaErrors.this.NoSuchDerivativeLiability();
  final case object NoSuchEvent extends java.lang.RuntimeException with errors.package.BadUser with ScalaObject with Product with Serializable {
    def this(): object SchemaErrors.this.NoSuchEvent = {
      NoSuchEvent.super.this();
      ()
    };
    final override def hashCode(): Int = 2387890;
    override def productPrefix: java.lang.String = "NoSuchEvent";
    override def productArity: Int = 0;
    override def productElement(x$1: Int): Any = x$1 match {
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[object SchemaErrors.this.NoSuchEvent]()
  };
  @volatile <synthetic> private[this] var NoSuchEvent$module: object SchemaErrors.this.NoSuchEvent = _;
  final case <stable> def NoSuchEvent: object SchemaErrors.this.NoSuchEvent = new object SchemaErrors.this.NoSuchEvent();
  final case object NoSuchComment extends java.lang.RuntimeException with errors.package.BadUser with ScalaObject with Product with Serializable {
    def this(): object SchemaErrors.this.NoSuchComment = {
      NoSuchComment.super.this();
      ()
    };
    final override def hashCode(): Int = 326698359;
    override def productPrefix: java.lang.String = "NoSuchComment";
    override def productArity: Int = 0;
    override def productElement(x$1: Int): Any = x$1 match {
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[object SchemaErrors.this.NoSuchComment]()
  };
  @volatile <synthetic> private[this] var NoSuchComment$module: object SchemaErrors.this.NoSuchComment = _;
  final case <stable> def NoSuchComment: object SchemaErrors.this.NoSuchComment = new object SchemaErrors.this.NoSuchComment();
  final case object NameInUse extends java.lang.RuntimeException with errors.package.BadUser with ScalaObject with Product with Serializable {
    def this(): object SchemaErrors.this.NameInUse = {
      NameInUse.super.this();
      ()
    };
    final override def hashCode(): Int = -1077639625;
    override def productPrefix: java.lang.String = "NameInUse";
    override def productArity: Int = 0;
    override def productElement(x$1: Int): Any = x$1 match {
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[object SchemaErrors.this.NameInUse]()
  };
  @volatile <synthetic> private[this] var NameInUse$module: object SchemaErrors.this.NameInUse = _;
  final case <stable> def NameInUse: object SchemaErrors.this.NameInUse = new object SchemaErrors.this.NameInUse()
}
SchemaErrors: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=1.000
         NoSuchD NoSuchE NameInU Negativ NoSuchP NoSuchO NoSuchA NoSuchU NotExec NoSuchC NoSuchD
 BidTooS                                                                                        
 NoSuchO                                                                                        
 NotEnou                                                                                        
 NoSuchU                                                                                        
 NoSuchA                                                                                        
 NotExec                                                                                        
 NameInU                                                                                        
 NoSuchE                                                                                        
 NoSuchC                                                                                        
 Negativ                                                                                        
 DontOwn                                                                                        
 NoSuchD                                                                                        
 NotEnou                                                                                        
 NoSuchD                                                                                        
 NoSuchP                                                                                        

final object IntField extends java.lang.Object with ScalaObject {
  def this(): object intform.IntField = {
    IntField.super.this();
    ()
  };
  def apply(i: String = ""): intform.IntField = new IntField(i);
  <synthetic> def apply$default$1: String @scala.annotation.unchecked.uncheckedVariance = ""
}
IntField: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
           apply

final object Scale extends java.lang.Object with ScalaObject with Serializable {
  def this(): object model.Scale = {
    Scale.super.this();
    ()
  };
  def apply(str: String): model.Scale = new model.Scale(scala.math.BigDecimal.apply(str));
  case <synthetic> def unapply(x$0: model.Scale): Option[scala.math.BigDecimal] = if (x$0.==(null))
    scala.this.None
  else
    new Some[scala.math.BigDecimal](x$0.scale);
  case <synthetic> def apply(scale: scala.math.BigDecimal): model.Scale = new model.this.Scale(scale);
  protected def readResolve(): java.lang.Object = model.this.Scale
}
Scale: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.500
           apply readRes

case class Delete[R >: Nothing <: model.KL] extends java.lang.Object with Transactions.this.EditOp with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val rec: R = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def rec: R = Delete.this.rec;
  <caseaccessor> <paramaccessor> private[this] val table: model.Table[R] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def table: model.Table[R] = Delete.this.table;
  def this(rec: R, table: model.Table[R]): Transactions.this.Delete[R] = {
    Delete.super.this();
    ()
  };
  def perform(): Unit = {
    Transactions.this.logger.info("Deleting ".+(Delete.this.rec));
    Delete.this.table.delete(Delete.this.rec)
  };
  private[this] val affectedTables: Seq[model.Table[R]] = collection.this.Seq.apply[model.Table[R]](Delete.this.table);
  <stable> <accessor> def affectedTables: Seq[model.Table[R]] = Delete.this.affectedTables;
  <synthetic> def copy[R >: Nothing <: model.KL](rec: R = rec, table: model.Table[R] = table): Transactions.this.Delete[R] = new Transactions.this.Delete[R](rec, table);
  <synthetic> def copy$default$2[R >: Nothing <: model.KL]: model.Table[R] @scala.annotation.unchecked.uncheckedVariance = Delete.this.table;
  <synthetic> def copy$default$1[R >: Nothing <: model.KL]: R @scala.annotation.unchecked.uncheckedVariance = Delete.this.rec;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(Delete.this);
  override def toString(): String = ScalaRunTime.this._toString(Delete.this);
  override def equals(x$1: Any): Boolean = Delete.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (rec: model.KL, table: model.Table[model.KL])Transactions.this.Delete[model.KL]((rec$3 @ _), (table$3 @ _)) if rec$3.==(rec).&&(table$3.==(table)) => x$1.asInstanceOf[Transactions.this.Delete[R]].canEqual(Delete.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "Delete";
  override def productArity: Int = 2;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => rec
    case 1 => table
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[Transactions.this.Delete[R]]()
}
Delete: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
         perform
   table     X  
     rec     X  

case class CompSecStock extends ComparableSecurity with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val ticker: String = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def ticker: String = CompSecStock.this.ticker;
  def this(ticker: String): model.CompSecStock = {
    CompSecStock.super.this();
    ()
  };
  def toPrice: model.Price = Stocks.stockPrice(CompSecStock.this.ticker);
  <synthetic> def copy(ticker: String = ticker): model.CompSecStock = new model.this.CompSecStock(ticker);
  <synthetic> def copy$default$1: String @scala.annotation.unchecked.uncheckedVariance = CompSecStock.this.ticker;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(CompSecStock.this);
  override def toString(): String = ScalaRunTime.this._toString(CompSecStock.this);
  override def equals(x$1: Any): Boolean = CompSecStock.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (ticker: String)model.CompSecStock((ticker$2 @ _)) if ticker$2.==(ticker) => x$1.asInstanceOf[model.CompSecStock].canEqual(CompSecStock.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "CompSecStock";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => ticker
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[model.CompSecStock]()
}
CompSecStock: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
         toPrice
  ticker     X  

abstract class StockOrder extends java.lang.Object with ScalaObject {
  def this(): code.snippet.StockOrder = {
    StockOrder.super.this();
    ()
  }
}
StockOrder: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

final class $anon extends java.lang.Object with intform.SubmitRender with intform.BasicErrors with intform.ErrorRender {
  def this(): anonymous class $anon = {
    $anon.super.this();
    ()
  };
  private[this] val value: String = text;
  <stable> <accessor> def value: String = $anon.this.value;
  def submitAjax(): net.liftweb.http.js.JsCmd = $anon.this.runWithErrors(callback).&(r.refresh())
}
$anon: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
         submitA

case class StockPurchase extends java.lang.Object with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val shares: model.Shares = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def shares: model.Shares = StockPurchase.this.shares;
  <caseaccessor> <paramaccessor> private[this] val dollars: model.Dollars = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def dollars: model.Dollars = StockPurchase.this.dollars;
  <caseaccessor> <paramaccessor> private[this] val asset: model.package.Key = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def asset: model.package.Key = StockPurchase.this.asset;
  def this(shares: model.Shares, dollars: model.Dollars, asset: model.package.Key): StockSchema.this.StockPurchase = {
    StockPurchase.super.this();
    ()
  };
  <synthetic> def copy(shares: model.Shares = shares, dollars: model.Dollars = dollars, asset: model.package.Key = asset): StockSchema.this.StockPurchase = new StockSchema.this.StockPurchase(shares, dollars, asset);
  <synthetic> def copy$default$3: model.package.Key @scala.annotation.unchecked.uncheckedVariance = StockPurchase.this.asset;
  <synthetic> def copy$default$2: model.Dollars @scala.annotation.unchecked.uncheckedVariance = StockPurchase.this.dollars;
  <synthetic> def copy$default$1: model.Shares @scala.annotation.unchecked.uncheckedVariance = StockPurchase.this.shares;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(StockPurchase.this);
  override def toString(): String = ScalaRunTime.this._toString(StockPurchase.this);
  override def equals(x$1: Any): Boolean = StockPurchase.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (shares: model.Shares, dollars: model.Dollars, asset: model.package.Key)StockSchema.this.StockPurchase((shares$2 @ _), (dollars$1 @ _), (asset$1 @ _)) if shares$2.==(shares).&&(dollars$1.==(dollars)).&&(asset$1.==(asset)) => x$1.asInstanceOf[StockSchema.this.StockPurchase].canEqual(StockPurchase.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "StockPurchase";
  override def productArity: Int = 3;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => shares
    case 1 => dollars
    case 2 => asset
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[StockSchema.this.StockPurchase]()
}
StockPurchase: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
  shares
   asset
 dollars

final case object NoSuchUser extends java.lang.RuntimeException with errors.package.BadUser with ScalaObject with Product with Serializable {
  def this(): object SchemaErrors.this.NoSuchUser = {
    NoSuchUser.super.this();
    ()
  };
  final override def hashCode(): Int = 1108929459;
  override def productPrefix: java.lang.String = "NoSuchUser";
  override def productArity: Int = 0;
  override def productElement(x$1: Int): Any = x$1 match {
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[object SchemaErrors.this.NoSuchUser]()
}
NoSuchUser: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

final object DerivativeLiability extends java.lang.Object with ScalaObject with Serializable {
  def this(): object DerivativeSchema.this.DerivativeLiability = {
    DerivativeLiability.super.this();
    ()
  };
  def byName(name: String): DerivativeSchema.this.DerivativeLiability = DerivativeSchema.this.derivativeLiabilities.filter(((x$1: DerivativeSchema.this.DerivativeLiability) => x$1.name.==(name))).headOption.getOrElse[DerivativeSchema.this.DerivativeLiability](throw DerivativeSchema.this.NoSuchDerivativeLiability);
  <synthetic> def init$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
  <synthetic> def apply$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
  case <synthetic> def unapply(x$0: DerivativeSchema.this.DerivativeLiability): Option[(model.package.Key, String, model.Derivative, model.Scale, org.joda.time.DateTime, model.Link[DerivativeSchema.this.Portfolio], Boolean)] = if (x$0.==(null))
    scala.this.None
  else
    new Some[(model.package.Key, String, model.Derivative, model.Scale, org.joda.time.DateTime, model.Link[DerivativeSchema.this.Portfolio], Boolean)](new (model.package.Key, String, model.Derivative, model.Scale, org.joda.time.DateTime, model.Link[DerivativeSchema.this.Portfolio], Boolean)(x$0.id, x$0.name, x$0.derivative, x$0.remaining, x$0.exec, x$0.owner, x$0.hidden));
  case <synthetic> def apply(id: model.package.Key = model.this.`package`.nextID, name: String, derivative: model.Derivative, remaining: model.Scale, exec: org.joda.time.DateTime, owner: model.Link[DerivativeSchema.this.Portfolio], hidden: Boolean): DerivativeSchema.this.DerivativeLiability = new DerivativeSchema.this.DerivativeLiability(id, name, derivative, remaining, exec, owner, hidden)
}
DerivativeLiability: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
          byName

case class BuyShares extends StockOrder with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val quote: stockdata.Quote = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def quote: stockdata.Quote = BuyShares.this.quote;
  <caseaccessor> <paramaccessor> private[this] val dollars: model.Dollars = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def dollars: model.Dollars = BuyShares.this.dollars;
  def this(quote: stockdata.Quote, dollars: model.Dollars): code.snippet.BuyShares = {
    BuyShares.super.this();
    ()
  };
  <synthetic> def copy(quote: stockdata.Quote = quote, dollars: model.Dollars = dollars): code.snippet.BuyShares = new snippet.this.BuyShares(quote, dollars);
  <synthetic> def copy$default$2: model.Dollars @scala.annotation.unchecked.uncheckedVariance = BuyShares.this.dollars;
  <synthetic> def copy$default$1: stockdata.Quote @scala.annotation.unchecked.uncheckedVariance = BuyShares.this.quote;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(BuyShares.this);
  override def toString(): String = ScalaRunTime.this._toString(BuyShares.this);
  override def equals(x$1: Any): Boolean = BuyShares.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (quote: stockdata.Quote, dollars: model.Dollars)code.snippet.BuyShares((quote$1 @ _), (dollars$1 @ _)) if quote$1.==(quote).&&(dollars$1.==(dollars)) => x$1.asInstanceOf[code.snippet.BuyShares].canEqual(BuyShares.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "BuyShares";
  override def productArity: Int = 2;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => quote
    case 1 => dollars
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[code.snippet.BuyShares]()
}
BuyShares: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
 dollars
   quote

final object User extends java.lang.Object with ScalaObject with Serializable {
  def this(): object UserSchema.this.User = {
    User.super.this();
    ()
  };
  def byName(name: String): UserSchema.this.User = {
    val u: Option[UserSchema.this.User] = UserSchema.this.users.filter(((x$8: UserSchema.this.User) => x$8.username.==(name))).headOption;
    u.getOrElse[UserSchema.this.User](throw UserSchema.this.NoSuchUser)
  };
  def userEnsure(name: String): UserSchema.this.User = UserSchema.this.editDB[UserSchema.this.User](User.this.ensure(name));
  def isNew(name: String): Product with Serializable = UserSchema.this.editDB[Product with Serializable](try {
    UserSchema.this.Transaction.apply[UserSchema.this.OldUser](new UserSchema.this.OldUser(User.this.byName(name)))
  } catch {
    case UserSchema.this.NoSuchUser => User.this.ensure(name).map[UserSchema.this.NewUser](((x$9: UserSchema.this.User) => new UserSchema.this.NewUser(x$9)))
  });
  private[model] def ensure(name: String): UserSchema.this.Transaction[UserSchema.this.User] = UserSchema.this.toOrCreate[UserSchema.this.User](User.this.byName(name)).orCreate(User.this.newUser(name));
  private[model] def ensureP(name: String): UserSchema.this.Transaction[UserSchema.this.Portfolio] = {
    def port: UserSchema.this.Portfolio = model.this.Link.extract[UserSchema.this.Portfolio](User.this.byName(name).lastPortfolio)(UserSchema.this.portfolios);
    UserSchema.this.toOrCreate[UserSchema.this.Portfolio](port).orCreate(User.this.newUserP(name))
  };
  private[model] def newUserAll(name: String): UserSchema.this.Transaction[(UserSchema.this.User, UserSchema.this.Portfolio)] = {
    val league: UserSchema.this.League = UserSchema.this.League.default();
    val cash: model.Dollars = league.startingCash;
    UserSchema.this.toOps[UserSchema.this.Portfolio]({
  val x$39: String = name;
  val x$40: model.Link[UserSchema.this.League] = model.this.KL.toLink[UserSchema.this.League](UserSchema.this.League.default());
  val x$41: model.Dollars = cash;
  val x$42: model.Dollars = cash;
  val x$43: Int(0) = 0;
  val x$44: model.package.Key = UserSchema.this.Portfolio.apply$default$1;
  new UserSchema.this.Portfolio(x$44, x$40, x$39, x$41, x$42, 0)
}).insert(UserSchema.this.portfolios).flatMap[(UserSchema.this.User, UserSchema.this.Portfolio)](((port: UserSchema.this.Portfolio) => UserSchema.this.toOps[UserSchema.this.User]({
  val x$45: String = name;
  val x$46: model.Link[UserSchema.this.Portfolio] = model.this.KL.toLink[UserSchema.this.Portfolio](port);
  val x$47: model.package.Key = UserSchema.this.User.apply$default$1;
  new UserSchema.this.User(x$47, x$45, x$46)
}).insert(UserSchema.this.users).flatMap[(UserSchema.this.User, UserSchema.this.Portfolio)](((user: UserSchema.this.User) => UserSchema.this.toOps[UserSchema.this.Ownership]({
  val x$48: UserSchema.this.User = user;
  val x$49: UserSchema.this.Portfolio = port;
  val x$50: model.package.Key = UserSchema.this.Ownership.apply$default$1;
  new UserSchema.this.Ownership(x$50, x$48, x$49)
}).insert(UserSchema.this.ownerships).map[(UserSchema.this.User, UserSchema.this.Portfolio)](((_: UserSchema.this.Ownership) => new (UserSchema.this.User, UserSchema.this.Portfolio)(user, port)))))))
  };
  private[model] def newUser(name: String): UserSchema.this.Transaction[UserSchema.this.User] = User.this.newUserAll(name).map[UserSchema.this.User](((x$10: (UserSchema.this.User, UserSchema.this.Portfolio)) => x$10._1));
  private[model] def newUserP(name: String): UserSchema.this.Transaction[UserSchema.this.Portfolio] = User.this.newUserAll(name).map[UserSchema.this.Portfolio](((x$11: (UserSchema.this.User, UserSchema.this.Portfolio)) => x$11._2));
  <synthetic> def apply$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
  <synthetic> def init$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
  case <synthetic> def unapply(x$0: UserSchema.this.User): Option[(model.package.Key, String, model.Link[UserSchema.this.Portfolio])] = if (x$0.==(null))
    scala.this.None
  else
    new Some[(model.package.Key, String, model.Link[UserSchema.this.Portfolio])](new (model.package.Key, String, model.Link[UserSchema.this.Portfolio])(x$0.id, x$0.username, x$0.lastPortfolio));
  case <synthetic> def apply(id: model.package.Key = model.this.`package`.nextID, username: String, lastPortfolio: model.Link[UserSchema.this.Portfolio]): UserSchema.this.User = new UserSchema.this.User(id, username, lastPortfolio)
}
User: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=1.000
         newUser   isNew ensureP  byName newUser newUser userEns  ensure

final object SellThisStock extends java.lang.Object with ScalaObject {
  def this(): object code.snippet.SellThisStock = {
    SellThisStock.super.this();
    ()
  };
  def apply(t: String): scala.xml.NodeSeq = new SellThisStock(t).render
}
SellThisStock: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
           apply

class DollarsField extends intform.TextField[model.Dollars] with ScalaObject {
  <paramaccessor> private[this] val initText: String = _;
  def this(initText: String): code.snippet.DollarsField = {
    DollarsField.super.this(initText);
    ()
  };
  def produce(): intform.SubmitResult[model.Dollars] = try {
    new intform.OK[model.Dollars](model.Dollars.apply(DollarsField.this.text))
  } catch {
    case (_: NumberFormatException) => new intform.Error("Must be a dollar amount")
  }
}
DollarsField: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
         produce
 initTex        

class AggregateField[A >: Nothing <: Any, F >: Nothing <: up.HList] extends intform.Field[A] with intform.AggregateRender with ScalaObject {
  <paramaccessor> private[this] val constructor: F => A = _;
  <paramaccessor> private[this] val fields: up.KList[intform.Field,F] = _;
  <paramaccessor> private[this] val renderer: () => scala.xml.NodeSeq = _;
  <stable> <accessor> <paramaccessor> def renderer: () => scala.xml.NodeSeq = AggregateField.this.renderer;
  def this(constructor: F => A, fields: up.KList[intform.Field,F], renderer: () => scala.xml.NodeSeq): intform.AggregateField[A,F] = {
    AggregateField.super.this();
    ()
  };
  def produce(): intform.SubmitResult[A] = {
    val inners: up.KList[Option,F] = AggregateField.this.fields.map[Option](AggregateField.mapProcess);
    if (inners.toList.forall(((x$1: Option[_]) => x$1.isDefined)))
      new intform.OK[A](AggregateField.this.constructor.apply(inners.down(AggregateField.mapExtract)))
    else
      ChildError
  };
  def reset(): Unit = {
    AggregateField.this.fields.toList.map[Unit, Any](((x$2: intform.Field[_]) => x$2.reset()))(immutable.this.List.canBuildFrom[Unit]);
    ()
  }
}
AggregateField: SCOM=0.667 CC=0.500 LSCC=0.333 CAMC=1.000
           reset produce
 rendere                
 constru             X  
  fields     X       X  

final case object CondAlways extends Condition with ScalaObject with Product with Serializable {
  def this(): object model.CondAlways = {
    CondAlways.super.this();
    ()
  };
  def isTrue: Boolean = true;
  final override def hashCode(): Int = -89544719;
  final override def toString(): java.lang.String = "CondAlways";
  override def productPrefix: java.lang.String = "CondAlways";
  override def productArity: Int = 0;
  override def productElement(x$1: Int): Any = x$1 match {
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[object model.CondAlways]();
  protected def readResolve(): java.lang.Object = model.this.CondAlways
}
CondAlways: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=1.000
          isTrue readRes

final case object NotFound extends java.lang.RuntimeException with errors.package.BadUser with ScalaObject with Product with Serializable {
  def this(): object model.NotFound = {
    NotFound.super.this();
    ()
  };
  final override def hashCode(): Int = 1617964175;
  override def productPrefix: java.lang.String = "NotFound";
  override def productArity: Int = 0;
  override def productElement(x$1: Int): Any = x$1 match {
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[object model.NotFound]();
  protected def readResolve(): java.lang.Object = model.this.NotFound
}
NotFound: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
         readRes

final protected object returnTo extends net.liftweb.http.SessionVar[String] with ScalaObject {
  def this(): object code.control.TwitterLogin.returnTo = {
    returnTo.super.this("/");
    ()
  }
}
returnTo: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

abstract trait CommentSchema extends java.lang.Object with ScalaObject { self: model.CommentSchema with model.NewsSchema with model.UserSchema with model.DBMagic with model.SchemaErrors => 
  def /*CommentSchema*/$init$(): Unit = {
    ()
  };
  private[this] val eventComments: model.Table[CommentSchema.this.EventComment] = CommentSchema.this.table[CommentSchema.this.EventComment];
  implicit <stable> <accessor> def eventComments: model.Table[CommentSchema.this.EventComment] = CommentSchema.this.eventComments;
  case class EventComment extends java.lang.Object with model.KL with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val id: model.package.Key = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def id: model.package.Key = EventComment.this.id;
    <caseaccessor> <paramaccessor> private[this] val event: CommentSchema.this.NewsEvent = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def event: CommentSchema.this.NewsEvent = EventComment.this.event;
    <caseaccessor> <paramaccessor> private[this] val by: CommentSchema.this.User = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def by: CommentSchema.this.User = EventComment.this.by;
    <caseaccessor> <paramaccessor> private[this] val text: String = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def text: String = EventComment.this.text;
    <caseaccessor> <paramaccessor> private[this] val when: org.joda.time.DateTime = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def when: org.joda.time.DateTime = EventComment.this.when;
    def this(id: model.package.Key = model.this.`package`.nextID, event: CommentSchema.this.NewsEvent, by: CommentSchema.this.User, text: String, when: org.joda.time.DateTime): CommentSchema.this.EventComment = {
      EventComment.super.this();
      ()
    };
    <synthetic> def copy(id: model.package.Key = id, event: CommentSchema.this.NewsEvent = event, by: CommentSchema.this.User = by, text: String = text, when: org.joda.time.DateTime = when): CommentSchema.this.EventComment = new CommentSchema.this.EventComment(id, event, by, text, when);
    <synthetic> def copy$default$5: org.joda.time.DateTime @scala.annotation.unchecked.uncheckedVariance = EventComment.this.when;
    <synthetic> def copy$default$4: String @scala.annotation.unchecked.uncheckedVariance = EventComment.this.text;
    <synthetic> def copy$default$3: CommentSchema.this.User @scala.annotation.unchecked.uncheckedVariance = EventComment.this.by;
    <synthetic> def copy$default$2: CommentSchema.this.NewsEvent @scala.annotation.unchecked.uncheckedVariance = EventComment.this.event;
    <synthetic> def copy$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = EventComment.this.id;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(EventComment.this);
    override def toString(): String = ScalaRunTime.this._toString(EventComment.this);
    override def equals(x$1: Any): Boolean = EventComment.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (id: model.package.Key, event: CommentSchema.this.NewsEvent, by: CommentSchema.this.User, text: String, when: org.joda.time.DateTime)CommentSchema.this.EventComment((id$1 @ _), (event$1 @ _), (by$1 @ _), (text$1 @ _), (when$1 @ _)) if id$1.==(id).&&(event$1.==(event)).&&(by$1.==(by)).&&(text$1.==(text)).&&(when$1.==(when)) => x$1.asInstanceOf[CommentSchema.this.EventComment].canEqual(EventComment.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "EventComment";
    override def productArity: Int = 5;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => id
      case 1 => event
      case 2 => by
      case 3 => text
      case 4 => when
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[CommentSchema.this.EventComment]()
  };
  final object EventComment extends java.lang.Object with ScalaObject with Serializable {
    def this(): object CommentSchema.this.EventComment = {
      EventComment.super.this();
      ()
    };
    def byID(id: model.package.Key): CommentSchema.this.EventComment = CommentSchema.this.eventComments.lookup(id).getOrElse[CommentSchema.this.EventComment](throw CommentSchema.this.NoSuchComment);
    <synthetic> def init$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID;
    case <synthetic> def unapply(x$0: CommentSchema.this.EventComment): Option[(model.package.Key, CommentSchema.this.NewsEvent, CommentSchema.this.User, String, org.joda.time.DateTime)] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(model.package.Key, CommentSchema.this.NewsEvent, CommentSchema.this.User, String, org.joda.time.DateTime)](new (model.package.Key, CommentSchema.this.NewsEvent, CommentSchema.this.User, String, org.joda.time.DateTime)(x$0.id, x$0.event, x$0.by, x$0.text, x$0.when));
    case <synthetic> def apply(id: model.package.Key = model.this.`package`.nextID, event: CommentSchema.this.NewsEvent, by: CommentSchema.this.User, text: String, when: org.joda.time.DateTime): CommentSchema.this.EventComment = new CommentSchema.this.EventComment(id, event, by, text, when);
    <synthetic> def apply$default$1: model.package.Key @scala.annotation.unchecked.uncheckedVariance = model.this.`package`.nextID
  };
  @volatile <synthetic> private[this] var EventComment$module: object CommentSchema.this.EventComment = _;
  final <stable> def EventComment: object CommentSchema.this.EventComment = new object CommentSchema.this.EventComment();
  abstract trait UserWithComments extends java.lang.Object with ScalaObject { self: CommentSchema.this.User => 
    def /*UserWithComments*/$init$(): Unit = {
      ()
    };
    def userPostComment(event: CommentSchema.this.NewsEvent, text: String): CommentSchema.this.EventComment = CommentSchema.this.editDB[CommentSchema.this.EventComment](UserWithComments.this.postComment(event, text));
    private[model] def postComment(event: CommentSchema.this.NewsEvent, text: String): CommentSchema.this.Transaction[CommentSchema.this.EventComment] = CommentSchema.this.toOps[CommentSchema.this.EventComment]({
  val x$2: CommentSchema.this.NewsEvent = event;
  val x$3: CommentSchema.this.User = this;
  val x$4: String = text;
  val x$5: org.joda.time.DateTime = new org.joda.time.DateTime();
  val x$6: model.package.Key = CommentSchema.this.EventComment.apply$default$1;
  new CommentSchema.this.EventComment(x$6, x$2, x$3, x$4, x$5)
}).insert(CommentSchema.this.eventComments)
  };
  abstract trait NewsEventWithComments extends java.lang.Object with ScalaObject { self: CommentSchema.this.NewsEvent => 
    def /*NewsEventWithComments*/$init$(): Unit = {
      ()
    };
    def comments: scala.collection.mutable.ArrayBuffer[CommentSchema.this.EventComment] = CommentSchema.this.eventComments.filter(((x$1: CommentSchema.this.EventComment) => x$1.event.~~(this)));
    def numComments: Int = NewsEventWithComments.this.comments.length;
    def userPostAnonymously(text: String): Unit = CommentSchema.this.editDB[Unit](CommentSchema.this.User.ensure("Anonymous").flatMap[Unit](((user: CommentSchema.this.User) => user.postComment(this, text).map[Unit](((_: CommentSchema.this.EventComment) => ())))))
  }
}
CommentSchema: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
         EventCo
 EventCo        

case class Transaction[A >: Nothing <: Any] extends java.lang.Object with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val result: A = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def result: A = Transaction.this.result;
  <caseaccessor> <paramaccessor> private[this] val ops: Seq[Transactions.this.EditOp] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def ops: Seq[Transactions.this.EditOp] = Transaction.this.ops;
  def this(result: A, ops: Seq[Transactions.this.EditOp]): Transactions.this.Transaction[A] = {
    Transaction.super.this();
    ()
  };
  def flatMap[B >: Nothing <: Any](f: A => Transactions.this.Transaction[B]): Transactions.this.Transaction[B] = {
    val next: Transactions.this.Transaction[B] = f.apply(Transaction.this.result);
    new Transactions.this.Transaction[B](next.result, Transaction.this.ops.++[Transactions.this.EditOp, Seq[Transactions.this.EditOp]](next.ops)(collection.this.Seq.canBuildFrom[Transactions.this.EditOp]))
  };
  def map[B >: Nothing <: Any](f: A => B): Transactions.this.Transaction[B] = new Transactions.this.Transaction[B](f.apply(Transaction.this.result), Transaction.this.ops);
  def filter(f: A => Boolean): Transactions.this.Transaction[A] = if (f.apply(Transaction.this.result))
    this
  else
    scala.sys.`package`.error("Match error");
  def &[B >: Nothing <: Any](tr: Transactions.this.Transaction[B]): Transactions.this.Transaction[(A, B)] = new Transactions.this.Transaction[(A, B)](new (A, B)(Transaction.this.result, tr.result), Transaction.this.ops.++[Transactions.this.EditOp, Seq[Transactions.this.EditOp]](tr.ops)(collection.this.Seq.canBuildFrom[Transactions.this.EditOp]));
  <synthetic> def copy[A >: Nothing <: Any](result: A = result, ops: Seq[Transactions.this.EditOp] = ops): Transactions.this.Transaction[A] = new Transactions.this.Transaction[A](result, ops);
  <synthetic> def copy$default$2[A >: Nothing <: Any]: Seq[Transactions.this.EditOp] @scala.annotation.unchecked.uncheckedVariance = Transaction.this.ops;
  <synthetic> def copy$default$1[A >: Nothing <: Any]: A @scala.annotation.unchecked.uncheckedVariance = Transaction.this.result;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(Transaction.this);
  override def toString(): String = ScalaRunTime.this._toString(Transaction.this);
  override def equals(x$1: Any): Boolean = Transaction.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (result: Any, ops: Seq[Transactions.this.EditOp])Transactions.this.Transaction[Any]((result$1 @ _), (ops$1 @ _)) if result$1.==(result).&&(ops$1.==(ops)) => x$1.asInstanceOf[Transactions.this.Transaction[A]].canEqual(Transaction.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "Transaction";
  override def productArity: Int = 2;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => result
    case 1 => ops
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[Transactions.this.Transaction[A]]()
}
Transaction: SCOM=1.000 CC=0.750 LSCC=0.750 CAMC=0.250
            $amp     map  filter flatMap
     ops     X       X               X  
  result     X       X       X       X  

abstract trait Refreshable extends java.lang.Object with net.liftweb.http.CometActor with net.liftweb.http.CometListener with net.liftweb.common.Loggable with ScalaObject {
  def /*Refreshable*/$init$(): Unit = {
    ()
  };
  override def lowPriority: PartialFunction[Any,Unit] = ((x0$1: Any) => x0$1 match {
    case model.Refresh => {
      Refreshable.this.refresh();
      Refreshable.this.reRender()
    }
  });
  def refresh(): Unit = ()
}
Refreshable: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=1.000
         refresh lowPrio

case private[this] class Entry extends java.lang.Object with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val value: V = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def value: V = Entry.this.value;
  <caseaccessor> <paramaccessor> private[this] val time: org.joda.time.DateTime = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def time: org.joda.time.DateTime = Entry.this.time;
  def this(value: V, time: org.joda.time.DateTime): CacheMap.this.Entry = {
    Entry.super.this();
    ()
  };
  <synthetic> def copy$default$2: org.joda.time.DateTime @scala.annotation.unchecked.uncheckedVariance = Entry.this.time;
  <synthetic> def copy$default$1: V @scala.annotation.unchecked.uncheckedVariance = Entry.this.value;
  <synthetic> def copy(value: V = value, time: org.joda.time.DateTime = time): CacheMap.this.Entry = new CacheMap.this.Entry(value, time);
  override def hashCode(): Int = ScalaRunTime.this._hashCode(Entry.this);
  override def toString(): String = ScalaRunTime.this._toString(Entry.this);
  override def equals(x$1: Any): Boolean = Entry.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (value: V, time: org.joda.time.DateTime)CacheMap.this.Entry((value$1 @ _), (time$1 @ _)) if value$1.==(value).&&(time$1.==(time)) => x$1.asInstanceOf[CacheMap.this.Entry].canEqual(Entry.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "Entry";
  override def productArity: Int = 2;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => value
    case 1 => time
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[CacheMap.this.Entry]()
}
Entry: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
   value
    time

class BooleanField extends intform.Field[Boolean] with intform.CheckBoxRender with ScalaObject {
  <paramaccessor> private[this] val initState: Boolean = _;
  def this(initState: Boolean): intform.BooleanField = {
    BooleanField.super.this();
    ()
  };
  private[this] var state: Boolean = BooleanField.this.initState;
  <accessor> def state: Boolean = BooleanField.this.state;
  <accessor> def state_=(x$1: Boolean): Unit = BooleanField.this.state = x$1;
  def produce(): intform.OK[Boolean] = new intform.OK[Boolean](BooleanField.this.state);
  def reset(): Unit = BooleanField.this.state_=(BooleanField.this.initState)
}
BooleanField: SCOM=1.000 CC=0.500 LSCC=0.500 CAMC=1.000
         produce   reset
 initSta             X  
   state     X       X  

final class $anon extends java.lang.Object with net.liftweb.common.Logger {
  def this(): anonymous class $anon = {
    $anon.super.this();
    ()
  };
  $anon.this.error("Error in form submission", e)
}
$anon: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        

case class DerivativeOrder extends java.lang.Object with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val recipient: code.snippet.Recipient = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def recipient: code.snippet.Recipient = DerivativeOrder.this.recipient;
  <caseaccessor> <paramaccessor> private[this] val stocks: Iterable[code.snippet.StockInDerivative] = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def stocks: Iterable[code.snippet.StockInDerivative] = DerivativeOrder.this.stocks;
  <caseaccessor> <paramaccessor> private[this] val execDate: org.joda.time.DateTime = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def execDate: org.joda.time.DateTime = DerivativeOrder.this.execDate;
  <caseaccessor> <paramaccessor> private[this] val price: model.Dollars = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def price: model.Dollars = DerivativeOrder.this.price;
  <caseaccessor> <paramaccessor> private[this] val cash: model.Dollars = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def cash: model.Dollars = DerivativeOrder.this.cash;
  <caseaccessor> <paramaccessor> private[this] val condition: model.Condition = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def condition: model.Condition = DerivativeOrder.this.condition;
  <caseaccessor> <paramaccessor> private[this] val early: Boolean = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def early: Boolean = DerivativeOrder.this.early;
  def this(recipient: code.snippet.Recipient, stocks: Iterable[code.snippet.StockInDerivative], execDate: org.joda.time.DateTime, price: model.Dollars, cash: model.Dollars, condition: model.Condition, early: Boolean): code.snippet.DerivativeOrder = {
    DerivativeOrder.super.this();
    ()
  };
  <synthetic> def copy(recipient: code.snippet.Recipient = recipient, stocks: Iterable[code.snippet.StockInDerivative] = stocks, execDate: org.joda.time.DateTime = execDate, price: model.Dollars = price, cash: model.Dollars = cash, condition: model.Condition = condition, early: Boolean = early): code.snippet.DerivativeOrder = new snippet.this.DerivativeOrder(recipient, stocks, execDate, price, cash, condition, early);
  <synthetic> def copy$default$7: Boolean @scala.annotation.unchecked.uncheckedVariance = DerivativeOrder.this.early;
  <synthetic> def copy$default$6: model.Condition @scala.annotation.unchecked.uncheckedVariance = DerivativeOrder.this.condition;
  <synthetic> def copy$default$5: model.Dollars @scala.annotation.unchecked.uncheckedVariance = DerivativeOrder.this.cash;
  <synthetic> def copy$default$4: model.Dollars @scala.annotation.unchecked.uncheckedVariance = DerivativeOrder.this.price;
  <synthetic> def copy$default$3: org.joda.time.DateTime @scala.annotation.unchecked.uncheckedVariance = DerivativeOrder.this.execDate;
  <synthetic> def copy$default$2: Iterable[code.snippet.StockInDerivative] @scala.annotation.unchecked.uncheckedVariance = DerivativeOrder.this.stocks;
  <synthetic> def copy$default$1: code.snippet.Recipient @scala.annotation.unchecked.uncheckedVariance = DerivativeOrder.this.recipient;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(DerivativeOrder.this);
  override def toString(): String = ScalaRunTime.this._toString(DerivativeOrder.this);
  override def equals(x$1: Any): Boolean = DerivativeOrder.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (recipient: code.snippet.Recipient, stocks: Iterable[code.snippet.StockInDerivative], execDate: org.joda.time.DateTime, price: model.Dollars, cash: model.Dollars, condition: model.Condition, early: Boolean)code.snippet.DerivativeOrder((recipient$1 @ _), (stocks$1 @ _), (execDate$1 @ _), (price$1 @ _), (cash$1 @ _), (condition$1 @ _), (early$1 @ _)) if recipient$1.==(recipient).&&(stocks$1.==(stocks)).&&(execDate$1.==(execDate)).&&(price$1.==(price)).&&(cash$1.==(cash)).&&(condition$1.==(condition)).&&(early$1.==(early)) => x$1.asInstanceOf[code.snippet.DerivativeOrder].canEqual(DerivativeOrder.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "DerivativeOrder";
  override def productArity: Int = 7;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => recipient
    case 1 => stocks
    case 2 => execDate
    case 3 => price
    case 4 => cash
    case 5 => condition
    case 6 => early
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[code.snippet.DerivativeOrder]()
}
DerivativeOrder: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
   price
 execDat
 conditi
    cash
 recipie
   early
  stocks

case class FormattedSecurity extends java.lang.Object with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val security: model.Security = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def security: model.Security = FormattedSecurity.this.security;
  def this(security: model.Security): formats.package.FormattedSecurity = {
    FormattedSecurity.super.this();
    ()
  };
  def toHumanString: String = FormattedSecurity.this.security match {
    case (amount: model.Dollars)model.SecDollar((amount @ _)) => amount.$
    case (ticker: String, shares: model.Shares)model.SecStock((ticker @ _), (shares @ _)) => scala.this.Predef.augmentString("%s shrs %s").format(shares.###(), ticker)
    case (name: String, scale: model.Scale)model.SecDerivative((name @ _), (scale @ _)) => scala.this.Predef.augmentString("[%s %s]").format(scale.%(), name)
  };
  <synthetic> def copy(security: model.Security = security): formats.package.FormattedSecurity = new package.this.FormattedSecurity(security);
  <synthetic> def copy$default$1: model.Security @scala.annotation.unchecked.uncheckedVariance = FormattedSecurity.this.security;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(FormattedSecurity.this);
  override def toString(): String = ScalaRunTime.this._toString(FormattedSecurity.this);
  override def equals(x$1: Any): Boolean = FormattedSecurity.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (security: model.Security)formats.package.FormattedSecurity((security$1 @ _)) if security$1.==(security) => x$1.asInstanceOf[formats.package.FormattedSecurity].canEqual(FormattedSecurity.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "FormattedSecurity";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => security
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[formats.package.FormattedSecurity]()
}
FormattedSecurity: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
         toHuman
 securit     X  

abstract trait DependentListRender extends java.lang.Object with intform.FieldRender with ScalaObject {
  def /*DependentListRender*/$init$(): Unit = {
    ()
  };
  <stable> <accessor> def renderer: () => scala.xml.NodeSeq;
  def main: scala.xml.NodeSeq = DependentListRender.this.renderer.apply()
}
DependentListRender: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
            main
 rendere     X  

final object parser extends java.lang.Object with scala.util.parsing.combinator.JavaTokenParsers with ScalaObject {
  def this(): object texttrading.parser = {
    parser.super.this();
    ()
  };
  def parseAction(text: String): texttrading.parser.ParseResult[Product with Serializable with texttrading.Action] = parser.this.action.apply(parser.this.toCSR(text));
  lazy private[this] var action: texttrading.parser.Parser[Product with Serializable with texttrading.Action] = _;
  <stable> <accessor> lazy def action: texttrading.parser.Parser[Product with Serializable with texttrading.Action] = {
    parser.this.action = parser.this.opt[String](parser.this.regex(parser.this.tags)).~[Product with Serializable with texttrading.Action](parser.this.buy.|[Product with Serializable with texttrading.Action](parser.this.sell).|[Product with Serializable with texttrading.Action](parser.this.sellAll).|[Product with Serializable with texttrading.Action](parser.this.showPortfolio).|[Product with Serializable with texttrading.Action](parser.this.getSAInfo)).~[Option[String]](parser.this.opt[String](parser.this.regex(parser.this.tail))).^^[Product with Serializable with texttrading.Action](((x0$10: texttrading.parser.~[texttrading.parser.~[Option[String],Product with Serializable with texttrading.Action],Option[String]]) => x0$10 match {
      case (_1: texttrading.parser.~[Option[String],Product with Serializable with texttrading.Action], _2: Option[String])texttrading.parser.~[texttrading.parser.~[Option[String],Product with Serializable with texttrading.Action],Option[String]]((_1: Option[String], _2: Product with Serializable with texttrading.Action)texttrading.parser.~[Option[String],Product with Serializable with texttrading.Action](_, (action @ _)), _) => action
    }));
    parser.this.action
  };
  lazy private[this] var getSAInfo: texttrading.parser.Parser[texttrading.GetInfo] = _;
  <stable> <accessor> lazy def getSAInfo: texttrading.parser.Parser[texttrading.GetInfo] = {
    parser.this.getSAInfo = parser.this.literal("how").~[java.io.Serializable](parser.this.literal("much").|[java.io.Serializable](parser.this.literal("many").~[Option[String]](parser.this.opt[String](parser.this.regex(scala.this.Predef.augmentString("shares?").r))).~[String](parser.this.literal("of")))).~[String](parser.this.ticker).^^[texttrading.GetInfo](((x0$9: texttrading.parser.~[texttrading.parser.~[String,java.io.Serializable],String]) => x0$9 match {
      case (_1: texttrading.parser.~[String,java.io.Serializable], _2: String)texttrading.parser.~[texttrading.parser.~[String,java.io.Serializable],String](_, (ticker @ _)) => new texttrading.GetInfo(ticker)
    }));
    parser.this.getSAInfo
  };
  lazy private[this] var tags: scala.util.matching.Regex = _;
  <stable> <accessor> lazy def tags: scala.util.matching.Regex = {
    parser.this.tags = scala.this.Predef.augmentString("([@#]\\S*)+").r;
    parser.this.tags
  };
  lazy private[this] var tail: scala.util.matching.Regex = _;
  <stable> <accessor> lazy def tail: scala.util.matching.Regex = {
    parser.this.tail = scala.this.Predef.augmentString("(\\S+\\s+)+").r;
    parser.this.tail
  };
  lazy private[this] var buy: texttrading.parser.Parser[texttrading.Buy] = _;
  <stable> <accessor> lazy def buy: texttrading.parser.Parser[texttrading.Buy] = {
    parser.this.buy = parser.this.literal("buy").~[Product with Serializable with texttrading.StockAsset](parser.this.stockAsset).^^[texttrading.Buy](((x0$5: texttrading.parser.~[String,Product with Serializable with texttrading.StockAsset]) => x0$5 match {
      case (_1: String, _2: Product with Serializable with texttrading.StockAsset)texttrading.parser.~[String,Product with Serializable with texttrading.StockAsset](_, (ass @ _)) => new texttrading.Buy(ass)
    }));
    parser.this.buy
  };
  lazy private[this] var sell: texttrading.parser.Parser[texttrading.Sell] = _;
  <stable> <accessor> lazy def sell: texttrading.parser.Parser[texttrading.Sell] = {
    parser.this.sell = parser.this.literal("sell").~[Product with Serializable with texttrading.StockAsset](parser.this.stockAsset).^^[texttrading.Sell](((x0$6: texttrading.parser.~[String,Product with Serializable with texttrading.StockAsset]) => x0$6 match {
      case (_1: String, _2: Product with Serializable with texttrading.StockAsset)texttrading.parser.~[String,Product with Serializable with texttrading.StockAsset](_, (ass @ _)) => new texttrading.Sell(ass)
    }));
    parser.this.sell
  };
  lazy private[this] var sellAll: texttrading.parser.Parser[texttrading.SellAll] = _;
  <stable> <accessor> lazy def sellAll: texttrading.parser.Parser[texttrading.SellAll] = {
    parser.this.sellAll = parser.this.literal("sell").~[String](parser.this.ticker).^^[texttrading.SellAll](((x0$7: texttrading.parser.~[String,String]) => x0$7 match {
      case (_1: String, _2: String)texttrading.parser.~[String,String](_, (ticker @ _)) => new texttrading.SellAll(ticker)
    }));
    parser.this.sellAll
  };
  lazy private[this] var stockAsset: texttrading.parser.Parser[Product with Serializable with texttrading.StockAsset] = _;
  <stable> <accessor> lazy def stockAsset: texttrading.parser.Parser[Product with Serializable with texttrading.StockAsset] = {
    parser.this.stockAsset = parser.this.stockShares.|[Product with Serializable with texttrading.StockAsset](parser.this.stockVolume);
    parser.this.stockAsset
  };
  lazy private[this] var stockShares: texttrading.parser.Parser[texttrading.StockShares] = _;
  <stable> <accessor> lazy def stockShares: texttrading.parser.Parser[texttrading.StockShares] = {
    parser.this.stockShares = parser.this.amount.~[texttrading.parser.~[String,Option[String]]](parser.this.regex(scala.this.Predef.augmentString("shares?").r).~[Option[String]](parser.this.opt[String](parser.this.literal("of")))).~[String](parser.this.ticker).^^[texttrading.StockShares](((x0$2: texttrading.parser.~[texttrading.parser.~[scala.math.BigDecimal,texttrading.parser.~[String,Option[String]]],String]) => x0$2 match {
      case (_1: texttrading.parser.~[scala.math.BigDecimal,texttrading.parser.~[String,Option[String]]], _2: String)texttrading.parser.~[texttrading.parser.~[scala.math.BigDecimal,texttrading.parser.~[String,Option[String]]],String]((_1: scala.math.BigDecimal, _2: texttrading.parser.~[String,Option[String]])texttrading.parser.~[scala.math.BigDecimal,texttrading.parser.~[String,Option[String]]]((shares @ _), _), (ticker @ _)) => new texttrading.StockShares(ticker, new model.Shares(shares))
    }));
    parser.this.stockShares
  };
  lazy private[this] var stockVolume: texttrading.parser.Parser[texttrading.StockDollars] = _;
  <stable> <accessor> lazy def stockVolume: texttrading.parser.Parser[texttrading.StockDollars] = {
    parser.this.stockVolume = parser.this.dollarAmount.~[texttrading.parser.~[Option[String],String]](parser.this.opt[String](parser.this.regex(scala.this.Predef.augmentString("dollars?").r)).~[String](parser.this.literal("of"))).~[String](parser.this.ticker).^^[texttrading.StockDollars](((x0$4: texttrading.parser.~[texttrading.parser.~[scala.math.BigDecimal,texttrading.parser.~[Option[String],String]],String]) => x0$4 match {
      case (_1: texttrading.parser.~[scala.math.BigDecimal,texttrading.parser.~[Option[String],String]], _2: String)texttrading.parser.~[texttrading.parser.~[scala.math.BigDecimal,texttrading.parser.~[Option[String],String]],String]((_1: scala.math.BigDecimal, _2: texttrading.parser.~[Option[String],String])texttrading.parser.~[scala.math.BigDecimal,texttrading.parser.~[Option[String],String]]((dollars @ _), _), (ticker @ _)) => new texttrading.StockDollars(ticker, new model.Dollars(dollars))
    }));
    parser.this.stockVolume
  };
  lazy private[this] var showPortfolio: texttrading.parser.Parser[texttrading.Portfolio.type] = _;
  <stable> <accessor> lazy def showPortfolio: texttrading.parser.Parser[texttrading.Portfolio.type] = {
    parser.this.showPortfolio = parser.this.opt[texttrading.parser.~[texttrading.parser.~[String,String],String]](parser.this.literal("show").~[String](parser.this.literal("me")).~[String](parser.this.literal("my"))).~[String](parser.this.regex(scala.this.Predef.augmentString("portfolio\\S*").r)).|[texttrading.parser.~[Product with Serializable,String]](parser.this.literal("what").~[Option[String]](parser.this.opt[String](parser.this.literal("stocks"))).~[String](parser.this.literal("do")).~[String](parser.this.regex(scala.this.Predef.augmentString("[iI]").r)).~[String](parser.this.regex(scala.this.Predef.augmentString("own\\S*").r).|[String](parser.this.regex(scala.this.Predef.augmentString("have\\S*").r)))).^^[texttrading.Portfolio.type](((x0$8: texttrading.parser.~[Product with Serializable,String]) => x0$8 match {
      case _ => Portfolio
    }));
    parser.this.showPortfolio
  };
  lazy private[this] var amount: texttrading.parser.Parser[scala.math.BigDecimal] = _;
  <stable> <accessor> lazy def amount: texttrading.parser.Parser[scala.math.BigDecimal] = {
    parser.this.amount = parser.this.decimalNumber.^^[scala.math.BigDecimal](((x0$1: String) => x0$1 match {
      case (numText @ _) => scala.math.BigDecimal.apply(numText)
    }));
    parser.this.amount
  };
  lazy private[this] var dollarAmount: texttrading.parser.Parser[scala.math.BigDecimal] = _;
  <stable> <accessor> lazy def dollarAmount: texttrading.parser.Parser[scala.math.BigDecimal] = {
    parser.this.dollarAmount = parser.this.amount.|[scala.math.BigDecimal](parser.this.literal("$").~[scala.math.BigDecimal](parser.this.amount).^^[scala.math.BigDecimal](((x0$3: texttrading.parser.~[String,scala.math.BigDecimal]) => x0$3 match {
      case (_1: String, _2: scala.math.BigDecimal)texttrading.parser.~[String,scala.math.BigDecimal](_, (amount @ _)) => amount
    })));
    parser.this.dollarAmount
  };
  lazy private[this] var ticker: texttrading.parser.Parser[String] = _;
  <stable> <accessor> lazy def ticker: texttrading.parser.Parser[String] = {
    parser.this.ticker = parser.this.ident;
    parser.this.ticker
  };
  implicit def toCSR(s: String): scala.util.parsing.input.CharSequenceReader = new scala.util.parsing.input.CharSequenceReader(s)
}
parser: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=1.000
         parseAc   toCSR
 stockVo     X          
  ticker     X          
  amount     X          
     buy     X          
    sell     X          
 showPor     X          
    tail     X          
    tags     X          
 dollarA     X          
 sellAll     X          
  action     X          
 getSAIn     X          
 stockSh     X          
 stockAs     X          

final object ConsoleTest extends java.lang.Object with ScalaObject {
  def this(): object texttrading.test.ConsoleTest = {
    ConsoleTest.super.this();
    ()
  };
  def main(args: Array[String]): Unit = {
    model.schema.init();
    val backend: texttrading.PitFailBackend = new PitFailBackend();
    val frontend: texttrading.ConsoleFrontend = new ConsoleFrontend("ellbur_k_a");
    val trader: texttrading.TextTrader = new TextTrader(backend, frontend);
    trader.run()
  }
}
ConsoleTest: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
            main

case class GetInfo extends Action with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val ticker: String = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def ticker: String = GetInfo.this.ticker;
  def this(ticker: String): texttrading.GetInfo = {
    GetInfo.super.this();
    ()
  };
  <synthetic> def copy(ticker: String = ticker): texttrading.GetInfo = new texttrading.this.GetInfo(ticker);
  <synthetic> def copy$default$1: String @scala.annotation.unchecked.uncheckedVariance = GetInfo.this.ticker;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(GetInfo.this);
  override def toString(): String = ScalaRunTime.this._toString(GetInfo.this);
  override def equals(x$1: Any): Boolean = GetInfo.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (ticker: String)texttrading.GetInfo((ticker$1 @ _)) if ticker$1.==(ticker) => x$1.asInstanceOf[texttrading.GetInfo].canEqual(GetInfo.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "GetInfo";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => ticker
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[texttrading.GetInfo]()
}
GetInfo: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
  ticker

final case object Portfolio extends Action with ScalaObject with Product with Serializable {
  def this(): object texttrading.Portfolio = {
    Portfolio.super.this();
    ()
  };
  final override def hashCode(): Int = -1169218264;
  final override def toString(): java.lang.String = "Portfolio";
  override def productPrefix: java.lang.String = "Portfolio";
  override def productArity: Int = 0;
  override def productElement(x$1: Int): Any = x$1 match {
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[object texttrading.Portfolio]();
  protected def readResolve(): java.lang.Object = texttrading.this.Portfolio
}
Portfolio: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
         readRes

class DependentListField[A >: Nothing <: Any] extends intform.Field[Seq[A]] with intform.DependentListRender with ScalaObject {
  <paramaccessor> private[this] val fields: () => Seq[intform.Field[A]] = _;
  <stable> <accessor> <paramaccessor> def fields: () => Seq[intform.Field[A]] = DependentListField.this.fields;
  <paramaccessor> private[this] val renderer: () => scala.xml.NodeSeq = _;
  <stable> <accessor> <paramaccessor> def renderer: () => scala.xml.NodeSeq = DependentListField.this.renderer;
  def this(fields: () => Seq[intform.Field[A]], renderer: () => scala.xml.NodeSeq): intform.DependentListField[A] = {
    DependentListField.super.this();
    ()
  };
  def produce(): intform.SubmitResult[Seq[A]] = scalaz.Scalaz.SeqMA[Seq, Option[A]](DependentListField.this.fields.apply().map[Option[A], Seq[Option[A]]](((x$5: intform.Field[A]) => x$5.process()))(collection.this.Seq.canBuildFrom[Option[A]])).sequence[Option, A](scala.this.Predef.conforms[Option[A]], scalaz.this.Traverse.TraversableTraverse[Seq](scalaz.this.CanBuildAnySelf.GenericCanBuildSelf[Seq](collection.this.Seq.canBuildFrom[Nothing])), scalaz.this.Applicative.applicative[Option](scalaz.this.Pure.OptionPure, scalaz.this.Apply.FunctorBindApply[Option](scalaz.this.Functor.OptionFunctor, scalaz.this.Bind.OptionBind))) match {
    case (x: Seq[A])Some[Seq[A]]((a @ _)) => new intform.OK[Seq[A]](a)
    case scala.None => ChildError
  };
  def reset(): Unit = {
    DependentListField.this.fields.apply().map[Unit, Any](((x$6: intform.Field[A]) => x$6.reset()))(collection.this.Seq.canBuildFrom[Unit]);
    ()
  }
}
DependentListField: SCOM=0.500 CC=1.000 LSCC=0.500 CAMC=1.000
         produce   reset
 rendere                
  fields     X       X  

case class StringResponse extends Status with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val msg: String = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def msg: String = StringResponse.this.msg;
  def this(msg: String): texttrading.StringResponse = {
    StringResponse.super.this();
    ()
  };
  <synthetic> def copy(msg: String = msg): texttrading.StringResponse = new texttrading.this.StringResponse(msg);
  <synthetic> def copy$default$1: String @scala.annotation.unchecked.uncheckedVariance = StringResponse.this.msg;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(StringResponse.this);
  override def toString(): String = ScalaRunTime.this._toString(StringResponse.this);
  override def equals(x$1: Any): Boolean = StringResponse.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (msg: String)texttrading.StringResponse((msg$1 @ _)) if msg$1.==(msg) => x$1.asInstanceOf[texttrading.StringResponse].canEqual(StringResponse.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "StringResponse";
  override def productArity: Int = 1;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => msg
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[texttrading.StringResponse]()
}
StringResponse: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
     msg

case class ItemRender extends java.lang.Object with ScalaObject with Product with Serializable {
  <caseaccessor> <paramaccessor> private[this] val field: scala.xml.NodeSeq = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def field: scala.xml.NodeSeq = ItemRender.this.field;
  <caseaccessor> <paramaccessor> private[this] val delete: scala.xml.NodeSeq = _;
  <stable> <caseaccessor> <accessor> <paramaccessor> def delete: scala.xml.NodeSeq = ItemRender.this.delete;
  def this(field: scala.xml.NodeSeq, delete: scala.xml.NodeSeq): intform.ItemRender = {
    ItemRender.super.this();
    ()
  };
  <synthetic> def copy(field: scala.xml.NodeSeq = field, delete: scala.xml.NodeSeq = delete): intform.ItemRender = new intform.this.ItemRender(field, delete);
  <synthetic> def copy$default$2: scala.xml.NodeSeq @scala.annotation.unchecked.uncheckedVariance = ItemRender.this.delete;
  <synthetic> def copy$default$1: scala.xml.NodeSeq @scala.annotation.unchecked.uncheckedVariance = ItemRender.this.field;
  override def hashCode(): Int = ScalaRunTime.this._hashCode(ItemRender.this);
  override def toString(): String = ScalaRunTime.this._toString(ItemRender.this);
  override def equals(x$1: Any): Boolean = ItemRender.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
    case (field: scala.xml.NodeSeq, delete: scala.xml.NodeSeq)intform.ItemRender((field$1 @ _), (delete$1 @ _)) if field$1.==(field).&&(delete$1.==(delete)) => x$1.asInstanceOf[intform.ItemRender].canEqual(ItemRender.this)
    case _ => false
  });
  override def productPrefix: java.lang.String = "ItemRender";
  override def productArity: Int = 2;
  override def productElement(x$1: Int): Any = x$1 match {
    case 0 => field
    case 1 => delete
    case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
  };
  override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[intform.ItemRender]()
}
ItemRender: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
  delete
   field

sealed abstract class Condition extends java.lang.Object with ScalaObject {
  def this(): model.Condition = {
    Condition.super.this();
    ()
  };
  def isTrue: Boolean
}
Condition: SCOM=1.000 CC=1.000 LSCC=1.000 CAMC=1.000
        
  isTrue

abstract trait Transactions extends java.lang.Object with model.Links with net.liftweb.common.Loggable with ScalaObject {
  def /*Transactions*/$init$(): Unit = {
    ()
  };
  private[model] def editDB[A >: Nothing <: Any](trans: => Transactions.this.Transaction[A]): A = {
    <synthetic> private[this] val x$3: (A, Seq[Transactions.this.EditOp]) = (trans: Transactions.this.Transaction[A] @unchecked) match {
      case (result: A, ops: Seq[Transactions.this.EditOp])Transactions.this.Transaction[A]((result @ _), (ops @ _)) => new (A, Seq[Transactions.this.EditOp])(result, ops)
    };
    val result: A = x$3._1;
    val ops: Seq[Transactions.this.EditOp] = x$3._2;
    ops.foreach[Unit](((x$4: Transactions.this.EditOp) => x$4.perform()));
    val tables: Seq[model.Table[_]] = ops.flatMap[model.Table[_], Seq[model.Table[_]]](((x$5: Transactions.this.EditOp) => x$5.affectedTables))(collection.this.Seq.canBuildFrom[model.Table[_]]);
    tables.foreach[Unit](((x$6: model.Table[_]) => x$6.!(Refresh)));
    result
  };
  def readDB[A >: Nothing <: Any](trans: => A): A = trans;
  case class Transaction[A >: Nothing <: Any] extends java.lang.Object with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val result: A = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def result: A = Transaction.this.result;
    <caseaccessor> <paramaccessor> private[this] val ops: Seq[Transactions.this.EditOp] = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def ops: Seq[Transactions.this.EditOp] = Transaction.this.ops;
    def this(result: A, ops: Seq[Transactions.this.EditOp]): Transactions.this.Transaction[A] = {
      Transaction.super.this();
      ()
    };
    def flatMap[B >: Nothing <: Any](f: A => Transactions.this.Transaction[B]): Transactions.this.Transaction[B] = {
      val next: Transactions.this.Transaction[B] = f.apply(Transaction.this.result);
      new Transactions.this.Transaction[B](next.result, Transaction.this.ops.++[Transactions.this.EditOp, Seq[Transactions.this.EditOp]](next.ops)(collection.this.Seq.canBuildFrom[Transactions.this.EditOp]))
    };
    def map[B >: Nothing <: Any](f: A => B): Transactions.this.Transaction[B] = new Transactions.this.Transaction[B](f.apply(Transaction.this.result), Transaction.this.ops);
    def filter(f: A => Boolean): Transactions.this.Transaction[A] = if (f.apply(Transaction.this.result))
      this
    else
      scala.sys.`package`.error("Match error");
    def &[B >: Nothing <: Any](tr: Transactions.this.Transaction[B]): Transactions.this.Transaction[(A, B)] = new Transactions.this.Transaction[(A, B)](new (A, B)(Transaction.this.result, tr.result), Transaction.this.ops.++[Transactions.this.EditOp, Seq[Transactions.this.EditOp]](tr.ops)(collection.this.Seq.canBuildFrom[Transactions.this.EditOp]));
    <synthetic> def copy[A >: Nothing <: Any](result: A = result, ops: Seq[Transactions.this.EditOp] = ops): Transactions.this.Transaction[A] = new Transactions.this.Transaction[A](result, ops);
    <synthetic> def copy$default$2[A >: Nothing <: Any]: Seq[Transactions.this.EditOp] @scala.annotation.unchecked.uncheckedVariance = Transaction.this.ops;
    <synthetic> def copy$default$1[A >: Nothing <: Any]: A @scala.annotation.unchecked.uncheckedVariance = Transaction.this.result;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(Transaction.this);
    override def toString(): String = ScalaRunTime.this._toString(Transaction.this);
    override def equals(x$1: Any): Boolean = Transaction.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (result: Any, ops: Seq[Transactions.this.EditOp])Transactions.this.Transaction[Any]((result$1 @ _), (ops$1 @ _)) if result$1.==(result).&&(ops$1.==(ops)) => x$1.asInstanceOf[Transactions.this.Transaction[A]].canEqual(Transaction.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "Transaction";
    override def productArity: Int = 2;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => result
      case 1 => ops
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[Transactions.this.Transaction[A]]()
  };
  final object Transaction extends java.lang.Object with ScalaObject with Serializable {
    def this(): object Transactions.this.Transaction = {
      Transaction.super.this();
      ()
    };
    def apply[A >: Nothing <: Any](result: A): Transactions.this.Transaction[A] = new Transactions.this.Transaction[A](result, collection.this.Seq.apply[Nothing]());
    case <synthetic> def unapply[A >: Nothing <: Any](x$0: Transactions.this.Transaction[A]): Option[(A, Seq[Transactions.this.EditOp])] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(A, Seq[Transactions.this.EditOp])](new (A, Seq[Transactions.this.EditOp])(x$0.result, x$0.ops));
    case <synthetic> def apply[A >: Nothing <: Any](result: A, ops: Seq[Transactions.this.EditOp]): Transactions.this.Transaction[A] = new Transactions.this.Transaction[A](result, ops)
  };
  @volatile <synthetic> private[this] var Transaction$module: object Transactions.this.Transaction = _;
  final <stable> def Transaction: object Transactions.this.Transaction = new object Transactions.this.Transaction();
  private[this] val TransactionPure: scalaz.Pure[Transactions.this.Transaction] = {
    final class $anon extends java.lang.Object with scalaz.Pure[Transactions.this.Transaction] {
      def this(): anonymous class $anon = {
        $anon.super.this();
        ()
      };
      def pure[A >: Nothing <: Any](a: => A): Transactions.this.Transaction[A] = Transactions.this.Transaction.apply[A](a)
    };
    new $anon()
  };
  implicit <stable> <accessor> def TransactionPure: scalaz.Pure[Transactions.this.Transaction] = Transactions.this.TransactionPure;
  private[this] val TransactionFunctor: scalaz.Functor[Transactions.this.Transaction] = {
    final class $anon extends java.lang.Object with scalaz.Functor[Transactions.this.Transaction] {
      def this(): anonymous class $anon = {
        $anon.super.this();
        ()
      };
      def fmap[A >: Nothing <: Any, B >: Nothing <: Any](t: Transactions.this.Transaction[A], f: A => B): Transactions.this.Transaction[B] = t.map[B](f)
    };
    new $anon()
  };
  implicit <stable> <accessor> def TransactionFunctor: scalaz.Functor[Transactions.this.Transaction] = Transactions.this.TransactionFunctor;
  private[this] val TransactionBind: scalaz.Bind[Transactions.this.Transaction] = {
    final class $anon extends java.lang.Object with scalaz.Bind[Transactions.this.Transaction] {
      def this(): anonymous class $anon = {
        $anon.super.this();
        ()
      };
      def bind[A >: Nothing <: Any, B >: Nothing <: Any](a: Transactions.this.Transaction[A], f: A => Transactions.this.Transaction[B]): Transactions.this.Transaction[B] = a.flatMap[B](f)
    };
    new $anon()
  };
  implicit <stable> <accessor> def TransactionBind: scalaz.Bind[Transactions.this.Transaction] = Transactions.this.TransactionBind;
  sealed abstract trait EditOp extends scala.AnyRef {
    def perform(): Unit;
    <stable> <accessor> def affectedTables: Seq[model.Table[_]]
  };
  case class Insert[R >: Nothing <: model.KL] extends java.lang.Object with Transactions.this.EditOp with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val rec: R = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def rec: R = Insert.this.rec;
    <caseaccessor> <paramaccessor> private[this] val table: model.Table[R] = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def table: model.Table[R] = Insert.this.table;
    def this(rec: R, table: model.Table[R]): Transactions.this.Insert[R] = {
      Insert.super.this();
      ()
    };
    def perform(): Unit = {
      Transactions.this.logger.info("Inserting ".+(Insert.this.rec));
      Insert.this.table.insert(Insert.this.rec)
    };
    private[this] val affectedTables: Seq[model.Table[R]] = collection.this.Seq.apply[model.Table[R]](Insert.this.table);
    <stable> <accessor> def affectedTables: Seq[model.Table[R]] = Insert.this.affectedTables;
    <synthetic> def copy[R >: Nothing <: model.KL](rec: R = rec, table: model.Table[R] = table): Transactions.this.Insert[R] = new Transactions.this.Insert[R](rec, table);
    <synthetic> def copy$default$2[R >: Nothing <: model.KL]: model.Table[R] @scala.annotation.unchecked.uncheckedVariance = Insert.this.table;
    <synthetic> def copy$default$1[R >: Nothing <: model.KL]: R @scala.annotation.unchecked.uncheckedVariance = Insert.this.rec;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(Insert.this);
    override def toString(): String = ScalaRunTime.this._toString(Insert.this);
    override def equals(x$1: Any): Boolean = Insert.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (rec: model.KL, table: model.Table[model.KL])Transactions.this.Insert[model.KL]((rec$1 @ _), (table$1 @ _)) if rec$1.==(rec).&&(table$1.==(table)) => x$1.asInstanceOf[Transactions.this.Insert[R]].canEqual(Insert.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "Insert";
    override def productArity: Int = 2;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => rec
      case 1 => table
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[Transactions.this.Insert[R]]()
  };
  final <synthetic> object Insert extends java.lang.Object with ScalaObject with Serializable {
    def this(): object Transactions.this.Insert = {
      Insert.super.this();
      ()
    };
    final override def toString(): java.lang.String = "Insert";
    case <synthetic> def unapply[R >: Nothing <: model.KL](x$0: Transactions.this.Insert[R]): Option[(R, model.Table[R])] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(R, model.Table[R])](new (R, model.Table[R])(x$0.rec, x$0.table));
    case <synthetic> def apply[R >: Nothing <: model.KL](rec: R, table: model.Table[R]): Transactions.this.Insert[R] = new Transactions.this.Insert[R](rec, table)
  };
  @volatile <synthetic> private[this] var Insert$module: object Transactions.this.Insert = _;
  final <synthetic> <stable> def Insert: object Transactions.this.Insert = new object Transactions.this.Insert();
  case class Update[R >: Nothing <: model.KL] extends java.lang.Object with Transactions.this.EditOp with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val rec: R = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def rec: R = Update.this.rec;
    <caseaccessor> <paramaccessor> private[this] val by: R => R = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def by: R => R = Update.this.by;
    <caseaccessor> <paramaccessor> private[this] val table: model.Table[R] = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def table: model.Table[R] = Update.this.table;
    def this(rec: R, by: R => R, table: model.Table[R]): Transactions.this.Update[R] = {
      Update.super.this();
      ()
    };
    def perform(): Unit = Update.this.table.update({
      Transactions.this.logger.info("Updating ".+(Update.this.rec));
      val old: R = Update.this.table.lookup(Update.this.rec.id).getOrElse[R](throw Transactions.this.NotFound);
      Transactions.this.logger.info("->Updating ".+(old));
      val next: R = Update.this.by.apply(old);
      scala.this.Predef.assert(next.id.==(old.id), "You changed an object\'s ID");
      Transactions.this.logger.info("~>Updating ".+(next));
      next
    });
    private[this] val affectedTables: Seq[model.Table[R]] = collection.this.Seq.apply[model.Table[R]](Update.this.table);
    <stable> <accessor> def affectedTables: Seq[model.Table[R]] = Update.this.affectedTables;
    <synthetic> def copy[R >: Nothing <: model.KL](rec: R = rec, by: R => R = by, table: model.Table[R] = table): Transactions.this.Update[R] = new Transactions.this.Update[R](rec, by, table);
    <synthetic> def copy$default$3[R >: Nothing <: model.KL]: model.Table[R] @scala.annotation.unchecked.uncheckedVariance = Update.this.table;
    <synthetic> def copy$default$2[R >: Nothing <: model.KL]: R => R @scala.annotation.unchecked.uncheckedVariance = Update.this.by;
    <synthetic> def copy$default$1[R >: Nothing <: model.KL]: R @scala.annotation.unchecked.uncheckedVariance = Update.this.rec;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(Update.this);
    override def toString(): String = ScalaRunTime.this._toString(Update.this);
    override def equals(x$1: Any): Boolean = Update.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (rec: model.KL, by: model.KL => model.KL, table: model.Table[model.KL])Transactions.this.Update[model.KL]((rec$2 @ _), (by$1 @ _), (table$2 @ _)) if rec$2.==(rec).&&(by$1.==(by)).&&(table$2.==(table)) => x$1.asInstanceOf[Transactions.this.Update[R]].canEqual(Update.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "Update";
    override def productArity: Int = 3;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => rec
      case 1 => by
      case 2 => table
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[Transactions.this.Update[R]]()
  };
  final <synthetic> object Update extends java.lang.Object with ScalaObject with Serializable {
    def this(): object Transactions.this.Update = {
      Update.super.this();
      ()
    };
    final override def toString(): java.lang.String = "Update";
    case <synthetic> def unapply[R >: Nothing <: model.KL](x$0: Transactions.this.Update[R]): Option[(R, R => R, model.Table[R])] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(R, R => R, model.Table[R])](new (R, R => R, model.Table[R])(x$0.rec, x$0.by, x$0.table));
    case <synthetic> def apply[R >: Nothing <: model.KL](rec: R, by: R => R, table: model.Table[R]): Transactions.this.Update[R] = new Transactions.this.Update[R](rec, by, table)
  };
  @volatile <synthetic> private[this] var Update$module: object Transactions.this.Update = _;
  final <synthetic> <stable> def Update: object Transactions.this.Update = new object Transactions.this.Update();
  case class Delete[R >: Nothing <: model.KL] extends java.lang.Object with Transactions.this.EditOp with ScalaObject with Product with Serializable {
    <caseaccessor> <paramaccessor> private[this] val rec: R = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def rec: R = Delete.this.rec;
    <caseaccessor> <paramaccessor> private[this] val table: model.Table[R] = _;
    <stable> <caseaccessor> <accessor> <paramaccessor> def table: model.Table[R] = Delete.this.table;
    def this(rec: R, table: model.Table[R]): Transactions.this.Delete[R] = {
      Delete.super.this();
      ()
    };
    def perform(): Unit = {
      Transactions.this.logger.info("Deleting ".+(Delete.this.rec));
      Delete.this.table.delete(Delete.this.rec)
    };
    private[this] val affectedTables: Seq[model.Table[R]] = collection.this.Seq.apply[model.Table[R]](Delete.this.table);
    <stable> <accessor> def affectedTables: Seq[model.Table[R]] = Delete.this.affectedTables;
    <synthetic> def copy[R >: Nothing <: model.KL](rec: R = rec, table: model.Table[R] = table): Transactions.this.Delete[R] = new Transactions.this.Delete[R](rec, table);
    <synthetic> def copy$default$2[R >: Nothing <: model.KL]: model.Table[R] @scala.annotation.unchecked.uncheckedVariance = Delete.this.table;
    <synthetic> def copy$default$1[R >: Nothing <: model.KL]: R @scala.annotation.unchecked.uncheckedVariance = Delete.this.rec;
    override def hashCode(): Int = ScalaRunTime.this._hashCode(Delete.this);
    override def toString(): String = ScalaRunTime.this._toString(Delete.this);
    override def equals(x$1: Any): Boolean = Delete.this.eq(x$1.asInstanceOf[java.lang.Object]).||(x$1 match {
      case (rec: model.KL, table: model.Table[model.KL])Transactions.this.Delete[model.KL]((rec$3 @ _), (table$3 @ _)) if rec$3.==(rec).&&(table$3.==(table)) => x$1.asInstanceOf[Transactions.this.Delete[R]].canEqual(Delete.this)
      case _ => false
    });
    override def productPrefix: java.lang.String = "Delete";
    override def productArity: Int = 2;
    override def productElement(x$1: Int): Any = x$1 match {
      case 0 => rec
      case 1 => table
      case _ => throw new java.lang.IndexOutOfBoundsException(x$1.toString())
    };
    override def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[Transactions.this.Delete[R]]()
  };
  final <synthetic> object Delete extends java.lang.Object with ScalaObject with Serializable {
    def this(): object Transactions.this.Delete = {
      Delete.super.this();
      ()
    };
    final override def toString(): java.lang.String = "Delete";
    case <synthetic> def unapply[R >: Nothing <: model.KL](x$0: Transactions.this.Delete[R]): Option[(R, model.Table[R])] = if (x$0.==(null))
      scala.this.None
    else
      new Some[(R, model.Table[R])](new (R, model.Table[R])(x$0.rec, x$0.table));
    case <synthetic> def apply[R >: Nothing <: model.KL](rec: R, table: model.Table[R]): Transactions.this.Delete[R] = new Transactions.this.Delete[R](rec, table)
  };
  @volatile <synthetic> private[this] var Delete$module: object Transactions.this.Delete = _;
  final <synthetic> <stable> def Delete: object Transactions.this.Delete = new object Transactions.this.Delete();
  implicit def toOps[R >: Nothing <: model.KL](rec: R): java.lang.Object{def insert(implicit table: model.Table[R]): Transactions.this.Transaction[R]; def update(by: R => R)(implicit table: model.Table[R]): Transactions.this.Transaction[Unit]; def delete(implicit table: model.Table[R]): Transactions.this.Transaction[R]; def refetch(implicit table: model.Table[R]): R} = {
    final class $anon extends scala.AnyRef {
      def this(): anonymous class $anon = {
        $anon.super.this();
        ()
      };
      def insert(implicit table: model.Table[R]): Transactions.this.Transaction[R] = new Transactions.this.Transaction[R](rec, {
        <synthetic> val x$7: Transactions.this.Insert[R] = new Transactions.this.Insert[R](rec, table);
        immutable.this.Nil.::[Transactions.this.Insert[R]](x$7)
      });
      def update(by: R => R)(implicit table: model.Table[R]): Transactions.this.Transaction[Unit] = new Transactions.this.Transaction[Unit]((), {
        <synthetic> val x$8: Transactions.this.Update[R] = new Transactions.this.Update[R](rec, by, table);
        immutable.this.Nil.::[Transactions.this.Update[R]](x$8)
      });
      def delete(implicit table: model.Table[R]): Transactions.this.Transaction[R] = new Transactions.this.Transaction[R](rec, {
        <synthetic> val x$9: Transactions.this.Delete[R] = new Transactions.this.Delete[R](rec, table);
        immutable.this.Nil.::[Transactions.this.Delete[R]](x$9)
      });
      def refetch(implicit table: model.Table[R]): R = table.lookup(rec.id).getOrElse[R](throw Transactions.this.NotFound)
    };
    new $anon()
  };
  implicit def toOrCreate[R >: Nothing <: Any](already: => R): java.lang.Object{def orCreate(trans: => Transactions.this.Transaction[R]): Transactions.this.Transaction[R]} = {
    final class $anon extends scala.AnyRef {
      def this(): anonymous class $anon = {
        $anon.super.this();
        ()
      };
      def orCreate(trans: => Transactions.this.Transaction[R]): Transactions.this.Transaction[R] = try {
        new Transactions.this.Transaction[R](already, immutable.this.Nil)
      } catch {
        case (_: errors.package.BadUser) => trans
      }
    };
    new $anon()
  };
  implicit def toOrCreateOpt[R >: Nothing <: Any](already: => Option[R]): java.lang.Object{def orCreate(trans: => Transactions.this.Transaction[R]): Transactions.this.Transaction[R]} = {
    final class $anon extends scala.AnyRef {
      def this(): anonymous class $anon = {
        $anon.super.this();
        ()
      };
      def orCreate(trans: => Transactions.this.Transaction[R]): Transactions.this.Transaction[R] = already match {
        case (x: R)Some[R]((r @ _)) => new Transactions.this.Transaction[R](r, immutable.this.Nil)
        case scala.None => trans
      }
    };
    new $anon()
  };
  def mutually[A >: Nothing <: Any](op: (model.package.Key, model.package.Key) => A): A = op.apply(model.this.`package`.nextID, model.this.`package`.nextID);
  def mutually[A >: Nothing <: Any](op: (model.package.Key, model.package.Key, model.package.Key) => A): A = op.apply(model.this.`package`.nextID, model.this.`package`.nextID, model.this.`package`.nextID)
}
Transactions: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.125
          readDB mutuall   toOps toOrCre Transac  editDB toOrCre mutuall
 Update$                                                                
 Delete$                                                                
 Transac                                                                
 Insert$                                                                

class TestForm extends java.lang.Object with intform.Page with net.liftweb.common.Loggable with ScalaObject {
  def this(): code.snippet.TestForm = {
    TestForm.super.this();
    ()
  };
  def render: scala.xml.Elem = {
    {
      new scala.xml.Elem(null, "p", scala.xml.Null, scala.this.Predef.$scope, ({
        val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
        $buf.&+(new scala.xml.Text("No"));
        $buf
      }: _*))
    }
  }
}
TestForm: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
          render

final object KL extends java.lang.Object with ScalaObject {
  def this(): object model.KL = {
    KL.super.this();
    ()
  };
  implicit def toLink[R >: Nothing <: model.KL](kl: R): model.Link[R] = new model.Link[R](kl.id)
}
KL: SCOM=1.000 CC=1.000 LSCC=0.000 CAMC=1.000
          toLink

class Offers extends java.lang.Object with code.comet.Refreshable with net.liftweb.common.Loggable with ScalaObject {
  def this(): code.comet.Offers = {
    Offers.super.this();
    ()
  };
  def registerWith: model.Table[model.schema.AuctionOffer] = model.schema.auctionOffers;
  def render: net.liftweb.http.RenderOut = Offers.this.nsToNsFuncToRenderOut(((in: scala.xml.NodeSeq) => model.schema.readDB[scala.xml.NodeSeq]({
    try {
      val myOffers: List[model.schema.DerivativeOffer] = control.PortfolioSwitcher.currentPortfolio.myDerivativeOffers;
      def result: scala.xml.NodeSeq = if (myOffers.isEmpty)
        xml.this.NodeSeq.seqToNodeSeq(immutable.this.Nil)
      else
        {
          {
            var $md: scala.xml.MetaData = scala.xml.Null;
            $md = new scala.xml.UnprefixedAttribute("id", new scala.xml.Text("offers"), $md);
            $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("container block"), $md);
            new scala.xml.Elem(null, "div", $md, scala.this.Predef.$scope, ({
              val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
              $buf.&+(new scala.xml.Text("\012                        "));
              $buf.&+({
                {
                  new scala.xml.Elem(null, "h2", scala.xml.Null, scala.this.Predef.$scope, ({
                    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                    $buf.&+(new scala.xml.Text("Pending Offer"));
                    $buf
                  }: _*))
                }
              });
              $buf.&+(new scala.xml.Text("\012                        "));
              $buf.&+(if (myOffers.length.==(1))
                {
                  {
                    new scala.xml.Elem(null, "p", scala.xml.Null, scala.this.Predef.$scope, ({
                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                      $buf.&+(new scala.xml.Text("Another user has offered to sell you a derivative.\012                            Look at the table below for more information and\012                            choose whether to accept or decline this offer."));
                      $buf
                    }: _*))
                  }
                }
              else
                {
                  {
                    new scala.xml.Elem(null, "p", scala.xml.Null, scala.this.Predef.$scope, ({
                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                      $buf.&+(new scala.xml.Text("Other users have offered to sell you\012                            derivatives. Look at the table below for\012                            information about the derivatives and choose\012                            whether to accept or decline the offers."));
                      $buf
                    }: _*))
                  }
                });
              $buf.&+(new scala.xml.Text("\012                        "));
              $buf.&+({
                {
                  var $md: scala.xml.MetaData = scala.xml.Null;
                  $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("boxy"), $md);
                  new scala.xml.Elem(null, "table", $md, scala.this.Predef.$scope, ({
                    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                    $buf.&+(new scala.xml.Text("\012                            "));
                    $buf.&+({
                      {
                        var $md: scala.xml.MetaData = scala.xml.Null;
                        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("from"), $md);
                        new scala.xml.Elem(null, "col", $md, scala.this.Predef.$scope)
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012                            "));
                    $buf.&+({
                      {
                        var $md: scala.xml.MetaData = scala.xml.Null;
                        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("securities"), $md);
                        new scala.xml.Elem(null, "col", $md, scala.this.Predef.$scope)
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012                            "));
                    $buf.&+({
                      {
                        var $md: scala.xml.MetaData = scala.xml.Null;
                        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("expiration"), $md);
                        new scala.xml.Elem(null, "col", $md, scala.this.Predef.$scope)
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012                            "));
                    $buf.&+({
                      {
                        var $md: scala.xml.MetaData = scala.xml.Null;
                        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("condition"), $md);
                        new scala.xml.Elem(null, "col", $md, scala.this.Predef.$scope)
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012                            "));
                    $buf.&+({
                      {
                        var $md: scala.xml.MetaData = scala.xml.Null;
                        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("strike-price"), $md);
                        new scala.xml.Elem(null, "col", $md, scala.this.Predef.$scope)
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012                            "));
                    $buf.&+({
                      {
                        var $md: scala.xml.MetaData = scala.xml.Null;
                        $md = new scala.xml.UnprefixedAttribute("class", new scala.xml.Text("buttons"), $md);
                        new scala.xml.Elem(null, "col", $md, scala.this.Predef.$scope)
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012                            "));
                    $buf.&+({
                      {
                        new scala.xml.Elem(null, "thead", scala.xml.Null, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(new scala.xml.Text("\012                                "));
                          $buf.&+({
                            {
                              new scala.xml.Elem(null, "tr", scala.xml.Null, scala.this.Predef.$scope, ({
                                val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                                $buf.&+(new scala.xml.Text("\012                                    "));
                                $buf.&+({
                                  {
                                    new scala.xml.Elem(null, "th", scala.xml.Null, scala.this.Predef.$scope, ({
                                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                                      $buf.&+(new scala.xml.Text("From"));
                                      $buf
                                    }: _*))
                                  }
                                });
                                $buf.&+(new scala.xml.Text("\012                                    "));
                                $buf.&+({
                                  {
                                    new scala.xml.Elem(null, "th", scala.xml.Null, scala.this.Predef.$scope, ({
                                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                                      $buf.&+(new scala.xml.Text("Securities"));
                                      $buf
                                    }: _*))
                                  }
                                });
                                $buf.&+(new scala.xml.Text("\012                                    "));
                                $buf.&+({
                                  {
                                    new scala.xml.Elem(null, "th", scala.xml.Null, scala.this.Predef.$scope, ({
                                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                                      $buf.&+(new scala.xml.Text("On"));
                                      $buf
                                    }: _*))
                                  }
                                });
                                $buf.&+(new scala.xml.Text("\012                                    "));
                                $buf.&+({
                                  {
                                    new scala.xml.Elem(null, "th", scala.xml.Null, scala.this.Predef.$scope, ({
                                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                                      $buf.&+(new scala.xml.Text("If"));
                                      $buf
                                    }: _*))
                                  }
                                });
                                $buf.&+(new scala.xml.Text("\012                                    "));
                                $buf.&+({
                                  {
                                    new scala.xml.Elem(null, "th", scala.xml.Null, scala.this.Predef.$scope, ({
                                      val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                                      $buf.&+(new scala.xml.Text("For"));
                                      $buf
                                    }: _*))
                                  }
                                });
                                $buf.&+(new scala.xml.Text("\012                                    "));
                                $buf.&+({
                                  {
                                    new scala.xml.Elem(null, "th", scala.xml.Null, scala.this.Predef.$scope)
                                  }
                                });
                                $buf.&+(new scala.xml.Text("\012                                "));
                                $buf
                              }: _*))
                            }
                          });
                          $buf.&+(new scala.xml.Text("\012                            "));
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012                            "));
                    $buf.&+({
                      {
                        new scala.xml.Elem(null, "tbody", scala.xml.Null, scala.this.Predef.$scope, ({
                          val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                          $buf.&+(new scala.xml.Text("\012                                "));
                          $buf.&+(myOffers.map[scala.xml.Elem, Any]({
                            ((o: model.schema.DerivativeOffer) => offer(o))
                          })(immutable.this.List.canBuildFrom[scala.xml.Elem]));
                          $buf.&+(new scala.xml.Text("\012                            "));
                          $buf
                        }: _*))
                      }
                    });
                    $buf.&+(new scala.xml.Text("\012                        "));
                    $buf
                  }: _*))
                }
              });
              $buf.&+(new scala.xml.Text("\012                    "));
              $buf
            }: _*))
          }
        };
      def offer(o: model.schema.DerivativeOffer): scala.xml.Elem = {
        val deriv: model.Derivative = o.derivative;
        {
          {
            new scala.xml.Elem(null, "tr", scala.xml.Null, scala.this.Predef.$scope, ({
              val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
              $buf.&+(new scala.xml.Text("\012                    "));
              $buf.&+({
                {
                  new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                    $buf.&+(snippet.PortfolioLink.apply(model.this.Link.extract[model.schema.Portfolio](o.from)(model.schema.portfolios)));
                    $buf
                  }: _*))
                }
              });
              $buf.&+(new scala.xml.Text("\012                    "));
              $buf.&+({
                {
                  new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                    $buf.&+(formats.`package`.securitiesFormatted(deriv.securities).toHumanString);
                    $buf
                  }: _*))
                }
              });
              $buf.&+(new scala.xml.Text("\012                    "));
              $buf.&+({
                {
                  new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                    $buf.&+(formats.`package`.dateTimeFormatted(deriv.exec).toNearbyString);
                    $buf
                  }: _*))
                }
              });
              $buf.&+(new scala.xml.Text("\012                    "));
              $buf.&+({
                {
                  new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                    $buf.&+(formats.`package`.conditionFormatted(deriv.condition).toHumanString);
                    $buf
                  }: _*))
                }
              });
              $buf.&+(new scala.xml.Text("\012                    "));
              $buf.&+({
                {
                  new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                    $buf.&+(o.price.$);
                    $buf
                  }: _*))
                }
              });
              $buf.&+(new scala.xml.Text("\012                    "));
              $buf.&+({
                {
                  new scala.xml.Elem(null, "td", scala.xml.Null, scala.this.Predef.$scope, ({
                    val $buf: scala.xml.NodeBuffer = new scala.xml.NodeBuffer();
                    $buf.&+(Offers.this.acceptOffer(o.id));
                    $buf.&+(new scala.xml.Text(" "));
                    $buf.&+(Offers.this.declineOffer(o.id));
                    $buf
                  }: _*))
                }
              });
              $buf.&+(new scala.xml.Text("\012                "));
              $buf
            }: _*))
          }
        }
      };
      result
    } catch {
      case control.LoginManager.NotLoggedIn => {
        {
          new scala.xml.Elem(null, "span", scala.xml.Null, scala.this.Predef.$scope)
        }
      }
    }
  })));
  def acceptOffer(offerID: String): scala.xml.NodeSeq = intform.FormSubmit.rendered("Accept")({
    try {
      control.PortfolioSwitcher.currentPortfolio.userAcceptOffer(offerID);
      net.liftweb.http.js.JsCmds.Noop
    } catch {
      case control.LoginManager.NotLoggedIn => throw new intform.BadInput("You\'re not logged in")
      case model.schema.NoSuchOffer => throw new intform.BadInput("This offer has expired")
    }
  });
  def declineOffer(offerID: String): scala.xml.NodeSeq = intform.FormSubmit.rendered("Decline")({
    try {
      control.PortfolioSwitcher.currentPortfolio.userDeclineOffer(offerID);
      net.liftweb.http.js.JsCmds.Noop
    } catch {
      case control.LoginManager.NotLoggedIn => throw new intform.BadInput("You\'re not logged in")
      case model.schema.NoSuchOffer => throw new intform.BadInput("This offer has expired")
    }
  })
}
Offers: SCOM=0.000 CC=0.000 LSCC=0.000 CAMC=0.500
          render decline acceptO registe

